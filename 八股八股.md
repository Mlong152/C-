<center><h1>C++面试八股</center>
[TOC]



# 一、C++基础

## １、C++中值传递和引用传递的区别？

- **值传递**

  - 定义：在函数调用时，将实参的值拷贝一份给形参。函数内部对形参的修改不会影响实参。

  - 特点

    - 函数内部对参数的修改不会改变原始数据
    - 对于**基本数据类型或较小的对象**，使用值传递通常比较高效
    - 对于**较大的对象**，值传递可能导致不必要的开销，因为需要复制整个对象。

  - ```c++
    void modifyValue(int x)
    {
        x = 10;//只改变函数内部的x值
    }
    int main()
    {
        int a = 5;
        modifyValue(a);
    }
    ```

- **引用传递**

  - 定义：在函数调用时，将实参的引用（即实参的地址）传递给形参。函数内部对形参的修改会直接影响到实参的值。

  - 特点：

    - 函数内部对参数的修改会改变原始数据
    - 避免了复制大对象的开销，因此对于大对象更为高效
    - 可以通过引用返回多个值
    - 可以使用`const`修饰符来保证函数内对引用参数的只读访问。

  - ```c++
    void modifyReference(int &x)
    {
        x = 10;//直接修改了原始数据
    }
    int main()
    {
        int a = 5;
        modifyReference(a);
    }
    ```

- **总结：**

  - 值传递传递的是**参数的副本**，函数内部对参数的修改**不会影响**到原始数据。
  - 引用传递传递的是**参数的引用（地址）**，函数内部对参数的修改**会直接影响**到原始数据。



## ２、C和C++的区别？

- **编程范式**
  - C：
    - 主要是**过程式**编程语言，强调函数和过程的调用，编程时主要关注函数和数据的操作。
  - C++：
    - 一种**面向对象**的编程语言，除了支持过程式编程外，还引入了面向对象的编程范式。支持类、继承、多态、封装等面向对象特性。
- **数据抽象**
  - C：
    - 数据和函数是分开的，数据类型的定义只能通过结构体（`struct`）来实现。
  - C++：
    - 引入了类（`class`）和对象（`object`）的概念，可以将数据和操作数据的函数封装在一起，从而实现数据抽象和封装。
- **函数重载**
  - C：
    - 不支持函数重载，函数名必须唯一。
  - C++：
    - 支持函数重载，即允许多个函数拥有相同的名称，但参数列表必须不同。
- **运算符重载**
  - C：
    - 不支持运算符重载。运算符的功能是固定的。
  - C++：
    - 支持运算符重载，可以为自定义类型定义运算符的行为，使得操作自定义类型的数据更加直观。
- **模板**
  - C：
    - 不支持模板。
  - C++：
    - 支持模板（`template`），可以编写泛型代码，使得函数和类可以处理不同的数据类型而不需要重复编写相似的代码。
- **异常处理**
  - C：
    - 没有内建的异常处理机制，通常使用错误码或其他机制来处理异常。
  - C++：
    - 提供了内存处理机制（`try`、`catch`、`throw`），可以捕捉和处理运行时错误，使得错误处理更加灵活和优雅。
- **标准库**
  - C：
    - 提供了标准库（如`stdio.h`、`stdlib.h`、`string.h`）同于基本的输入输出、内存管理和字符串管理。
  - C++：
    - 提供了更丰富的标准库，包括`STL`（标准模板库），如`vector`、`list`、`map`、`set`、`algorithm`等，支持更复杂的数据结构和算法。
- **内存管理**
  - C：
    - 使用`malloc`和`free`**函数**进行动态内存管理。
  - C++：
    - 引入了`new`和`delete`**操作符**用于动态内存管理，提供了更高层的内存管理机制，并可以结合`RAII`（资源获取即初始化）来自动管理资源。
- **命名空间**
  - C：
    - 没有命名空间的概念，所有的标识符都在同一个全局命名空间中。
  - C++：
    - 引入了命名空间（`namespace`）来组织代码，避免命名冲突。
- **默认参数**
  - C：
    - 不支持函数默认参数。
  - C++：
    - 支持函数默认参数，可以在函数声明中指定参数的默认值。



## ３、什么是左值和右值？有什么区别？

- **左值（`lvalue`）**

  - 定义：表示一个具有**可持久性**和**可寻址**的对象和位置，即**可以引用和修改**的对象。左值通常可以出现在赋值语句的左侧。

  - 特点：

    - 可以作为赋值语句的左侧。
    - 可以取地址（使用取地址符`&`）。
    - 代表一个对象的存储位置。

  - ```c++
    int x = 10;//x是一个左值，因为它表示一个可以被赋值的存储位置
    x = 20;//x仍然是一个左值
    ```

- **右值（`rvalue`）**

  - 定义：表示一个**没有可持久性**和**不可寻址**的值，通常是临时的或者计算结果。右值通常出现在赋值语句的右侧。

  - 特点：

    - 不能作为赋值语句左侧。
    - 不能取地址（没有存储位置）。
    - 表示一个值而不是存储位置。

  - ```c++
    int x = 10;//10是一个右值，因为它是一个值而不是一个存储位置
    x = x + 5;//x + 5 是右值，因为它表示一个计算结果
    ```

- **区别**

  - 可寻址性
    - 左值：可以取地址，表示对象的实际存储位置。
    - 右值：不可以取地址，因为它通常是临时的值或者计算结果
  - 赋值
    - 左值：可以作为赋值操作的左侧（例如：`x = 10;`）。
    - 右值：不能作为赋值操作的左侧，只能出现在赋值操作的右侧（例如：`x = x + 5;`）。
  - 生命周期
    - 左值：表示持久存在的对象或存储位置，生命周期通常比右值长。
    - 右值：通常是临时的，生命周期较短。

- **拓展**

  - `xvalue（eXpiring value）`：一种特殊的右值，表示即将被销毁的对象。常用于`std::move`（将一个左值转换成右值）的返回值。`xvalue`可以被用于资源的移动语义。

  - `prvalue（Pure rvalue）`：纯右值，表示临时值，例如常量值或计算结果。

  - `lvalue reference`和`rvalue reference`：

    - `lvalue reference(T&)`：绑定到左值。
    - `rvalue reference(T&&)`：绑定到右值（或`xvalue`），用于实现移动语义和完美转发。

  - ```c++
    int a = 5;//a是左值，5是右值
    int &b = a;//b是左值引用，绑定到左值a
    int &&c = 10;//c是右值引用，绑定到右值10
    c = std::move(a);//std::move(a)是一个xvalue，c可以接受它
    ```



## 4、什么是移动语义和完美转发？

- **移动语义：**

  - 定义：移动语义允许资源的所有权在对象之间转移，而不是赋值资源。它主要通过**移动构造函数**和**移动赋值运算符函数**来实现。这种机制可以提高性能，尤其是在处理大型数据结构或具有动态分配内存的对象时。

  - 基本操作：

    - 移动构造函数：从一个已有的对象中“窃取”资源并初始化一个新对象。

      - ```c++
        Example(Example&& other) noexcept;
        ```

    - 移动赋值运算符函数：将一个已有对象的资源转移到另一个对象，并释放原有对象的资源。

      - ```c++
        Example& operator=(Example&& other) noexcept;
        ```

  - 使用场景：

    - 临时对象的处理

      - 当一个函数返回一个临时对象时，如果不使用移动语义，编译器将会调用复制构造函数，这会导致对象的深拷贝，增加性能开销。移动构造函数可以通过“移动”临时对象的资源，避免不必要的深拷贝。

        ```c++
        class MyClass {
        public:
            MyClass() {
                data = new int[100];  // 动态分配资源
                std::cout << "Constructor\n";
            }
            ~MyClass() {
                delete[] data;
                std::cout << "Destructor\n";
            }
        
            // 移动构造函数
            MyClass(MyClass&& other) noexcept {
                data = other.data;   // 资源转移
                other.data = nullptr; // 清空源对象的指针
                std::cout << "Move Constructor\n";
            }
        
        private:
            int* data;
        };
        
        MyClass createObject() {
            return MyClass();  // 返回一个临时对象
        }
        
        int main() {
            MyClass obj = createObject();  // 调用移动构造函数
            return 0;
        }
        ```

        在 `createObject` 中返回的临时对象会使用移动构造函数，将其资源“转移”给 `obj`，避免了对象的深拷贝。

    - 容器的元素移动

      - 在标准模板库（STL）容器（如 `std::vector`、`std::list` 等）中，当容器**重新分配内存**时，或者当容器通过 `push_back`、`emplace_back` 等操作添加新元素时，通常会涉及到元素的移动。如果元素类型支持移动构造函数，则容器可以移动这些元素的资源，而不是逐个复制。

        ```c++
        std::vector<MyClass> vec;
        vec.push_back(createObject());  // 如果 MyClass 支持移动构造函数，会优先调用它
        ```

        在 `push_back` 中，会调用 `MyClass` 的移动构造函数将临时对象移动到 `vec` 容器中。

    - 所有权转移

      - 在处理需要**转移资源所有权**的场景时，移动构造函数和移动赋值运算符是非常重要的。例如，`std::unique_ptr` 作为独占所有权的智能指针，当它被传递或赋值时，资源的所有权需要转移，而不能简单地复制指针指向的资源。

        ```c++
        std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
        std::unique_ptr<int> ptr2 = std::move(ptr1);  // 使用移动构造函数转移所有权
        ```

        在上述代码中，`std::move` 将 `ptr1` 的资源转移给 `ptr2`，`ptr1` 将变为空指针。

    - 避免不必要的深拷贝

      - 在处理需要大量数据的类时，如果不提供移动构造函数和移动赋值运算符，默认情况下会调用复制构造函数，这可能导致不必要的深拷贝。提供移动构造函数和移动赋值运算符可以显著减少拷贝次数，提高程序性能。

        ```c++
        MyClass obj1;
        MyClass obj2 = std::move(obj1);  // 使用移动构造函数，将 obj1 的资源转移给 obj2
        ```

        通过 `std::move`，可以避免 `obj1` 的数据被复制，而是直接转移给 `obj2`。

    - 右值引用的函数参数

      - 当函数参数是右值引用（`T&&`）时，意味着函数可以“窃取”传递进来的资源，这种情况下通常会调用移动构造函数或移动赋值运算符。

        ```c++
        void process(MyClass&& obj) {
            MyClass localObj = std::move(obj);  // 调用移动构造函数
        }
        ```

        函数 `process` 接受一个右值引用对象，并通过 `std::move` 将其资源转移到 `localObj` 中。

  - 总结：

    - 当类**管理动态资源**（如动态内存、文件句柄、网络连接等），并且拷贝这些资源的代价很高时，可以编写移动构造函数和移动赋值运算符函数。
    - 当类的资源需要在对象间**转移所有权**，而不是复制时，可以编写移动构造函数和移动赋值运算符函数。
    - 当类的大量实例被存储在 STL 容器中，并且容器经常需要重新分配或扩展时，可以编写移动构造函数和移动赋值运算符函数。

  - 示例：

    - ```c++
      #include <iostream>
      #include <utility> // for std::move
      
      class Example{
      public:
          Example()
          :data(new int[10]())
          {
              std::cout << "Constructor" << std::endl;
          }
          
          ~Example()
          {
              delete [] data;
              data = nullptr;
              std::cout << "Destructor" << std::endl;
          }
          
          Example(Example&& other) noexcept
          :data(other.data)
          {
              other.data = nullptr;
              std::cout << "Move Constructor" << std::endl;
          }
          
          Example& operator=(Example&& other) noexcept
          {
              if(this != &other)
              {
                  delete [] data;
                  data = other.data;
                  other.data = nullptr;
                  std::cout << "Move Assignment" << std::endl;
              }
              return *this;
          }
      private:
          int *data;
      };
      
      int main()
      {
          Example a;//调用默认构造函数
          Example b = std::move(a);//调用移动构造函数
          
          Example c;//调用默认构造函数
          c = std::move(b);//调用移动赋值运算符函数
          
          return 0;
      }
      ```

- **完美转发：**

  - 定义：完美转发是一种技术，它允许函数模板将参数以其原始类型（左值或者右值）传递给其他函数，而不失去其值类别。这种机制通过`std::forward`函数实现，并结合了通过引用（也称为转发引用）来实现。

  - 核心概念：

    - **通用引用（Forwarding Reference）：**可以接受左值或者右值，通常在函数模板中定义。其语法为`T&&`，但`T`不是固定类型。

      - ```c++
        template<typename T>
        void func(T&& arg);
        ```

    - **`std::forward`：**用于将参数以其原始值类别（左值或右值）转发给其他函数。

      - ```c++
        template<typename T>
        void wrapper(T&& arg)
        {
            someFunc(std::forward<T>(arg)); // 完美转发
        }
        ```

  - 示例：

    - ```c++
      #include <iostream>
      #include <utility> // for std::forward
      
      void process(int& x)
      {
          std::cout << "Lvalue reference" << std::endl;
      }
      
      void process(int&& x)
      {
          std::cout << "Rvalue reference" << std::endl;
      }
      
      template<typename T>
      void wrapper(T&& arg)
      {
          process(std::forward<T>(arg)); // 完美转发
      }
      
      int main()
      {
          int x = 10;
          wrapper(x);//调用process(int& x)
          wrapper(20);//调用process(int&& x)
          
          return 0;
      }
      ```



## 5、介绍C++中三种智能指针的使用场景

- **什么是智能指针？**

  - 智能指针是C++标准库中的一种工具，用于**自动管理动态分配的内存**。智能指针可以自动处理对象的生命周期，确保在不需要使用对象时，自动释放对象占用的内存，**避免内存泄漏**。

- **智能指针的原理是什么？**

  **原理：**通过**将资源的管理与对象的生命周期绑定在一起**，利用**RAII原则**和**引用计数机制**来确保资源在生命周期结束时被正确释放，从而避免了内存泄漏和悬空指针的问题。

  - **RAII（Resource Acquisition Is Initialization）原则：**
    - RAII 是一种 C++ 资源管理的编程范式，它的核心思想是：将资源的生命周期与对象的生命周期绑定在一起。当对象被创建时，资源被分配；当对象被销毁时，资源被释放。这样可以确保资源在对象生命周期结束时被正确释放，从而避免资源泄漏。
    - 智能指针利用 RAII 原则，在对象的构造函数中申请资源，在对象的析构函数中释放资源，从而确保资源在对象生命周期结束时被正确释放。
  - **引用计数：**
    - 智能指针中的 `shared_ptr` 使用引用计数来跟踪对象的引用数量。每当一个新的 `shared_ptr` 指向同一个对象时，该对象的引用计数就会增加；当 `shared_ptr` 被销毁时，引用计数减少。只有当引用计数为零时，对象才会被销毁。
    - `weak_ptr` 则不增加引用计数，它只是提供一种观察 `shared_ptr` 是否存在的机制，避免循环引用造成的内存泄漏。
  - **自定义析构函数：**
    - 智能指针通常会使用自定义的析构函数来释放动态分配的内存。在析构函数中，智能指针会调用 `delete` 或者 `delete[]` 来释放内存资源，确保资源被正确释放。
  - **运算符重载：**
    - 智能指针通常会重载指针操作符`*`和箭头操作符`->`，以便于像原始指针一样访问对象。这样可以使智能指针的使用方式与原始指针类似，方便开发人员进行替换使用。

- **三种智能指针：**

  - `std::unique_ptr`

    - 介绍：

      - 一种**独占所有权**的智能指针，即同一时刻只有一个`std::unique_ptr`指针可以指向一某个对象。它不允许拷贝，但允许移动。

    - 使用场景：

      - 独占所有权：
        - 当希望某个对象的生命周期由某个特定的指针控制时，可以使用`std::unique_ptr`。这种情况通常出现在需要明确所有权的情况下。
      - 资源管理：
        - 适合用于资源管理，例如：文件句柄、网络连接等，确保资源能够被正确释放。

    - 示例：

      - ```c++
        #include <iostream>
        #include <memory>
        
        void use_unique_ptr()
        {
            std::unique_ptr<int> ptr = std::make_unique<int>(10);
            std::cout << *ptr << std::endl;//输出10
            
            //不允许拷贝，但可以转移所有权
            std::unique_ptr<int> ptr2 = std::move(ptr);
            if(!ptr)
            {
                std::cout << "ptr is nullptr" << std::endl;//ptr 已经为 nullptr
            }
            std::cout << *ptr2 << std::endl;//输出10
        }
        ```

  - `std::shared_ptr`

    - 介绍：

      - 一种**共享所有权**的智能指针，即多个`std::shared_ptr`可以指向同一个对象。当最后一个`std::shared_ptr`被销毁时，对象的内存才会被释放。

    - 使用场景：

      - 共享资源：
        - 当希望多个对象或函数共享同一资源，并不确定哪个对象或资源会最后释放它时，`std::shared_ptr`是最好的选择。
      - 避免悬挂指针：
        - 通过引用计数机制，`std::shared_ptr`可以避免使用已经被释放了的资源。

    - 示例：

      - ```c++
        #include <iostream>
        #include <memory>
        
        void use_shared_ptr()
        {
            std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
            {
                std::shared_ptr<int> ptr2 = ptr1;//ptr1和ptr2共享所有权
                std::cout << "ptr2 = " << *ptr2 << std::endl;//输出20
            }
            std::cout << "ptr1" << *ptr1 << std::endl;//输出20
        }//最后一个共享指针被销毁时，对象被释放。
        ```

  - `std::weak_ptr`

    - 介绍：	

      - 一种**弱引用**智能指针，不参与引用计数管理。`std::weak_ptr`主要被用于打破循环引用，从而避免内存泄漏。

    - 使用场景：

      - 防止循环引用：
        - 在使用`std::weak_ptr`时，如果两个对象互相引用，可能会导致内存泄露。通过使用`std::weak_ptr`可以打破这种循环引用。
      - **观察者模式：**
        - 在某些设计模式中，可能需要观察某个对象，但不想影响该对象的生命周期，此时可以使用`std::weak_ptr`。

    - 示例：

      - ```c++
        #include <iostream>
        #include <memory>
        
        void use_weak_ptr() {
            std::shared_ptr<int> ptr1 = std::make_shared<int>(30);
            std::weak_ptr<int> weak_ptr = ptr1;
        
            if (auto sp = weak_ptr.lock()) {  // 锁定并获取 shared_ptr
                std::cout << "Shared value: " << *sp << std::endl;  // 输出 30
            } else {
                std::cout << "Pointer is expired" << std::endl;
            }
        
            ptr1.reset();  // 销毁 shared_ptr，资源被释放
        
            if (auto sp = weak_ptr.lock()) {
                std::cout << "Shared value: " << *sp << std::endl;
            } else {
                std::cout << "Pointer is expired" << std::endl;  // 输出 Pointer is expired
            }
        }
        
        ```



## 6、C++中`static`的作用是什么？什么场景下用到static？

在C++中，`static`关键字的用途取决于它的位置和上下文。

- 在函数内部使用`static`
  当`static`用于函数内部的局部变量时，该变量在函数的多次调用中保持其值不变，而不是在每次调用时重新创建和销毁。

  - 作用：

    - 静态存储持续性：函数内的`static`变量旨在第一次调用时初始化，其值在函数的后续调用中保留。

  - 使用场景：

    - 计数器：在函数内跟踪某些操作的调用次数。
    - 缓存中间结果：保留一些计算结果以避免重复计算。

  - 示例：

    - ```c++
      #include <iostream>
      
      void counter() {
          static int count = 0;  // 只初始化一次
          count++;
          std::cout << "Function called " << count << " times" << std::endl;
      }
      
      int main() {
          counter();  // 输出 "Function called 1 times"
          counter();  // 输出 "Function called 2 times"
          counter();  // 输出 "Function called 3 times"
          return 0;
      }
      ```

- 在类中使用`static`成员变量
  在类中使用static关键字修饰的变量属于整个类，而不是某个具体对象。所有对象共享同一个`static`成员变量。

  - 作用：

    - 类共享数据：`static`成员变量对所有类实例共享，可以用于计数类的实例个数等。

  - 使用场景：

    - 计数类实例：跟踪类创建的实例数量。
    - 共享数据：在类的所有实例之间共享信息，如配置数据。

  - 示例：

    - ```c++
      #include <iostream>
      
      class MyClass {
      public:
          static int count;  // 静态成员变量声明
          MyClass() { count++; }  // 构造函数，增加计数
      };
      
      int MyClass::count = 0;  // 静态成员变量定义和初始化
      
      int main() {
          MyClass obj1;
          MyClass obj2;
          MyClass obj3;
      
          std::cout << "Number of instances: " << MyClass::count << std::endl;  // 输出 3
          return 0;
      }
      ```

- 在类中使用`static`成员函数
  `static`成员函数不依赖于类的任何实例，因此**不能访问非`static`的成员变量或成员函数**。它们通常用于操作`static`成员变量，或执行不依赖于特定实例的操作。

  - 作用：

    - 无需对象实例：可以在没有对象实例的情况下调用，用于操作类级别的静态数据。

  - 使用场景：

    - 操作静态数据：对静态成员变量进行操作。
    - 实用工具函数：不需要对象实例即可使用的函数，如数学计算

  - 示例：

    - ```c++
      #include <iostream>
      
      class Math {
      public:
          static int add(int a, int b) {
              return a + b;
          }
      };
      
      int main() {
          int result = Math::add(5, 3);  // 静态成员函数的调用
          std::cout << "Result: " << result << std::endl;  // 输出 8
          return 0;
      }
      ```

- 在全局或命名空间级别使用`static`
  当`static`用于全局变量或函数时，它将限制这些变量或函数的可见性，使它们只在定义它们的翻译单元（通常是一个源文件）内可见。

  - 作用：

    - 内部链接：限制变量或函数的作用域，使其只在当前源文件中可见，避免命名冲突。

  - 使用场景：

    - 模块私有变量或函数：定义只在某个模块（源文件）内部使用的函数或变量，不希望它们在其他模块中可见。

  - 示例：

    - ```c++
      // file1.cpp
      static void func() {
          std::cout << "This is a static function" << std::endl;
      }
      
      void callFunc() {
          func();
      }
      
      // file2.cpp
      extern void callFunc();
      
      int main() {
          callFunc();  // 调用 file1.cpp 中的函数
          // func();  // 错误：func 对于 file2.cpp 是不可见的
          return 0;
      }
      ```



## 7、C++中`const`的作用？

在C++中，`const`关键字用于定义常量，限制数据的修改权限，并提高代码的可读性和安全性。`const`可以应用于变量、指针、成员函数和函数参数等多个方面。

- **用于定义常量**

  - 使用`const`定义的变量在初始化后不能被修改，这可以防止意外的值改变。

    - ```c++
      const int maxValue = 100;
      // maxValue = 200;  // 错误，const变量不能被修改
      ```

  - 使用场景

    - 常量定义：定义不应改变的值，如数学常量、配置参数等。
    - 增加代码可读性：让读者清楚地知道哪些值是不可修改的。

- **用于指针**

  在C++中，`const`可以用于指针的多个层面，分别表示指针本身、指针指向的数据或两者都不可修改。

  - 指向常量的指针

    - 指针指向的对象是常量，不能通过指针修改对象的值，但可以改变指针的指向。

    - ```c++
      const int* p = &maxValue;
      // *p = 10;  // 错误，指针指向的值不能修改
      ```

  - 常量指针

    - 指针本身是常量，指向一旦确定，就不能再改变，但指向的数据可以修改。

    - ```c++
      int value = 10;
      int* const p = &value;
      // p = &maxValue;  // 错误，不能改变指针的指向
      *p = 20;  // 可以修改指针指向的值
      ```

  - 指向常量的常量指针

    - 指针本身和指针指向的对象都是常量，既不能修改指针指向的值，也不能改变指针的指向。

    - ```c++
      const int* const p = &maxValue;
      // *p = 10;  // 错误，指针指向的值不能修改
      // p = &value;  // 错误，指针本身也不能修改
      ```

- **用于函数参数**

  `const`可以用于函数参数，表示在函数内部不应修改传入的参数值。这对于避免副作用（即函数对参数的修改）特别有用。

  - 值传递的`const`参数

    - 避免在函数内部修改传入的值，通常用于大对象的引用传递或指针传递。

    - ```c++
      void display(const int x) {
          // x = 100;  // 错误，不能修改传入的参数
          std::cout << x << std::endl;
      }
      ```

  - 引用传递的`const`参数

    - 引用传递`const`对象，避免了不必要的拷贝，同时保证函数内部不会修改传入的对象。适用于传递大型对象如`std::string`或`std::vector`。

    - ```c++
      void display(const std::string& str) {
          std::cout << str << std::endl;
      }
      ```

- **用于成员函数**

  在类中，`const`可以用于成员函数，以表示该函数不会修改类的成员变量。这种成员函数称为常量成员函数。

  ```c++
  class MyClass {
  private:
      int value;
  public:
      int getValue() const {
          return value;
      }
      void setValue(int v) {
          value = v;
      }
  };
  ```

  在`getValue`函数中，`const`保证了该函数不会修改类的任何成员变量，因此可以安全地调用该函数，即使是在一个常量对象上。

- **用于返回值**

  `const`也可以用于函数的返回值，主要用于返回一个不应修改的对象或指针，防止调用者对其进行修改。

  ```c++
  const std::string& getName() const {
      return name;
  }
  ```

  返回值是一个`const`引用，表明返回的对象不能被修改，通常用于**返回类的私有成员**。



## 8、C++中`#define`和`const`的区别

在C++中，`#define`和`const`都是用于定义常量，但它们的使用方式、特点和应用场景有很大的不同。

- **定义和语法：**

  - `#define`：

    - 是**预处理指令**，用于在**编译前**对代码进行**文本替换**。

    - ```c++
      #define MAX_VALUE 100
      ```

    - 在编译时，预处理器会将所有的`MAX_VALUE`替换为`100`。

  - const：

    - 是C++关键字，用于声明常量，其值在初始化后不可更改。

    - ```c++
      const int maxValue = 100;
      ```

- **作用范围：**

  - `#define`：
    - 作用于整个源文件，从定义开始直到文件结束或直到遇到`#undef`（取消定义）。
    - 由于它在预处理阶段进行替换，所以**不会被类型检查**，也**不会受到作用域的限制**。
  - `const`：
    - 作用于当前作用域。`const`变量的作用范围是声明它的作用域，例如函数、类或命名空间内部。
    - 受作用域限制，具有类型信息，可以进行类型检查。

- **类型安全：**

  - `#define`：

    - 没有类型信息，替换只是简单的文本替换，因此不会进行类型检查，可能会导致类型错误或难以调试的错误。

    - ```c++
      #define PI 3.14159
      double area = PI * radius * radius;  // PI 被替换为 3.14159
      ```

  - `const`：

    - 具有类型信息，编译器可以进行类型检查，确保类型的正确性。

    - ```c++
      const double PI = 3.14159;
      double area = PI * radius * radius;  // PI 是一个具有类型信息的常量
      ```

- **调试和错误检查：**

  - `#define`：
    - 由于是文本替换，出错时难以调试，错误消息通常是关于文本替换的问题。
    - 可能会引入不易察觉的错误，例如命名冲突。
  - `const`：
    - 编译器会进行语法和类型检查，发现错误时可以提供更明确的错误信息。
    - 更容易进行调试，因为常量有明确的类型和作用范围。

- **内存和存储：**

  - `#define`：
    - 宏定义**不占用内存**，文本替换不会生成实际的内存存储。
    - 编译时直接将替换结果嵌入到代码中。
  - `const`：
    - `const`变量在内存中**有实际的存储空间**，并且在编译时可能会进行优化处理。
    - 可以存储在**只读数据段**中，编译器也可以在需要时进行优化。

- **作用于类成员：**

  - `#define`：

    - 无法直接用于类成员常量的定义，通常用于**全局常量**。

  - `const`：

    - 可以在类中定义成员常量，并且可以是静态成员常量。

    - ```c++
      class MyClass {
      public:
          static const int MaxSize = 100;  // 类的静态常量
      };
      ```

- **替代方案：**

  - `constexpr`(C++11引入)：

    - 另一个用于定义常量的方式，它提供了更严格的**编译时常量检查**和更高的表达能力。

    - ```c++
      constexpr int maxValue = 100;
      ```



## 9、C++中`inline`的作用？有什么优缺点？

在C++中，`inline`关键字用于**建议**编译器将**函数调用替换为函数体**，从而**避免函数调用的开销**。`inline`主要用于那些频繁调用的小型函数，以提高执行效率。

- **`inline`的作用：**

  - 内联函数：

    - `inline`函数是一种**建议**编译器将函数调用替换为函数体的机制。当调用一个`inline`函数时，编译器会将函数的代码直接插入到调用点，而不是进行常规的函数调用。这样可以避免函数调用的开销（如压栈、跳转等）。

    - ```c++
      inline int add(int a, int b) {
          return a + b;
      }
      
      int main() {
          int result = add(3, 4);  // 编译器可能将add(3, 4)替换为3 + 4
          return 0;
      }
      //如果编译器接受了inline的建议，它会将add(3, 4)直接替换为3 + 4，从而省去了函数调用的开销。
      ```

- **`inline`的优点：**

  - 减少函数调用的开销
    - 对于**小型函数（如一两行代码）**，使用`inline`可以减少函数调用所需的开销，如参数传递、栈帧的创建和返回跳转等。
  - 提高性能
    - 如果某些小函数被频繁调用，使用`inline`可以提高执行效率，特别是在循环或性能关键的代码中。
  - 有助于编译器优化
    - `inline`函数由于直接嵌入到调用点，编译器可以更容易进行进一步的优化，例如常量折叠、消除不必要的临时变量等。
  - 减少代码重复
    - 通过`inline`函数，可以避免将小段代码多次重复编写，保持代码的简洁和可读性，同时避免了常规函数调用的开销。

- **`inline`的缺点：**

  - 代码膨胀
    - 如果一个`inline`函数在多个地方被调用，每次调用都会被替换为函数体，这可能导致可执行文件的体积增大，尤其是对于大型函数或频繁调用的函数而言。
  - 不适用于所有函数
    - 虽然**可以建议**内联，**但编译器不一定会接受**。对于复杂的函数、递归函数、大型函数等，编译器通常不会进行内联优化。
  - 调试困难
    - 由于内联函数是在**编译时**展开的，函数体嵌入到调用点，调试器在调试内联函数时可能难以准确跟踪函数调用，调试信息变得不太直观。
  - 增加编译时间
    - 由于内联函数会直接展开在调用处，编译器可能需要更长的时间来编译和优化这些展开后的代码，尤其是当内联函数大量存在时。
  - 对库开发的影响
    - 如果一个函数在头文件中被定义为`inline`，它必须在头文件中提供完整的定义。这在开发大型库时可能会带来问题，因为内联函数的更改可能导致头文件的修改，进而要求重新编译所有包含该头文件的源文件。



## 10、C++中数组和指针的区别？

在C++中，数组和指针有相似之处，尤其是在使用数组名时，它通常会退化为指向第一个元素的指针。但数组和指针在概念、使用、内存管理等方面有显著的区别。

- **定义方式和类型：**

  - 数组：

    - 是一块连续的内存区域，包含一组相同类型的元素，其大小在**编译时**确定。

    - ```c++
      int arr[5] = {1, 2, 3, 4, 5};  // 定义了一个大小为5的int类型数组
      ```

  - 指针：

    - 是一个变量，存储的是另一个变量的内存地址，可以指向任何内存地址（包括数组的首地址），也可以在运行是动态分配内存。

    - ```c++
      int* ptr;
      int value = 10;
      ptr = &value;  // ptr指向变量value的地址
      ```

- **数组名 VS 指针：**

  - 数组名：

    - 在大多数情况下，数组名会退化成指向数组第一个元素的指针，但数组名本身是常量，不能修改。

    - ```c++
      int arr[5] = {1, 2, 3, 4, 5};
      int* p = arr;  // 数组名arr退化为指针，指向arr[0]
      ```

  - 指针变量：

    - 指针可以被赋值，指向不同的地址或变量。

    - ```c++
      int arr[5] = {1, 2, 3, 4, 5};
      int* p = arr;
      p = &arr[1];  // 指针p现在指向arr[1]
      ```

- **内存分配：**

  - 数组：

    - 数组的大小是固定的，在定义时确定。数组的内存分配是在**栈（对于局部数组）**或**堆（通过动态分配）**的**连续**空间。

    - ```c++
      int arr[5];  // 分配了5个int大小的连续内存
      ```

  - 指针：

    - 指针本身占据一定的内存，但它指向的内存可以是动态分配的（如通过`new`或`malloc`），可以在运行时根据需要分配和释放内存。

    - ```c++
      int* p = new int[5];  // 动态分配5个int大小的数组
      ```

- **大小和长度：**

  - 数组：

    - 数组的大小是**编译时确定**的。通过`sizeof`可以获取数组的总大小（字节数），也可以根据元素类型计算数组长度。

    - ```c++
      int arr[5] = {1, 2, 3, 4, 5};
      int size = sizeof(arr);         // 获取数组的字节大小
      int length = sizeof(arr) / sizeof(arr[0]);  // 计算数组的元素个数
      ```

  - 指针：

    - 指针的大小与系统架构相关（通常在**32位系统上为4字节**，在**64位系统上为8字节**），但无法通过`sizeof`获取指针指向的数据大小或数组的长度。

    - ```c++
      int* p = arr;
      int size = sizeof(p);  // p是指针，返回指针的大小（通常是4或8）
      ```

- **访问方式：**

  - 数组：

    - 数组可以通过索引来直接访问其元素，`arr[i]`是访问第`i`个元素的常见方式。

    - ```c++
      int arr[5] = {1, 2, 3, 4, 5};
      int value = arr[2];  // 获取arr[2]的值
      ```

  - 指针：

    - 指针可以通过指针算术（如`*(p + i)`）访问其指向的内存。指针也可以像数组一样使用下标运算符访问元素。

    - ```c++
      int arr[5] = {1, 2, 3, 4, 5};
      int* p = arr;
      int value = *(p + 2);  // 获取p指向的数组第3个元素的值
      ```

- **修改性：**

  - 数组：

    - 数组名是常量，不可修改，即不能将数组名赋值给其他指针或变量。

    - ```c++
      int arr[5];
      // arr = some_other_array;  // 错误，不能将数组名赋值给其他数组
      ```

  - 指针：

    - 指针可以被重新赋值，指向不同的地址。

    - ```c++
      int* p;
      int arr1[5], arr2[5];
      p = arr1;
      p = arr2;  // 正确，指针可以指向不同的数组
      ```

- **函数参数传递：**

  - 数组：

    - 当数组作为函数参数传递时，会退化为指向数组第一个元素的指针。这意味着在函数内部不能直接获取数组的大小。

    - ```c++
      void func(int arr[]) {  // arr退化为指针
          // sizeof(arr)只会返回指针大小，不是数组大小
      }
      ```

  - 指针：

    - 指针可以直接作为函数参数传递，并且可以指向任意内存地址。

    - ```c++
      void func(int* p) {
          // p指向的是传入的地址
      }
      ```

    - 

- **数组与指针的关系：**

  - 数组名退化为指针：

    - 数组名可以退化为指向数组第一个元素的指针，但它并不是一个指针变量。

    - ```c++
      int arr[5] = {1, 2, 3, 4, 5};
      int* p = arr;  // 数组名退化为指针
      ```

  - 指针可以指向数组：

    - 指针可以指向数组中的元素，通过指针访问数组内容。

    - ```c++
      int* p = &arr[0];  // 指针指向数组的第一个元素
      ```



## 11、C++中`sizeof`和`strlen`的区别？

在C++中，`sizeof`和`strlen`是两个用于不同目的的操作符和函数，主要用于获取不同类型数据的大小或长度。它们的用途、工作原理和适用场景各不相同。

- `sizeof`：

  - 功能：

    - `sizeof`是一个**编译时操作符**，用于获取某个数据类型或对象在内存中所占用的字节数。它可以作用于任何类型（基本数据类型、数组、结构体、类等）。

  - 语法：

    - ```c++
      int a = 10;
      char str[] = "Hello";
      
      std::cout << sizeof(a) << std::endl;        // 输出4，int类型通常占4个字节
      std::cout << sizeof(str) << std::endl;      // 输出6，字符数组占6个字节（包括'\0'）
      //在上例中，sizeof(str)返回的是字符数组的总大小，包括最后的空字符'\0'。
      ```

- `strlen`：

  - 功能：

    - `strlen`是**C标准库中的函数**，定义在`<cstring>`头文件中，用于计算以`'\0'`（空字符）结尾的C风格字符串的长度。

  - 语法：

    - ```c++
      size_t strlen(const char* str);  // 计算字符串str的长度（不包括'\0'）
      ```

  - 返回值：

    - 返回的是字符串中的**字符个数**（不包括结尾的空字符`'\0'`），类型为`size_t`。

  - ```c++
    char str[] = "Hello";
    
    std::cout << strlen(str) << std::endl;  // 输出5，字符串"Hello"的长度是5，不包括'\0'
    //在上例中，strlen(str)返回5，因为"Hello"有5个字符，'\0'不计入长度。
    ```

- **`sizeof`和`strlen`的区别：**

  - 功能和用途：
    - `sizeof`：用于计算**类型或对象**所占用的内存大小（以字节为单位），是在**编译时**确定的。
    - `strlen`：用于计算以**空字符结尾的字符串**的长度，是在**运行时**确定的。
  - 适用的数据类型：
    - `sizeof`：可以作用于任何类型，包括基本数据类型（如`int`、`float`）、用户自定义的类型（如结构体）、数组、指针等。
    - `strlen`：只能用于**以`'\0'`结尾的C风格字符串**，不能用于其他数据类型（如数组、非字符指针等）。
  - 返回值的含义：
    - `sizeof`：返回的是对象或类型在内存中占用的字节数。
    - `strlen`：返回的是C风格字符串中**字符的个数**（不包括终止的`'\0'`字符）。

|   特性   |                 `sizeof`                 |              `strlen`               |
| :------: | :--------------------------------------: | :---------------------------------: |
|   目的   |        获取类型或对象占用的字节数        | 获取以`'\0'`结尾的C风格字符串的长度 |
|  返回值  |            类型或对象的字节数            |    字符串的字符数（不包括`'\0`）    |
| 适用范围 | 任何类型（包括数组、指针、结构体、类等） |  只能用于以`'\0'`结尾的C风格字符串  |
| 计算时间 |                编译时确定                |             运行时确定              |
| 常见用途 |          内存管理、数组大小计算          |             字符串处理              |



## 12、C++中`extern`有什么作用？`extern "C"`有什么作用？

在C++中，`extern`和`extern "C"`有着不同的作用，分别用于**声明外部变量或函数**和**处理C与C++之间的链接兼容性**。它们在跨文件、跨语言的编程中十分重要。

- `extern` 的作用

  - 跨文件访问全局变量或函数：

    在C++中，`extern`关键字用于声明一个**外部变量或函数**，其定义可能在另一个文件中。通过`extern`，多个文件可以共享同一个全局变量或函数，而不需要重新定义它。

    - 声明外部变量：

      - 当在一个文件中定义了某个全局变量时，想在另一个文件中使用它，就可以用`extern`进行声明，表明这个变量是在别处定义的，编译器不会为它分配新的内存。

    - 示例：

      - 假设有两个文件：`file1.cpp`和`file2.cpp`。

      - ```c++
        //file1.cpp
        int globalVar = 10;  // 定义一个全局变量
        
        
        //file2.cpp
        extern int globalVar;  // 声明来自其他文件的全局变量
        
        void printGlobalVar() {
            std::cout << globalVar << std::endl;  // 输出全局变量的值
        }
        ```

      - `globalVar`在`file1.cpp`中定义，`file2.cpp`中使用`extern`声明它，表明它来自于外部文件，而非重新定义。

  - 声明外部函数

    与变量类似，函数也可以使用`extern`声明。当一个函数在某个文件中定义，在其他文件中调用时，可以通过`extern`来声明。

    ```c++
    //file1.cpp
    void foo() {
        std::cout << "Hello from foo" << std::endl;
    }
    
    //file2.cpp
    extern void foo();  // 声明外部函数
    
    int main() {
        foo();  // 调用在file1.cpp中定义的函数
        return 0;
    }
    
    ```

    `foo`函数定义在`file1.cpp`中，而在`file2.cpp`中通过`extern`声明并调用。

- `extern "C"` 的作用

  - C和C++链接兼容性

    `extern "C"`的主要作用是解决C++与C之间的**函数名修饰（name mangling）**问题，从而使C++代码能够与C语言的代码进行互操作。

    - 函数名修饰（name mangling）
      - C++为了支持函数重载，会对函数名进行修饰，生成独特的符号。例如，C++中的一个函数`void foo(int)`在编译后，可能被修改成`_Z3fooi`（编译器生成的名字会有所不同）。这种修饰使得编译器能够区分同名的不同函数。
      - C语言则没有函数名修饰，函数名在编译后保持不变。如果在C++中直接调用C语言的函数，链接时会因为函数名不匹配而失败。
    - 解决方法：
      - 使用`extern "C"`告诉编译器，按照C语言的方式处理函数名，这样在链接C语言函数时就不会出现名字不匹配的问题。

  - 使用`extern "C"`声明C语言函数

    - 语法：

      - ```c++
        extern "C" 
        {
            // 这里面的函数将按C语言方式链接
            void cFunction();
        }
        ```

    - 示例：

      - 有一个C语言文件`c_functions.c`，并希望从C++中调用它的函数。

      - ```c++
        //c_functions.c
        #include <stdio.h>
        
        void cFunction() {
            printf("Hello from C function\n");
        }
        ```

      - ```c++
        //cpp_program.cpp
        extern "C" void cFunction();  // 声明C语言函数
        
        int main() {
            cFunction();  // 调用C语言的函数
            return 0;
        }
        ```

      - 在这个例子中，`extern "C"`告诉C++编译器`cFunction`是一个按照C语言规则定义的函数，因此不要对它进行C++风格的函数名修饰。这样C++代码就可以正确地调用C语言代码。

- 混合C和C++代码：

  - `extern "C"`的使用场景：
    - 当需要在C++代码中调用C语言的库时（例如标准C库、第三方C库等），`extern "C"`是必不可少的。
    - 在C++代码中暴露给C代码的接口时，也可以使用`extern "C"`来确保C代码能够正确地调用C++中的函数。
  - 注意事项：
    -  `extern "C"`仅用于函数声明或定义，不能用于C++的类、模板、重载函数等特性。它主要作用于简单的C风格函数。



## 13、C++中`explicit`的作用？

在 C++ 中，`explicit` 关键字用于**修饰构造函数或类型转换函数**，目的是**防止隐式类型转换**。默认情况下，C++ 允许通过构造函数进行隐式类型转换，但有时候这可能会导致意外的行为或错误。使用 `explicit` 关键字可以阻止这种隐式转换，只允许显式转换。

- **隐式转换问题**

  通常情况下，如果类的构造函数可以接受一个参数，C++ 允许通过隐式转换创建该类的对象。

  ```c++
  #include <iostream>
  using namespace std;
  
  class MyClass {
  public:
      // 接受一个参数的构造函数
      MyClass(int x) {
          cout << "Constructor called with " << x << endl;
      }
  };
  
  void printMyClass(const MyClass &obj) {
      cout << "Function called!" << endl;
  }
  
  int main() {
      MyClass obj1 = 42;  // 隐式调用构造函数，生成 MyClass 对象
      printMyClass(100);  // 隐式调用构造函数，生成 MyClass 对象
  
      return 0;
  }
  //输出：
  //Constructor called with 42
  //Constructor called with 100
  //Function called!
  ```

  在上面的代码中：

  - 当 `MyClass obj1 = 42;` 执行时，C++ 通过隐式转换自动将 `42` 转换为 `MyClass` 对象。
  - 调用 `printMyClass(100);` 时，也通过隐式转换将 `100` 转换为 `MyClass` 对象。

- **使用`explicit`禁止隐式转换**

  为了避免上述隐式转换的发生，可以在构造函数前添加 `explicit` 关键字，确保对象只能通过显式的方式创建。

  ```c++
  #include <iostream>
  using namespace std;
  
  class MyClass {
  public:
      // 显式构造函数
      explicit MyClass(int x) {
          cout << "Constructor called with " << x << endl;
      }
  };
  
  void printMyClass(const MyClass &obj) {
      cout << "Function called!" << endl;
  }
  
  int main() {
      MyClass obj1(42);    // 必须显式调用构造函数
      // MyClass obj2 = 42;  // 错误：不允许隐式转换
  
      printMyClass(MyClass(100));  // 必须显式创建 MyClass 对象
      // printMyClass(100);         // 错误：隐式转换被禁止
  
      return 0;
  }
  //输出：
  //Constructor called with 42
  //Constructor called with 100
  //Function called!
  ```

  在这个例子中：

  - `MyClass obj1(42);` 是合法的，因为它**显式**调用了构造函数。
  - `MyClass obj2 = 42;` 和 `printMyClass(100);` 将会导致编译错误，因为隐式转换已被 `explicit` 禁止。

- **`explicit`关键字的作用总结**

  - 防止**单参数构造函数**进行**隐式类型转换**。
  - 需要**显式**构造对象，避免潜在的错误。
  - 常用于防止不期望的类型转换，确保代码更加清晰和安全。

- **C++11中`explicit`适用于类型转换函数**

  在 C++11 及之后的版本中，`explicit` 也可以用于**修饰类型转换函数**，从而禁止隐式的类型转换操作。

  ```c++
  #include <iostream>
  using namespace std;
  
  class MyClass {
  public:
      //类型转换函数：将自定义类型转换成bool类型
      explicit operator bool() const {
          return true;
      }
  };
  
  int main() {
      MyClass obj;
      // if (obj) {             // 错误：隐式转换被禁止
      if (static_cast<bool>(obj)) {  // 正确：显式转换
          cout << "Object is true!" << endl;
      }
  
      return 0;
  }
  ```

  在这个例子中，`explicit` 禁止了隐式的 `bool` 类型转换，必须通过显式的 `static_cast` 来进行转换。



## 14、C++中野指针和悬挂指针的区别？

在 C++ 中，**野指针**和**悬挂指针**都是涉及内存管理的错误类型，它们都会导致程序的不稳定和不确定行为，但它们的产生原因和表现略有不同。

- **野指针**

  **野指针**是指那些**没有被初始化**或者指向了**无效地址**的指针。它并**不指向任何有效的对象或内存位置**，因此对野指针的操作会导致未定义行为。

  - 产生原因

    - 指针未被初始化：当一个指针变量**声明后没有被赋值时**，它会指向一个随机的内存地址，可能是无效地址或系统保留的地址，操作这种指针会导致错误。

    - 错误的内存地址分配：如果指针**指向了一个不合法的内存区域**，或因为某种原因分配了错误的内存地址，那么该指针也是野指针。

      ```c++
      int *ptr;  // 未初始化，ptr 是野指针
      *ptr = 10; // 错误，ptr 指向随机内存
      ```

  - 解决方法

    - 在声明指针时，将其初始化为`nullptr`，以确保它在未分配内存之前不会指向任意地址。

      ```c++
      int *ptr = nullptr;
      ```

- **悬挂指针**

  **悬挂指针**是指指向一个**已经被释放或销毁**的对象或内存的指针。虽然它曾经指向有效的内存区域，但该内存区域已经被释放或回收，而指针仍然保留着原来的地址，此时它就成为了悬挂指针。

  - 产生原因

    - 指针指向的对象已被释放：如果通过 `delete` 或 `free` **释放了指针**指向的内存，但**指针本身并没有被重置为 `nullptr`**，那么该指针就变成了悬挂指针。

    - 指向局部变量的指针：当函数返回后，指向局部变量的指针仍然存在，但局部变量的内存已经被释放，此时该指针就是悬挂指针。

      ```c++
      //情况一
      int *ptr = new int(10); // 分配内存
      delete ptr;             // 释放内存，ptr 成为悬挂指针
      *ptr = 20;              // 错误，ptr 指向的内存已经被释放
      
      //情况二
      int* func() {
          int x = 10;
          return &x;  // 返回局部变量的地址
      }
      
      int* p = func();  // 悬挂指针，x 已经被释放
      ```

  - 解决方法

    - 在释放指针指向的内存后，将指针**立即设置为 `nullptr`**，这样可以避免对悬挂指针的操作。

      ```c++
      delete ptr;
      ptr = nullptr;  // 防止悬挂指针
      ```

- **野指针与悬挂指针的区别：**

  |   区别   |                    野指针                     |                         悬挂指针                          |
  | :------: | :-------------------------------------------: | :-------------------------------------------------------: |
  |   定义   |     指向**未初始化**或**非法地址**的指针      |          指向**已经释放**或**销毁**的内存的指针           |
  | 产生原因 | 1. 指针未初始化 <br />2. 指向不合法的内存地址 | 1. 指向的内存已经被释放<br /> 2. 指向函数中局部变量的地址 |
  | 解决方法 |           将指针初始化为 `nullptr`            |             释放内存后将指针设置为 `nullptr`              |



## 15、是什么内存对齐？为什么要内存对齐？

内存对齐（Memory Alignment）是指在计算机系统中，数据被存储时**按照特定的字节边界**进行对齐，即变量或数据的存储地址应符合一定的规则。通常，这些规则是由系统架构或处理器的设计决定的，例如 4 字节、8 字节或 16 字节边界。内存对齐的主要目的是提高数据访问的效率。

- **为什么要内存对齐：**
  - 提升内存访问速度：
    - 处理器通常通过特定的字节边界访问内存。若数据未对齐，处理器需要执行额外的操作（如两次内存访问）才能读取或写入数据，导致性能下降。
  - 硬件要求：
    - 某些处理器对未对齐的内存访问不支持或处理效率较低。如果访问未对齐的内存，处理器可能会抛出异常或强制进行额外的操作来处理。
  - 缓存效率：
    - 现代处理器使用缓存来加速内存访问。内存对齐可以让数据更好地适应缓存行，避免_DC行的不必要切换，进而提升数据的缓存命中率。
  - 提高代码可移植性：
    - 内存对齐规则通常与平台相关。如果在一台机器上使用了未对齐的内存操作，移植到另一台机器时可能导致程序崩溃或不稳定。
- **内存对齐的三大规则：**
  - 数据成员对齐规则
    - 数据成员本身要对齐，每个数据成员都要对齐
  - 结构（或联合）的整体对齐规则
    - 结构体也要对齐，最后结构体的大小是结构体中最大数据成员的整数倍
  - 结构体作为成员对齐规则
    - 结构体里面还有结构体的时候，里面的结构体要对齐，并且里面结构体也要对齐

例如：

```c++
//对齐系数，指定数值对齐。
#pragma pack(n) 
//如果没有指定，则不同机器按照不同系数进行对齐
//在 32 位系统上，通常是 4 字节对齐，而在 64 位系统上，通常是 8 字节对齐。

#pragma pack() // 恢复默认对齐

struct x
{
    char a;
    int b;
    short c;
    char d;
}MyStructX;//12

struct y
{
    int b;
    char a;
    char d;
    short c;
}MyStructY;//8

struct SS
{
    int a;
    char b;
    short c;
    int d;
    struct FF{
        int a1;
        char b1;
        short c1;
        char d1;
    }MyStructFF;
    int e;
    //char e;
    double ww;
}MyStructSS;


cout << "sizeof(MyStructX) = " << sizeof(MyStructX) << endl;
cout << "sizeof(MyStructY) = " << sizeof(MyStructY) << endl;
cout << "sizeof(MyStructSS) = " << sizeof(MyStructSS) << endl;

//打印结果：
sizeof(MyStructX) = 12
sizeof(MyStructY) = 8
sizeof(MyStructSS) = 40
```

**struct x**

![image-20230309171816254](C:\Users\ML\AppData\Roaming\Typora\typora-user-images\image-20230309171816254.png)

**struct y**

![image-20230309171948965](C:\Users\ML\AppData\Roaming\Typora\typora-user-images\image-20230309171948965.png)

**struct ss**

![image-20230309173854711](C:\Users\ML\AppData\Roaming\Typora\typora-user-images\image-20230309173854711.png)

## 16、C++中四种类型转换及其使用场景？

C++ 中有四种显式类型转换操作符，分别是 `static_cast`、`dynamic_cast`、`const_cast` 和 `reinterpret_cast`。这些类型转换操作符比传统的 C 风格类型转换（如 `(int)x`）更加安全和灵活，每种类型转换有其特定的应用场景。

- **`static_cast`**
  `static_cast` 用于在类型之间进行**显式的类型转换**，适用于**编译期**能确定的转换操作。

  - 使用场景：

    - 基本数据类型之间的转换：
      - 例如 `int` 转换为 `float`，`double` 转换为 `int` 等。
    - 类层次结构中的向上转换（Upcasting）：
      - 将派生类指针或引用转换为基类指针或引用。例如，将 `Derived*` 转换为 `Base*`，是安全的操作。
    - 类层次结构中的向下转换（Downcasting）：
      - 在已知对象确实是派生类时，将基类指针转换为派生类指针，但这个操作不如向上转换安全（需要保证指针实际指向派生类对象）。
    - `void*`与其他类型指针之间的转换：
      - 将 `void*` 转换为其他类型的指针。

  - 示例

    ```c++
    class Base {};
    class Derived : public Base {};
    
    int main() {
        Derived d;
        Base* basePtr = static_cast<Base*>(&d);  // 向上转换，安全
        Derived* derivedPtr = static_cast<Derived*>(basePtr);  // 向下转换，可能不安全
        return 0;
    }
    ```

- **`dynamic_cast`**

  `dynamic_cast` 用于在**类层次结构中**进行安全的**向下转换（Downcasting）**。它会在**运行时**检查对象的实际类型，只有当转换是安全的（即基类指针实际指向派生类对象）时，才会成功。否则，指针转换会返回 `nullptr`，引用转换会抛出 `std::bad_cast` 异常。

  - 使用场景：

    - 类层次结构中的安全向下转换：
      - 通常用于将基类指针或引用转换为派生类指针或引用，且只有在启用了 **RTTI**（运行时类型识别）时才能使用。
    - 多态环境中检查对象类型：
      - `dynamic_cast` 主要用于有虚函数的类，即多态类，确保派生类对象的转换是正确的。

  - 示例

    ```c++
    class Base {
    public:
        virtual ~Base() {}  // 虚析构函数使得 Base 成为多态类
    };
    class Derived : public Base {};
    
    int main() {
        Base* basePtr = new Derived();
        Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);  // 安全的向下转换
        if (derivedPtr) {
            // 转换成功
        } else {
            // 转换失败
        }
        return 0;
    }
    ```

- **`const_cast`**

  `const_cast` 用于在**去除或增加类型的 `const` 或 `volatile` 属性**，通常用于去除 `const` 限定符。

  - 使用场景：

    - 去除`const`属性
      - 允许对原本是 `const` 的数据进行修改。需要注意的是，去除 `const` 是危险的，如果原对象本身是 `const`，对其进行修改会导致未定义行为。
    - 修改函数的`const`重载版本中的参数
      - 例如某个函数需要接受非 `const` 参数，但调用者只能提供 `const` 参数，可以使用 `const_cast` 来去除 `const` 限定。

  - 示例

    ```c++
    void modify(int* x) {
        *x = 10;
    }
    
    int main() {
        const int y = 5;
        modify(const_cast<int*>(&y));  // 去除 const 限定符
        return 0;
    }
    ```

- **`reinterpret_cast`**

  `reinterpret_cast` 用于**低级别的类型转换**，是**最不安全的一种转换方式**，允许将一种指针或引用类型强制转换为另一种完全不同的类型。它通常用于与硬件、底层操作系统交互时的类型转换。

  - 使用场景

    - 指针类型之间的转换
      - 例如将指针转换为整数类型，或者将整数转换为指针。
    - 非相关类型之间的强制转换
      - 如将函数指针转换为 `void*`，或者将某个对象的内存内容解释为另一种类型。
    - 位模式转换
      - 直接将某个数据的位模式转换为另一种数据类型。

  - 示例

    ```c++
    int main() {
        int a = 65;
        char* charPtr = reinterpret_cast<char*>(&a);  // 将 int* 转换为 char*
        // 输出 'A'，因为 65 对应于 ASCII 字符 'A'
        std::cout << *charPtr << std::endl;
        return 0;
    }
    ```




## 17、C++中`volatile`关键字的作用及其使用场景？

在C++中，`volatile`关键字用于告诉编译器，**修饰的变量可能会在程序执行的过程中随时发生变化**，因此编译器不应对该变量进行优化。通常，编译器会对一些变量进行优化，例如将变量缓存到寄存器中，而不是每次都从内存中读取。如果某个变量被声明为`volatile`，则编译器会确保每次访问这个变量时，都直接从内存读取，而不是从缓存中获取。

- **作用**

  - 防止编译器优化
    - `volatile`确保变量的值**总是从内存中读取**，而不会被编译器优化掉。
  - 保证数据的可见性
    - 在某些多线程环境或硬件设备交互中，`volatile`确保其他线程或设备对变量的修改对当前线程可见。

- **使用场景**

  - 硬件寄存器映射

    - 在嵌入式编程中，常常需要与硬件设备通信，硬件寄存器的值可能随时被设备改变。在这种情况下，访问这些寄存器的变量需要用`volatile`修饰，以确保程序不会缓存这些寄存器的值。

      ```c++
      volatile int* hardware_register = (int*)0x12345678; // 假设这是一个硬件寄存器
      ```

  - 中断服务程序中的变量

    - 在使用中断的系统中，主程序和中断处理程序可能会共享一些变量。由于中断的不可预测性，主程序无法控制中断何时会修改这些变量。因此，使用`volatile`修饰这些变量，确保每次访问时都能看到最新的值。

      ```c++
      volatile bool interrupt_occurred = false; // 中断处理程序会修改该变量
      ```

  - 多线程编程

    - 在多线程环境中，如果某个线程修改的变量没有使用同步机制（如锁、原子操作等）保护，并且另一个线程访问该变量时需要看到最新值，则可以使用`volatile`保证变量的可见性。

      ```c++
      volatile bool flag = false; // 线程之间共享的标志位
      ```

- **注意事项**

  - `volatile`并**不保证操作的原子性**：它仅保证变量每次都从内存中读取，但不保证读写操作是原子性的。如果需要保证原子性，应使用适当的同步机制（如`std::atomic`）。
  - `volatile`**不等同于线程安全**：对于多线程访问，虽然`volatile`可以避免编译器的优化，但并不能解决数据竞争问题，仍然需要配合锁或原子操作。



## 18、什么是C++的回调函数？为什么需要回调函数？

**回调函数**是指一种通过**函数指针**或**函数对象**调用的函数，在特定事件或条件下被执行。简单来说，回调函数允许我们将一个函数作为参数传递给另一个函数，并在合适的时候“回调”该函数。

在 C++ 中，回调函数可以是**普通函数**、**成员函数**、**lambda 函数**，或者是任何可以像函数一样调用的对象（比如仿函数）。它的实现通常涉及将函数指针或其他可调用对象作为参数传递给另一个函数，在某个事件触发时再调用该回调。

- **函数回调的实现方式**

  - 普通函数的回调
    - 使用**函数指针**传递一个函数，并在事件触发时调用该函数。
  - 类成员函数的回调
    - 类成员函数的指针或 lambda 函数也可以作为回调传递。
  - Lambda函数
    - 使用 C++11 中引入的 lambda 函数，能够简洁地定义回调逻辑。

- **为什么需要回调函数？**

  - 回调函数的主要作用是**解耦**和**灵活性**。它允许我们将一些**可变的、与上下文相关的行为逻辑**从核心代码中分离出来，传递给一个**通用模块**或**函数**，使其在合适的时候执行。这种机制广泛应用于事件驱动编程、异步编程、信号处理、用户界面操作等场景。

- **回调函数的应用场景**

  - 事件驱动编程
    - 回调函数常用于 GUI 应用或游戏开发中，用户触发按钮点击等事件时，系统会调用预先注册的回调函数来处理该事件。
  - 异步操作
    - 回调函数在异步编程中非常常见。比如当一个异步任务完成时，系统会调用回调函数来处理结果。
  - 算法封装
    - 一些算法可能需要自定义逻辑，例如排序算法可以接收比较函数作为回调，用以灵活地调整比较策略。

- **回调函数的实现方式示例**

  - 普通函数的回调

    ```c++
    #include <iostream>
    using namespace std;
    
    // 定义一个回调函数
    void myCallback(int a) {
        cout << "Callback executed with value: " << a << endl;
    }
    
    // 定义一个接受回调函数的函数
    void process(int x, void (*callback)(int)) {
        // 处理逻辑
        x *= 2;
        // 调用回调函数
        callback(x);
    }
    
    int main() {
        // 将 myCallback 作为回调函数传递
        process(5, myCallback);
        return 0;
    }
    ```

  - Lambda函数作为回调函数

    ```c++
    #include <iostream>
    #include <functional>
    
    void process(int x, std::function<void(int)> callback) {
        x *= 2;
        callback(x);
    }
    
    int main() {
        // 使用 lambda 函数作为回调
        process(10, [](int result) {
            std::cout << "Lambda callback with result: " << result << std::endl;
        });
        return 0;
    }
    ```

  - 类成员函数作为回调函数

    ```c++
    #include <iostream>
    #include <functional>
    
    class MyClass {
    public:
        void memberCallback(int a) {
            std::cout << "Member callback executed with value: " << a << std::endl;
        }
    };
    
    // 接收回调的函数
    void process(int x, std::function<void(int)> callback) {
        x *= 2;
        callback(x);
    }
    
    int main() {
        MyClass obj;
        // 绑定类成员函数作为回调
        process(7, std::bind(&MyClass::memberCallback, &obj, std::placeholders::_1));
        return 0;
    }
    ```



## 19、C++中如何设计一个线程安全的类？

在 C++ 中设计一个线程安全的类时，主要目标是确保多个线程同时访问或修改共享资源时，不会产生竞争条件或数据不一致的情况。为了实现这一点，常常需要使用多线程同步机制，如**互斥锁（`mutex`）**、**条件变量（`condition_variable`）**等。

- **设计线程安全类的核心概念**

  - 互斥锁（`mutex`）：使用`std::mutex`来保证同一时间只有一个线程能够访问共享资源。
  - 条件变量（Condition Variable）：通过`std::condition_variable`来同步线程，避免不必要的等待。
  - 锁的粒度：避免锁的过度使用，确保不会因锁的使用影响程序性能。粒度过细会导致性能下降，粒度过粗则可能无法确保线程安全。
  - 原子操作：对某些简单的数据类型（如整数或者布尔值），可以使用 `std::atomic` 来保证操作的原子性，避免竞争。

- **设计思路**

  - 互斥锁保护共享资源
    - 使用互斥锁来保护共享数据的访问，确保同一时间只有一个线程能访问或修改该数据。
  - 将同步操作封装在类的内部
    - 让用户无法直接操作类的内部数据，而是通过类的线程安全接口进行访问。
  - 使用RAII管理锁的生命周期
    - 使用 `std::lock_guard` 或 `std::unique_lock` 来自动管理锁的生命周期，避免手动锁定和解锁可能带来的问题。

- **示例：设计线程安全的计算器类**

  ```c++
  #include <iostream>
  #include <thread>
  #include <mutex>
  #include <atomic>
  
  class ThreadSafeCounter {
  public:
      ThreadSafeCounter() : value(0) {}
  
      // 增加计数器
      void increment() {
          std::lock_guard<std::mutex> lock(mutex_);
          ++value;
      }
  
      // 减少计数器
      void decrement() {
          std::lock_guard<std::mutex> lock(mutex_);
          --value;
      }
  
      // 获取当前计数值
      int getValue() const {
          std::lock_guard<std::mutex> lock(mutex_);
          return value;
      }
  
  private:
      mutable std::mutex mutex_;  // 互斥锁，保护共享数据
      int value;                  // 共享资源
  };
  
  int main() {
      ThreadSafeCounter counter;
  
      // 创建多个线程对计数器进行并发操作
      std::thread t1([&counter]() {
          for (int i = 0; i < 1000; ++i) {
              counter.increment();
          }
      });
  
      std::thread t2([&counter]() {
          for (int i = 0; i < 1000; ++i) {
              counter.decrement();
          }
      });
  
      t1.join();
      t2.join();
  
      std::cout << "Final Counter Value: " << counter.getValue() << std::endl;
      return 0;
  }
  ```

  - 互斥锁的使用
    - `std::mutex mutex_`用于保护共享变量`value`的使用
    - `std::lock_guard<std::mutex>`是RAII风格的锁管理类，用于在作用域内自动加锁和解锁，避免手动解锁时可能发生的错误。
  - 线程安全的操作
    - `increment()`和`decrement()`方法通过互斥锁来保护`value`的读写操作，确保每次修改时只有一个线程范访问。
    - `getValue()`使用`mutable`修饰`mutex_`，保证在`const`方法中也能使用互斥锁保护读取操作。
  - 线程并发
    - 使用 `std::thread` 创建多个线程对计数器进行增减操作。通过使用互斥锁，避免了多个线程同时修改 `value` 时的竞争条件。

- **使用`std::atomic`进行优化**

  对于简单的计数器类，使用 `std::atomic` 可以避免使用互斥锁，从而提高性能。以下是使用 `std::atomic` 的改进版本：

  ```c++
  #include <iostream>
  #include <thread>
  #include <atomic>
  
  class ThreadSafeCounter {
  public:
      ThreadSafeCounter() : value(0) {}
  
      // 使用原子操作增加计数器
      void increment() {
          value.fetch_add(1, std::memory_order_relaxed);
      }
  
      // 使用原子操作减少计数器
      void decrement() {
          value.fetch_sub(1, std::memory_order_relaxed);
      }
  
      // 获取当前计数值
      int getValue() const {
          return value.load(std::memory_order_relaxed);
      }
  
  private:
      std::atomic<int> value;  // 原子类型，保证线程安全
  };
  
  int main() {
      ThreadSafeCounter counter;
  
      std::thread t1([&counter]() {
          for (int i = 0; i < 1000; ++i) {
              counter.increment();
          }
      });
  
      std::thread t2([&counter]() {
          for (int i = 0; i < 1000; ++i) {
              counter.decrement();
          }
      });
  
      t1.join();
      t2.join();
  
      std::cout << "Final Counter Value: " << counter.getValue() << std::endl;
      return 0;
  }
  ```

  

## 20、什么是大端序？什么是小端序？

**大端序（Big-Endian）** 和 **小端序（Little-Endian）** 是两种在计算机系统中表示多字节数据（如 16 位、32 位、64 位整数或浮点数）在内存中**字节排列顺序**的方式。

- 大端序

  高字节（高位）存储在低地址，低字节（低位）存储在高地址。

  例如：32位整数`0x12345678`，在内存中的跑列顺序如下（地址从小到大）：

  ```c++
  地址：0x00  0x01  0x02  0x03
  数据：0x12  0x34  0x56  0x78
  ```

- 小端序

  低字节（低位）存储在低地址，高字节（高位）存储在高地址。

  常见于x86架构（如Intel、AMD）。

  例如：32位整数`0x12345678`，在内存中的跑列顺序如下（地址从小到大）：

  ```c
  地址：0x00  0x01  0x02  0x03
  数据：0x78  0x56  0x34  0x12
  ```



## 21、什么是C++中的RAII？它的使用场景是什么？

- **概念：**

  **RAII（Resource Acquisition Is Initialization）**，全称是**资源获取即初始化**。

- 核心思想

  将资源的获取与对象的生命周期绑定，通过构造函数获取资源（如内存、文件句柄、网络连接等 ），通过析构函数释放资源。这样，即使程序在执行过程中抛出异常或多路径返回，也能确保资源最终得到正确释放，**特别是可以避免内存泄漏**。

- **使用场景：**

  - **内存管理**

    标准库中的`std::unique_ptr`和`std::shared_ptr`是RAII的经典实现，用于智能管理和动态内存。

  - **文件操作**

    `std::fstream`类在打开文件时获取资源，在析构函数中关闭文件。

  - **互斥锁**

    `std::lock_guard`和`std::unuque_lock`用于在多线程编程中自动管理互斥锁的锁定和释放。

- **示例代码**

  ```c++
  #include <iostream>
  #include <fstream>
  
  class FileHandler
  {
  public:
      //获取资源
      FileHandler(const std::string& filename)
          : file(filename)
          {
              if(!file.is_open())
              {
                  throw std::runtime_error("Unable to open file");
              }
          }
      //释放资源
      ~FileHandler()
      {
          file.close();
      }
      void write(const std::string& data)
      {
          if(file.is_open())
          {
              file << data << std::endl;
          }
      }
  private:
      std::ofstream file;
  };
  
  int main()
  {
      try{
          FileHandler fh("example.txt");
          fh.write("Hello, RAII!");
      }catch(const std::exception& e)
      {
          std::cerr << e.what() << std::endl;
      }
      return 0;
  }
  ```

  

- **RAII的好处**

  - 异常安全

    使用RAII能够确保在异常发生时自动释放资源，避免资源泄露。

  - 简化资源管理

    将资源的获取和释放逻辑封装在类中，是代码更加简洁且方便维护。

  - 与智能指针的结合

    ```c++
    std::unique_ptr<int> ptr(new int(5));
    ```

  - 拓展应用

    通过`std::lock_guard`对锁进行管理，确保锁在作用范围内被正确释放。

    ```c++
    std::mutex mtx;
    
    {
        std::lock_guard<std::mutex> lock(mtx);
    }//mtx在此处自动释放
    ```

    

# 二、C++11新特性

## 1、C++11中有哪些常用的新特性？

- **自动类型推导（`auto`）**

  - `auto`关键字允许编译器根据初始化表达式自动推导变量的类型，减少显式声明变量的冗余。

  - 优点：

    - 简化代码，减少重复性。
    - 提高代码的可读性和可维护性。
    - 自动类型推导对类型安全编程非常有帮助，尤其是在使用复杂的迭代器类型时。

  - ```c++
    #include <vector>
    
    int main() {
        auto x = 42;  // 自动推导为 int
        auto y = 3.14;  // 自动推导为 double
    
        std::vector<int> vec = {1, 2, 3, 4, 5};
        for (auto it = vec.begin(); it != vec.end(); ++it) {
            // it 的类型自动推导为 std::vector<int>::iterator
            std::cout << *it << " ";
        }
    }
    ```

- **范围`for`循环**

  - 新的范围`for`循环用于遍历容器或者数组，使代码更加简洁。

  - 优点：

    - 简化遍历操作。
    - 提高代码可读性，减少错误的可能性。

  - ```c++
    #include <vector>
    
    int main() {
        std::vector<int> vec = {1, 2, 3, 4, 5};
        for (const auto& value : vec) {
            std::cout << value << " ";
        }
    }
    ```

- **右值引用和移动语义**

  - 右值引用允许操作右值（临时对象）。移动语义通过右值引用和`std::move`函数，可以**避免不必要的深拷贝**，提高性能。

  - 优点：

    - 优化性能，减少内存分配和拷贝。
    - 提供显式的资源转移语义。

  - ```c++
    #include <iostream>
    #include <vector>
    
    class Example {
    public:
        Example() {
            std::cout << "Constructor\n";
        }
    
        Example(const Example&) {
            std::cout << "Copy Constructor\n";
        }
    
        Example(Example&&) noexcept {
            std::cout << "Move Constructor\n";
        }
    };
    
    int main() {
        Example e1;	// 调用普通构造函数
        Example e2 = std::move(e1);  // 调用移动构造函数
    }
    ```

- **智能指针**

  - C++11提供了`std::unique_ptr`、`std::shared_ptr`和`std::weak_ptr`，用于自动管理动态内存，减少内存泄露风险。

  - 优点：

    - 自动管理动态分配的内存。
    - 提高程序的安全性，防止内存泄漏。

  - ```c++
    #include <memory>
    
    int main() {
        std::unique_ptr<int> uptr = std::make_unique<int>(42);  // 使用 unique_ptr
        std::shared_ptr<int> sptr = std::make_shared<int>(42);  // 使用 shared_ptr
    }
    ```

- **`lambda`表达式（匿名函数）**

  - `lambda`表达式是匿名函数的轻量级实现，提供了函数对象的简洁表示。可以捕获局部变量，便于在局部上下文中定义小型函数。

  - 优点：

    - 提高代码的灵活性。
    - 可以捕获局部变量，便于在局部上下文中定义小型函数。

  - ```c++
    #include <algorithm>
    #include <vector>
    #include <iostream>
    
    int main() {
        std::vector<int> numbers = {1, 2, 3, 4, 5};
    
        auto isEven = [](int x) -> bool { return x % 2 == 0; };
    
        numbers.erase(std::remove_if(numbers.begin(), numbers.end(), isEven), numbers.end());
    
        for (const auto& num : numbers) {
            std::cout << num << " ";
        }
    }
    ```

- **空指针常量**

  - `nullptr` 是一个类型安全的指针常量，取代了 `NULL`，避免了 `NULL` 与整数混淆的问题。

  - 优点：

    - 提供更好的类型安全性。
    - 避免了传统 `NULL` 带来的歧义。

  - ```c++
    void func(int* ptr) {
        if (ptr == nullptr) {
            std::cout << "Pointer is null\n";
        }
    }
    
    int main() {
        func(nullptr);  // 传递 nullptr，而不是 0 或 NULL
    }
    ```

- **线程支持库**

  - C++11 引入了一个新的**标准线程库**，提供了跨平台的线程管理功能，包括 `std::thread`、`std::mutex`、`std::condition_variable` 等。标准化的多线程支持，简化了跨平台开发。提供了强大的线程同步机制。

  - 优点：

    - 标准化的多线程支持，简化了跨平台开发。
    - 提供了强大的线程同步机制。

  - ```c++
    #include <thread>
    #include <iostream>
    
    void hello() {
        std::cout << "Hello from thread!\n";
    }
    
    int main() {
        std::thread t(hello);
        t.join();  // 等待线程完成
    }
    ```

- **原子操作库**

  - C++11 提供了 `std::atomic` 模板，用于无锁编程，确保操作的原子性，以提高多线程环境下的安全性和性能。

  - 优点：

    - 提供安全的原子操作支持。
    - 提高多线程程序的性能。

  - ```c++
    #include <atomic>
    #include <iostream>
    #include <thread>
    
    std::atomic<int> counter(0);
    
    void increment() {
        for (int i = 0; i < 1000; ++i) {
            ++counter;
        }
    }
    
    int main() {
        std::thread t1(increment);
        std::thread t2(increment);
    
        t1.join();
        t2.join();
    
        std::cout << "Final counter value: " << counter << std::endl;
    }
    ```

- **强类型枚举**

  - `enum class` 提供了强类型和作用域控制的枚举类型，防止传统枚举带来的隐式转换和作用域污染问题。

  - 优点：

    - 提供强类型检查。
    - 避免枚举之间的隐式转换

  - ```c++
    enum class Color { Red, Green, Blue };
    Color c = Color::Red;
    
    if (c == Color::Green) {
        std::cout << "Color is green\n";
    }
    ```

- **列表初始化**

  - 初始化列表使得初始化 `std::array` 和 `std::vector` 更加方便。

  - 优点：

    - 简化容器的初始化。
    - 提高代码的可读性和安全性。

  - ```c++
    #include <array>
    #include <vector>
    
    int main() {
        std::array<int, 3> arr = {1, 2, 3};
        std::vector<int> vec = {4, 5, 6};
    }
    ```

- **类型别名**

  - `using` 关键字提供了比 `typedef` 更加灵活的类型定义方式，尤其在模板编程中非常有用。

  - 优点：

    - 提高代码的可读性。
    - 使模板的类型定义更加简洁。

  - ```c++
    #include <vector>
    
    using IntVector = std::vector<int>;
    
    int main() {
        IntVector vec = {1, 2, 3};
    }
    ```

- **静态断言**

  - `static_assert` 在编译时进行条件检查，如果条件不满足会触发编译错误。

  - 优点：

    - 提供编译期断言，捕捉潜在的错误。
    - 提高代码的健壮性。

  - ```c++
    static_assert(sizeof(int) == 4, "int size is not 4 bytes");
    ```

- **`std::function`和`std::bind`委托构造函数**

  - `std::function` 是一个通用的函数包装器，可以存储函数对象。`std::bind` 用于绑定函数的部分参数。

  - 优点：

    - 提高函数对象的灵活性。
    - 简化回调机制的实现。

  - ```c++
    #include <functional>
    #include <iostream>
    
    void print(int a, int b) {
        std::cout << "a: " << a << ", b: " << b << std::endl;
    }
    
    int main() {
        auto boundFunc = std::bind(print, 10, std::placeholders::_1);
        boundFunc(20);  // 输出: a: 10, b: 20
    }
    ```

- **显式虚函数重载**

- **`noexcept`关键字**

  - `noexcept` 用于指定函数不会抛出异常，帮助编译器优化和提供强制性的异常安全保证。

  - 优点：

    - 提供强制的异常安全性。
    - 提高编译器优化的能力。

  - ``` c++
    void func() noexcept {
        // 确保不抛出异常
    }
    ```

- **变长模板**







## 2、什么是C++的列表初始化？

C++中的**列表初始化（List Initialization）**是一种新的对象初始化语法，引入于C++11，它使用花括号`{}`来初始化对象或者变量。列表初始化使得初始化变得更加简介、安全，并且能避免一些常见的编译器隐式转换错误。

- **直接列表初始化：**

  - 使用花括号`{}`直接初始化对象或者变量，通常用于构造函数调用。

  - ```c++
    #include <iostream>
    #include <vector>
    
    class Example {
    public:
        Example(int a, int b) {
            std::cout << "Constructor with parameters: " << a << ", " << b << std::endl;
        }
    };
    
    int main() {
        Example e1{1, 2}; // 直接列表初始化
        std::vector<int> vec{1, 2, 3, 4, 5}; // 直接列表初始化
    
        return 0;
    }
    ```

- **复制列表初始化：**

  - 用于赋值初始化，使用等号`=`和花括号`{}`。

  - ```c++
    int main() {
        int x = {10}; // 复制列表初始化
        double y = {3.14}; // 复制列表初始化
    
        std::cout << "x: " << x << ", y: " << y << std::endl;
    
        return 0;
    }
    ```

- **聚合初始化：**

  - 聚合类型（如数组、结构体或类）可以使用列表初始化。这种方式称为**聚合初始化**。

  - ```c++
    struct Point {
        int x;
        int y;
    };
    
    int main() {
        Point p1{1, 2}; // 聚合初始化
        int arr[3] = {1, 2, 3}; // 聚合初始化
    
        std::cout << "Point: (" << p1.x << ", " << p1.y << ")\n";
        std::cout << "Array: {" << arr[0] << ", " << arr[1] << ", " << arr[2] << "}\n";
    
        return 0;
    }
    ```

- **值初始化：**

  - 当使用 `{}` 初始化一个对象而没有提供初始值时，称为**值初始化**。这种方式会将基本数据类型初始化为零，将指针初始化为 `nullptr`，将类对象初始化为其默认构造函数调用。

  - ```c++
    int main() {
        int x{}; // 值初始化为0
        double d{}; // 值初始化为0.0
        int* ptr{}; // 值初始化为nullptr
    
        std::cout << "x: " << x << ", d: " << d << ", ptr: " << ptr << std::endl;
    
        return 0;
    }
    ```

- **列表初始化的优势：**

  - **避免窄化转换：**

    - 使用列表初始化可以避免可能导致**数据丢失**的窄化转换。例如：将浮点数转化为整数时会导致精度丢失。

    - ```c++
      int x1 = 3.14; // 编译通过，但精度丢失，x1 = 3
      int x2{3.14};  // 编译错误，避免了窄化转换
      ```

  - **简化初始化用于：**

    - 使用花括号`{}`可以统一数组、结构体和类对象的初始化用语。

  - **更安全：**

    - 通过列表初始化，可以防止意外的类型转换，并显式指出了被初始化的值，避免了一些常见的编译错误。



## 3、C++中的`move`有什么作用？它的原理是什么？

在C++中，`std::move`是一个标准库函数，用于将对象转化为右值引用（`rvalue reference`）。它的主要作用是帮助实现对象的“移动语义”（`Move Semantics`），从而避免不必要的深拷贝，提高程序的性能。

- **`std::move`的作用**

  - **移动语义**

    - 在现代C++中，移动语义允许对象的资源（如内存、文件句柄等）从一个对象转移到另一个对象，而不需要复制资源。这在处理大数据结构或涉及资源管理时，可以显著提高性能。

  - **资源转移**

    - 通过将对象转化为右值引用，`std::move`使得对象的所有权可以被“移动”到另一个对象，而不是“复制”它的资源。

  - 示例

    - ```c++
      #include <iostream>
      #include <vector>
      #include <utility>  // for std::move
      
      //在下面的示例中，通过 std::move，vec1 的数据被移动到了 vec2，而不是被复制。
      //这使得 vec1 在移动后变为空，而 vec2 拥有了原 vec1 的数据。
      int main() {
          std::vector<int> vec1 = {1, 2, 3, 4, 5};
          std::vector<int> vec2;
      
          // 使用 std::move 将 vec1 的资源移动到 vec2
          vec2 = std::move(vec1);
      
          std::cout << "vec1 size: " << vec1.size() << std::endl; // 输出 0
          std::cout << "vec2 size: " << vec2.size() << std::endl; // 输出 5
      
          return 0;
      }
      ```

- **`std::move`的原理**

  - `std::move`的实现其实非常简单，它的作用是将其参数转换为右值引用，从而允许对该对象进行移动操作。

  - 实现原理（底层实现）

    - ```c++
      template<typename T>
      typename std::remove_reference<T>::type&& move(T&& arg) {
          return static_cast<typename std::remove_reference<T>::type&&>(arg);
      }
      ```

- **总结：**

  - `std::move` 是**实现移动语义**的关键工具，能够将对象的资源“移动”到新的对象上，而不是复制，从而提高程序的效率。它通过将左值转化为右值引用，使得对象能够被“移动”而非“复制”。



## 4、C++中`final`关键字的作用？

在 C++ 中，`final` 关键字是 **C++11** 引入的新特性，主要用于**防止类或虚函数被继承或重写**。

- **防止类被继承**

  当在类定义后加上 `final` 关键字时，该类不能被进一步继承。试图继承该类将会导致编译错误。

  ```c++
  class Base final {
      // 类的定义
  };
  
  // 错误：无法继承被标记为 final 的类
  class Derived : public Base {
      // 编译错误
  };
  ```

  在这个例子中，`Base` 类被标记为 `final`，因此 `Derived` 类无法继承 `Base`，否则编译器会报错。

- **防止虚函数被重写**

  当一个虚函数被声明为 `final` 时，派生类不能重写这个虚函数。试图重写它会导致编译错误。

  ```c++
  class Base {
  public:
      // 虚函数被标记为 final，不能被派生类重写
      virtual void display() final {
          cout << "Base class display" << endl;
      }
  };
  
  class Derived : public Base {
  public:
      // 错误：不能重写被标记为 final 的虚函数
      void display() override {
          cout << "Derived class display" << endl;
      }
  };
  ```

  在这个例子中，`Base` 类的 `display()` 虚函数被标记为 `final`，因此 `Derived` 类无法重写该函数，尝试重写会导致编译错误。

- **`final`的使用场景**

  - 防止类被继承
    - 如果一个类的设计目的是作为**最终类**，无法被进一步扩展，可以使用 `final` 来确保这一点。类似于 Java 中的 `final` 类。
  - 防止虚函数被重写
    - 有时你可能希望某个虚函数在基类中定义后，不再允许子类重写，这时可以使用 `final`。

















# 三、C++进阶

## 1、介绍下C++程序从编写到可执行的整个过程

C++ 程序从编写到生成可执行文件的过程涉及多个步骤，包括编写代码、编译、链接等。

- **编写源代码**

  开发者使用文本编辑器或集成开发环境（IDE）编写 C++ 源代码，文件扩展名通常为 `.cpp`。这些文件包含了程序的实现逻辑，如类定义、函数实现和主函数。

- **预处理**

  在编译之前，预处理器会处理源代码文件中的预处理指令（如 `#include`, `#define`）。预处理阶段的任务包括：

  - 文件包含
    - 处理 `#include` 指令，将头文件的内容插入到源文件中。
  - 宏替换
    - 替换 `#define` 指令定义的宏。
  - 条件编译
    - 处理 `#if`, `#ifdef`, `#endif` 等条件编译指令。

  预处理后的代码会生成一个中间文件，通常扩展名为 `.i`（在某些编译器中可能没有这个文件，但预处理的结果是生成了一个扩展名为 `.i` 的文件）。

- **编译**

  编译器将预处理后的源代码转换为汇编代码。这个过程包括：

  - 词法分析
    - 将源代码分解成词法单元（tokens）。
  - 语法分析
    - 根据语法规则分析词法单元的结构，生成抽象语法树（AST）。
  - 语义分析
    - 检查语义错误（如类型不匹配）。
  - 生成中间代码
    - 将 AST 转换为中间表示形式（如 LLVM IR 或其他中间代码）。
  - 优化
    - 对中间代码进行优化，提高程序效率。
  - 生成汇编代码
    - 将中间代码转换为具体的汇编指令。

  编译后的代码是汇编代码文件，通常扩展名为 `.s`。

- **汇编**

  汇编器将汇编代码转换为机器代码。这个过程包括：

  - 将汇编代码转换成目标代码
    - 生成目标文件，其中包含机器码和其他需要的元数据。

  汇编生成的目标文件扩展名通常为 `.o`（在 Windows 系统上可能是 `.obj`）。

- **链接**

  链接器将目标文件和库文件链接在一起，生成最终的可执行文件。链接过程包括：

  - 符号解析
    - 将所有目标文件中的符号（函数和变量）解析到实际的地址。
  - 地址重定位
    - 调整目标文件中的地址，使它们指向正确的位置。
  - 库链接
    - 将程序所需的库函数（如标准库函数）链接到可执行文件中。

- **生成可执行文件**

  经过链接过程后，最终生成的文件可以直接在操作系统上执行。这个文件包含了机器码以及所有程序运行所需的资源和库。

- **运行**

  执行生成的可执行文件，操作系统将加载该文件到内存中，执行程序的指令。程序的执行可以涉及操作系统调用、内存管理、输入输出操作等。



## 2、什么是C++中的`auto`和`decltype`？

在 C++ 中，`auto` 和 `decltype` 是用于类型推导的关键字，它们可以简化代码，尤其是在需要处理复杂类型时。

- **`auto`关键字**

  `auto` 用于在变量声明时**自动推导变量的类型**。编译器根据变量的初始化表达式来确定其类型。它的目的是减少代码中的类型声明，尤其是在类型复杂或难以书写的情况下。

  ```c++
  int a = 5;
  auto b = a;  // b 的类型是 int
  ```

  - 常见使用场景

    - 简化声明

      - 对于复杂类型，如迭代器或模板类型，`auto` 可以大大简化声明。

        ```c++
        std::vector<int> vec = {1, 2, 3};
        auto it = vec.begin();  // 自动推导 it 的类型为 std::vector<int>::iterator
        ```

    - 函数返回类型

      - 当函数返回类型比较复杂时，可以使用 `auto` 推导出返回类型。

        ```c++
        auto sum(int x, int y) {
            return x + y;  // 返回类型自动推导为 int
        }
        ```

    - `lambda`表达式

      - 在使用 `lambda` 表达式时，`auto` 也可以自动推导函数类型。

        ```c++
        auto lambda = [](int x) { return x + 1; };
        ```

  - 注意事项

    - `auto` 必须有一个初始化表达式，因为它依赖于初始化来推导类型。

    - 使用 `auto` 时，推导出的类型不会是引用类型或常量类型，除非你明确指定引用或 `const`。

      ```c++
      const int x = 10;
      auto y = x;  // y 的类型是 int，而不是 const int
      ```

      如果需要保留 `const` 或引用属性，可以这样写：

      ```c++
      const auto& z = x;  // z 的类型是 const int&
      ```

- **`delctype`关键字**

  `decltype` 是一个关键字，用于**获取表达式的类型**，而**不计算该表达式**。它返回表达式的类型，可以用于变量声明、函数返回类型等。

  - 使用示例

    ```c++
    int x = 5;
    decltype(x) y = x;  // y 的类型是 int
    ```

  - 常见使用场景

    - 推导复杂类型

      - 在不方便写出某个表达式的类型时，`decltype` 可以根据该表达式推导出类型。

        ```c++
        int a = 5;
        float b = 2.0;
        decltype(a + b) result;  // result 的类型是 float（a + b 的类型）
        ```

    - 结合函数返回类型

      - 当函数返回类型依赖于参数的类型时，`decltype` 非常有用。

        ```c++
        template <typename T1, typename T2>
        auto add(T1 a, T2 b) -> decltype(a + b) {
            return a + b;
        }
        ```

        在上面的模板函数中，`decltype(a + b)` 确保返回值类型与 `a + b` 的类型一致。

    - 结合模板

      - 在模板编程中，`decltype` 用来推导模板参数表达式的类型，简化了模板推导。

        ```c++
        template <typename T>
        void printType(T& value) {
            decltype(value) x = value;  // x 的类型与 value 一致
        }
        ```

  - 注意事项

    - 类型保持

      - `decltype` 保留了表达式的所有类型修饰符，包括 `const` 和引用。

        ```c++
        int x = 10;
        int& ref = x;
        decltype(ref) y = x;  // y 的类型是 int&，因为 ref 是引用
        ```

    - 不同表达式的推导

      - `decltype` 根据表达式的具体形式决定类型。例如，`decltype(x)` 和 `decltype((x))` 的结果可能不同。`decltype(x)` 返回 `x` 的类型，而 `decltype((x))` 返回 `x` 的引用类型。

        ```c++
        int a = 5;
        decltype(a) x = a;   // x 的类型是 int
        decltype((a)) y = a; // y 的类型是 int&
        ```

- **`auto`和`decltype`的组合使用**

  有时可以将 `auto` 和 `decltype` 结合使用，特别是在模板编程或需要根据表达式推导类型时。

  ```c++
  auto x = 5;
  decltype(x) y = 10;  // y 的类型是 int
  ```

  结合函数返回类型

  ```c++
  template <typename T1, typename T2>
  auto multiply(T1 a, T2 b) -> decltype(a * b) {
      return a * b;
  }
  ```

- **总结**

  - **`auto`** 主要用于自动推导变量类型，减少显式类型声明的冗长。
  - **`decltype`** 用于获取表达式的类型，可以用在更灵活的场景，如函数返回类型推导和模板编程。



## 3、C++中为什么new和delete一定要配对使用？

在 C++ 中，`new` 和 `delete` 是用于动态内存管理的操作符。它们一定要配对使用的原因是，正确的内存管理对于程序的稳定性和效率至关重要。如果不配对使用 `new` 和 `delete`，可能会导致**内存泄漏**和**未定义行为**。

- **动态内存分配的工作原理**

  - 当使用`new`分配内存时，程序从堆（`heap`）中为对象或数据分配内存空间。

  - 分配的内存不会在当前作用域结束时自动释放，程序员必须手动调用`delete`来释放内存。如果没有显式地调用`delete`，分配地内存就会一直保留，知道程序结束。

    ```c++
    int* p = new int(10);  // 动态分配一个整数
    ```

    这段代码会在堆中分配一个 `int` 类型的内存，`p` 指向该内存单元。如果此时没有用 `delete` 释放这块内存，它将一直占用空间，导致内存泄漏。

- **`new`和`delete`配对使用的原因**

  - 避免内存泄漏：

    - 如果使用`new`分配了内存但没有使用`delete`释放它，程序将永久无法再使用这块内存，这被称为**内存泄露**。在长时间运行的程序中，内存泄漏会导致内存耗尽，最终导致程序崩溃或系统性能下降。

      ```c++
      void leak() {
          int* p = new int(5);  // 动态分配内存
          // 没有 delete，导致内存泄漏
      }
      ```

  - 释放资源

    - 当分配了动态内存后，操作系统不会自动知道何时可以回收这些内存，只有程序员知道某块内存何时不再需要。如果不适用`delete`释放内存，这些资源将一直被占用。

      ```c++
      int* p = new int(10);  // 分配内存
      delete p;  // 释放内存
      ```

  - 防止内存碎片化

    - 堆管理器会根据程序的动态分配请求分配内存。如果 `new` 被频繁使用而没有相应的 `delete`，堆中的内存会变得越来越分散，导致**内存碎片化**，降低内存的利用效率。

- **不匹配使用`new`和`delete`的后果**

  - 内存泄露

    - 如果你分配了内存却没有释放它，程序中的可用内存会越来越少，最终可能导致内存不足。这种情况特别容易发生在长时间运行的程序或频繁分配和释放内存的程序中。

      ```c++
      int* p = new int(10);
      // 没有 delete p; 导致内存泄漏
      ```

  - 重复释放资源

    - 如果你多次对同一块内存调用 `delete`，程序会尝试释放已经被释放的内存，导致**未定义行为**。可能会导致程序崩溃或产生不可预测的错误。

      ```c++
      int* p = new int(10);
      delete p;  // 第一次释放内存
      delete p;  // 再次释放同一块内存，未定义行为
      ```

  - 悬空指针

    - 如果在释放内存后继续使用原来的指针而没有将其置为 `nullptr`，指针将指向已经释放的内存区域。此时，访问这块内存将导致**悬空指针**问题，可能导致程序崩溃。

      ```c++
      int* p = new int(10);
      delete p;  // 释放内存
      *p = 20;   // 继续使用释放后的指针，悬空指针，未定义行为
      ```

      正确的做法是，在释放内存后将指针置为 `nullptr`：

      ```c++
      delete p;
      p = nullptr;  // 防止悬空指针
      ```

- **内存管理中的其他注意事项**

  - 配对规则

    - 使用 `new` 分配内存时，必须使用 `delete` 释放它；而使用 `new[]` 分配数组时，必须使用 `delete[]` 释放它。`delete[]` 会调用数组中每个元素的析构函数，而 `delete` 只会调用单个对象的析构函数。

      ```c++
      int* p = new int[10];  // 使用 new[] 分配数组
      delete[] p;  // 必须使用 delete[] 释放
      ```

  - 智能指针

    - C++11 引入了智能指针（如 `std::unique_ptr` 和 `std::shared_ptr`）来简化内存管理，避免手动调用 `delete`。智能指针会在超出作用域时自动释放内存，从而减少内存泄漏和悬空指针的风险。

      ```c++
      std::unique_ptr<int> p = std::make_unique<int>(10);  // 自动管理内存
      ```

      

      





# 四、C++面向对象

## １、介绍C++多态的实现原理

C++中的多态是面向对象编程中的一个核心特性，它允许**同一接口**根据**不同对象的类型**来表现出不同的行为（对于**同一种指令**，针对**不同的对象**，产生**不同的行为**）。多态分为**编译时多态**和**运行时多态**。C++多态的实现主要依赖于**虚函数**和**继承**机制。

- **多态的类型：**

  - 编译时多态（静态多态）

    编译时多态，也成为**静态绑定**或**早绑定**，在**编译阶段**确定函数的调用。这种多态主要通过**函数重载**、**运算符重载**、**模板**来实现。

    - 函数重载：同名函数可以有不同的参数列表，编译时根据调用参数类型来确定调用哪个函数。
    
    - 模板：模板是一种泛型编程方式，在编译时生成相应的代码。
    
    - 示例：
    
      ```c++
      #include <iostream>
      void print(int i) {
          std::cout << "Integer: " << i << std::endl;
      }
      
      void print(double d) {
          std::cout << "Double: " << d << std::endl;
      }
      
      int main() {
          print(5);    // 调用print(int)
          print(5.5);  // 调用print(double)
          return 0;
      }
      ```
    
  - 运行时多态（动态多态）
  
    运行时多态，也称为**动态绑定**或**晚绑定**，是在**运行时**根据对象的实际类型来决定调用哪个函数。C++通过**继承**和**虚函数**来实现运行时多态，虚函数的调用依赖于**虚函数表（vtable）**。
  
- **运行时多态的原理：**

  运行时多态是通过**继承**和**虚函数**实现的。当一个基类中包含了虚函数，派生类可以重写这些虚函数，从而实现多态。

  - 虚函数和虚函数表（vtable）：

    - 虚函数：在基类中使用关键词`virtual`定义的函数。
    - 虚函数表：每个含有虚函数的类会维护一个虚函数表，这张表存储了该类所有的虚函数的地址。在每个对象的内存布局中，会有一个指向虚函数表的指针，称为**虚指针（vpr）**。在运行时，虚函数的调用通过虚函数指针查找虚函数表，进而调用对应的虚函数。

    **注：虚函数表在编译器编译时确定。**

  - 虚指针（vptr）

    虚指针是对象中的一个隐藏指针，指向该对象所属类的虚函数表。每个对象都有一个虚指针，用于动态调用虚函数。虚指针是在对象创建时由编译器自动生成的，并且在构造函数中初始化为指向类的虚函数表。
    
    **注：虚指针（虚函数表指针）在对象构造的时候确定。**

- 运行时的函数调用过程：

  - 当调用一个对象的虚函数时，编译器首先通过对象的虚指针找到该对象所属类的虚函数表。

  - 然后在虚函数表中根据函数的偏移量找到对应的虚函数地址，并调用该函数。

    ```c++
    #include <iostream>
    
    using namespace std;
    
    class Base {
    public:
        //1、基类定义虚函数
        virtual void show() {
            cout << "Base::show()" << endl;
        }
    };
    
    class Derived : public Base {
    public:
        //2、派生类重写该虚函数
        void show() override {
            cout << "Derived::show()" << :endl;
        }
    };
    
    int main() {
        //3、创建派生类对象
        Deriver derived = new Derived();
        //4、用基类的指针（引用）指向派生类对象
        Base* ptr = derived;
        //5、使用基类的指针（引用）调用虚函数
        ptr->show();
        delete ptr;
        return 0;
    }
    ```

    运行时的行为：

    - `Base* ptr = new Derived();` 创建了一个指向`Derived()`类对象的`Base`类指针。
    - 当调用`ptr->show()`时，由于`show()`是虚函数，程序在运行是通过`ptr`的虚指针找到`Derived`类的虚函数表，最终调用的是`Derived::show()`而不是`Base::show()`。

- **虚函数表和虚指针的内存布局：**

  通常，编译器会为含有虚函数的类生成一个虚函数表（`vtable`），并为每个对象分配一个虚指针（`vptr`），它指向这个虚函数表。这个虚函数表存储了类的虚函数的地址。

  - 虚函数表（vtable）：包含类的所有虚函数地址
  
  - 虚指针（vptr）：每个含有虚函数的类对象都有一个隐藏的指针，指向该类的虚函数表。
  
    内存布局：
  
    ![image-20240905161300609](C:\Users\ML\AppData\Roaming\Typora\typora-user-images\image-20240905161300609.png)
  
- **多态的使用场景：**

  - 统一接口处理不同类型的对象：通过基类指针或引用，可以处理不同的派生类对象。
  - 扩展性：可以通过派生类扩展程序的功能，而不需要修改现有代码。
  - 动态绑定：程序在运行时自动选择适合的函数执行，实现更灵活的系统。

- **C++多态的优缺点：**

  - 优点：
    - 灵活性：基类可以定义通用的接口，派生类可以根据需要重写这些接口，实现灵活的设计。
    - 扩展性：通过继承和虚函数，系统可以在不修改现有代码的情况下进行扩展。
    - 代码复用：派生类继承了基类的属性和行为，避免了重复的代码编写。
  - 缺点：
    - 性能开销：虚函数调用需要通过虚函数表查找函数地址，这相对于直接调用函数有一定的性能开销。
    - 增加内存占用：每个对象需要存储一个虚指针（`vptr`），并且类的虚函数表也需要占用内存。
    - 调试复杂：由于多态在运行时决定函数的调用，调试时很难在编译阶段明确知道具体调用的是哪个函数。



## 2、C++中虚函数的原理

在C++中，虚函数（virtual function）是一种支持**动态多态**（也称为**运行时多态**）的机制，使得程序可以**在运行时决定调用哪个派生类的函数**。虚函数的实现基于**虚函数表（vtable）**和**虚指针（vptr）**。通过这些机制，C++可以在继承体系中根据实际对象的类型选择正确的函数进行调用。

- **虚函数的原理**

  当一个类中**有虚函数**时，编译器会**为这个类创建一个虚函数表（vtable）**。虚函数表是一个函数指针数组，数组中的每个元素指向类的虚函数。每个包含虚函数的类的对象中，都会有一个**虚指针（vptr）**，这个指针指向该类的虚函数表。

  - 具体过程如下：
    - 虚函数表（vtable）：
      - 每个**类**有一个**虚函数表**，用来**存储指向虚函数的指针**。当类中定义了虚函数，编译器就会生成这个表。对于基类和派生类来说，它们各自拥有自己的虚函数表。如果派生类重写了基类的虚函数，则派生类的虚函数表中会将该函数指向派生类的重写版本。
    - 虚指针（vptr）：
      - 在每个包**含虚函数的类的对象**中，编译器会隐式添加一个**虚指针（通常放在对象的头部）**，**指向该类的虚函数表**。这样，当程序运行时，通过这个虚指针可以查找到虚函数表，并调用其中的函数。
    - 虚函数调用的过程：
      - 当通过指针或引用调用虚函数时，程序首先会通过对象的虚指针找到虚函数表，然后从虚函数表中定位到合适的函数指针，并进行调用。这就是所谓的**动态绑定**（或**后期绑定**），即函数的调用在运行时根据对象的类型来确定。

- **示例：**

  ```c++
  #include <iostream>
  using namespace std;
  
  class Base {
  public:
      //1、基类定义虚函数
      virtual void show() {  // 虚函数
          cout << "Base::show()" << endl;
      }
  };
  
  class Derived : public Base {
  public:
      //2、派生类重写虚函数
      void show() override {  // 重写基类的虚函数
          cout << "Derived::show()" << endl;
      }
  };
  
  int main() {
      //3、创建派生类对象
      Derived derived = new Derived();
      //4、基类的指针指向派生类对象
      Base* basePtr = derived;
      //5、基类的指针调用虚函数
      basePtr->show();  // 动态绑定，调用 Derived::show()
      delete basePtr;
      return 0;
  }
  ```

- **虚函数表的结构**

  假设有如下类层次结构：

  ```c++
  class Base {
      virtual void func1();
      virtual void func2();
  };
  
  class Derived : public Base {
      void func1() override;
  };
  ```

  - `Base`类的虚函数表可能是这样的：

    ```c++
    Base_vtable:
    [0] Base::func1()
    [1] Base::func2()
    ```

    

  - `Derived`类的虚函数表则会继承自`Base`，并对`func1()`进行重写：

    ```c++
    Derived_vtable:
    [0] Derived::func1()   // 重写了 func1
    [1] Base::func2()      // 没有重写 func2
    ```

- **虚函数的开销**

  - 空间开销
    - 每个对象需要存储一个虚指针（`vptr`），虚函数表也占用了一些内存。
  - 时间开销
    - 每次调用虚函数时，需要通过虚指针找到虚函数表，再从表中查找函数指针，因而比普通函数调用稍慢，属于间接调用。



## 3、C++中构造函数可以是虚函数吗？为什么？

在C++中，**构造函数不能是虚函数**。

- **构造函数的职责：**

  构造函数的主要职责是**初始化对象的成员变量并为对象分配内存**。在对象创建的过程中，构造函数是从基类到派生类逐层调用的。因为在构造过程中，派生类对象还没有被完全初始化，基类的构造函数会首先执行，而此时派生类的成员还没有被正确初始化，调用派生类的虚函数是不安全的。因此，构造函数不适合作为虚函数。

- **对象的虚指针在构造过程中未完全初始化：**

  虚函数表（vtable）的工作机制依赖于虚指针（vptr）。虚指针通常在**基类的构造函数**中进行初始化，并在派生类的构造函数中更新为指向派生类的虚函数表。在基类的构造函数执行时，虚指针还指向基类的虚函数表，如果此时允许调用虚函数，那么会出现调用基类版本的虚函数，而不是派生类的版本，这会违反动态多态的原则。为了避免这种混乱，C++不允许构造函数为虚函数。

- **构造函数和虚函数的用途不同：**

  - 构造函数用于初始化对象，包括基类和派生类对象。
  - 虚函数用于实现动态多态，允许通过基类的指针或引用在运行时调用派生类的函数。

  构造函数在对象创建时用于设置对象的初始状态，它必须确保整个对象从基类到派生类都正确地构建，而虚函数则是为了允许多态行为在对象已经构建完成后进行动态绑定。两者的目的和生命周期不同，因此C++不允许构造函数是虚函数。

- **替代方案：工厂模式**

  尽管构造函数不能是虚函数，但可以通过其他设计模式，比如**工厂模式**，来实现对象的多态创建。具体来说，可以使用一个虚函数的工厂方法来生成不同类型的对象：

  ```c++
  class Base {
  public:
      virtual ~Base() {}
      virtual void show() = 0;
      static Base* create();
  };
  
  class Derived : public Base {
  public:
      void show() override {
          std::cout << "Derived" << std::endl;
      }
  };
  
  Base* Base::create() {
      return new Derived();
  }
  ```

  通过这种方式，虽然构造函数不能是虚函数，但可以通过静态工厂方法间接实现多态对象的创建。



## 4、C++中析构函数一定要是虚函数吗？为什么？

在C++中，析构函数不一定必须是虚函数，但在使用**继承**时，如果类可能会通过**基类指针或引用**来删除对象，那么基类的析构函数应当声明为虚函数。

- **原因：**

  - 如果基类的析构函数不是虚函数，当使用基类的指针或引用指向一个派生类对象，并调用`delete`时，只会调用基类的析构函数，而不是调用派生类的析构函数。这可能会导致派生类中的资源（如动态内存、文件句柄）得不到正确释放，造成资源泄露或其他问题。

- 示例

  - ```c++
    class Base {
    public:
        ~Base() {
            std::cout << "Base destructor\n";
        }
    };
    
    class Derived : public Base {
    public:
        ~Derived() {
            std::cout << "Derived destructor\n";
        }
    };
    
    int main() {
        Base* obj = new Derived();
        delete obj;  // 只会调用 Base 的析构函数，Derived 的析构函数不会被调用
        return 0;
    }
    ```

    在上面的代码中，`delete obj` 只调用了基类 `Base` 的析构函数，而不会调用派生类 `Derived` 的析构函数，导致派生类的资源无法正确释放。

-  **解决方法：将基类的析构函数声明为虚函数。**

  - ```c++
    class Base {
    public:
        virtual ~Base() {
            std::cout << "Base destructor\n";
        }
    };
    
    class Derived : public Base {
    public:
        ~Derived() {
            std::cout << "Derived destructor\n";
        }
    };
    
    int main() {
        Base* obj = new Derived();
        delete obj;  // 现在会先调用 Derived 的析构函数，然后再调用 Base 的析构函数
        return 0;
    }
    ```

    通过将基类的析构函数声明为虚函数，确保了删除派生类对象时，会**先调用派生类的析构函数**，然后**再调用基类的析构函数**，确保了资源的正确释放。

- **总结：**

  - **不是所有的析构函数都需要是虚函数**，但当你有**多态行为**并且可能通过基类指针或引用删除对象时，基类的析构函数应该是虚函数，以确保对象能够正确析构。



## 5、什么是C++中的虚继承？

C++ 中的 **虚继承**（virtual inheritance）是一种用于解决 **菱形继承**（diamond inheritance）问题的机制。菱形继承结构中，派生类通过多个路径继承同一个基类，可能导致基类成员的**重复继承**问题。虚继承允许派生类通过一条唯一的路径继承基类，从而避免基类成员的重复。

- **菱形继承问题**

  假设有一个基类 `Base`，有两个类 `Derived1` 和 `Derived2` 分别继承 `Base`，然后还有一个类 `DerivedFinal` 同时继承 `Derived1` 和 `Derived2`，这就是典型的**菱形继承结构**。问题在于 `DerivedFinal` 类会从 `Derived1` 和 `Derived2` 两个路径继承 `Base`，因此会有两个 `Base` 类的副本。

  ```c++
  class Base {
  public:
      int value;
  };
  
  class Derived1 : public Base { };
  
  class Derived2 : public Base { };
  
  class DerivedFinal : public Derived1, public Derived2 { };
  
  int main() {
      DerivedFinal obj;
      obj.Derived1::value = 1;  // DerivedFinal 对象中有两个 Base 部分
      obj.Derived2::value = 2;  // 两个不同的 Base 对象
      return 0;
  }
  ```

  在上面的例子中，`DerivedFinal` 类通过 `Derived1` 和 `Derived2` 分别继承了两个 `Base`，因此它拥有两个 `Base` 类的副本。这意味着 `Base` 类中的成员（如 `value`）在 `DerivedFinal` 中会有两个实例。如果我们访问 `DerivedFinal` 对象中的 `value`，需要明确指定是 `Derived1::value` 还是 `Derived2::value`，否则会引发混淆。

- **虚继承的解决方案**

  为了避免上述问题，C++ 提供了**虚继承**，即通过 `virtual` 关键字在继承时声明基类。虚继承确保无论通过多少条继承路径继承同一个基类，最终在最底层的派生类中只会有一个基类的实例。

  ```c++
  class Base {
  public:
      int value;
  };
  
  class Derived1 : virtual public Base { };
  
  class Derived2 : virtual public Base { };
  
  class DerivedFinal : public Derived1, public Derived2 { };
  
  int main() {
      DerivedFinal obj;
      obj.value = 3;  // 只有一个 Base 部分
      return 0;
  }
  ```

  在这个例子中，`Derived1` 和 `Derived2` 通过**虚继承**继承了 `Base`，因此 `DerivedFinal` 只包含一个 `Base` 类的实例。这解决了菱形继承中基类成员重复的问题。

- **虚继承的原理**

  虚继承的**核心思想**是：在派生类中，不直接包含基类的成员，而是通过一个共享的基类实例来访问基类的成员。这使得所有从同一基类虚继承的派生类，共享基类的同一个实例。

- **虚继承的用法**

  - 当派生类可能从多个路径继承同一个基类时，可以使用虚继承。

    ```c++
    class Derived : virtual public Base { };
    ```

- **访问虚基类成员**

  在虚继承中，派生类共享同一个基类的实例。因此，如果 `Derived1` 和 `Derived2` 虚继承自 `Base`，那么 `DerivedFinal` 可以直接访问 `Base` 的成员。

  ```c++
  class Base {
  public:
      int value;
  };
  
  class Derived1 : virtual public Base { };
  
  class Derived2 : virtual public Base { };
  
  class DerivedFinal : public Derived1, public Derived2 { };
  
  int main() {
      DerivedFinal obj;
      obj.value = 10;  // 直接访问 Base 的成员
      return 0;
  }
  ```

  在这个例子中，`DerivedFinal` 通过虚继承共享了 `Base` 的一个实例，因此它可以直接访问 `Base` 中的成员 `value`，而不需要指定继承路径。



## 8、C++中什么是深拷贝？什么是浅拷贝？

在C++中，**深拷贝**和**浅拷贝**是两种不同的对象拷贝方式，尤其在类中涉及动态内存分配和指针成员时，它们的行为差异尤为明显。

- **浅拷贝**

  **浅拷贝**只复制对象的值，不管这个值是基础类型还是指针。如果对象中包含指针，浅拷贝会直接复制这个指针的地址，而不是指针指向的内容。

  - 特性：

    - 对于普通成员变量（如 `int`、`double` 等），浅拷贝直接复制它们的值。
    - 对于指针成员，浅拷贝只复制指针的地址，即多个对象共享同一块内存。

  - 浅拷贝的问题：

    - 如果两个对象共享同一块动态内存，当一个对象析构或修改该内存时，另一个对象的指针可能会指向无效的地址或被意外修改，从而引发**悬空指针**或**数据不一致**问题。

  - ```c++
    class MyClass {
    public:
        char* data;
        
        MyClass(int val){
            data = new int(val);  // 动态分配内存
        }
    
        // 浅拷贝：编译器生成的默认拷贝构造函数
        MyClass(const MyClass& other){
            data = other.data;  // 仅复制指针，两个对象共享同一块内存
        }
    
        ~MyClass() {
            delete data;  // 析构函数释放动态分配的内存
        }
    };
    
    int main() {
        MyClass obj1(10);
        MyClass obj2 = obj1;  // 浅拷贝，obj2.data 指向与 obj1.data 相同的内存
        *obj2.data = 20;      // 修改 obj2 的数据，也会影响 obj1 的数据
    
        // 当 obj1 和 obj2 析构时，delete 会被调用两次，导致程序崩溃
    }
    ```

    在上面的例子中，`obj1` 和 `obj2` 共享同一块内存，当两个对象都调用析构函数时，动态内存会被释放两次，导致未定义行为（如程序崩溃）。

- **深拷贝**

  **深拷贝**不仅复制对象的值，还会为指针成员分配新的内存，并复制指针指向的内容。这确保每个对象都有自己独立的内存空间。

  - 特性：

    - 对于普通成员变量，深拷贝和浅拷贝一样，直接复制值。
    - 对于指针成员，深拷贝会为目标对象分配新的内存，并将源对象的数据复制到新分配的内存中。

  - 深拷贝的好处：

    - 深拷贝解决了浅拷贝的问题，每个对象都拥有自己独立的内存空间，不会因为修改一个对象的内容而影响另一个对象，同时也避免了重复释放内存的问题。

  - ```C++
    class MyClass {
    public:
        int* data;
    
        MyClass(int val) {
            data = new int(val);  // 动态分配内存
        }
    
        // 深拷贝：拷贝构造函数
        MyClass(const MyClass& other) {
            data = new int(*other.data);  // 分配新的内存并复制内容
        }
    
        ~MyClass() {
            delete data;  // 释放动态分配的内存
        }
    };
    
    int main() {
        MyClass obj1(10);
        MyClass obj2 = obj1;  // 深拷贝，obj2.data 指向新的内存
    
        *obj2.data = 20;      // 修改 obj2 的数据，不影响 obj1
    
        // 没有重复释放内存的问题
    }
    
    ```

    在此例中，`obj1` 和 `obj2` 分别拥有独立的内存空间，修改 `obj2` 的 `data` 不会影响 `obj1`，并且两个对象析构时，各自释放自己的内存，不会产生内存重复释放的问题。

- **区别**
  - 浅拷贝：仅复制指针的地址，两个对象共享同一块内存空间。
  - 深拷贝：为指针分配新的内存空间，并复制指针指向的数据，保证对象有独立的内存。
- **什么时候需要深拷贝**
  
  - 当类中包含指针成员，并且希望每个对象有独立的内存空间时。
  - 当多个对象需要独立管理各自资源，而不是共享同一块内存时。
  - 防止多个对象在共享内存时导致的资源管理问题，如悬空指针和重复释放内存等。
- **如何实现深拷贝**
  - 编写自定义的**拷贝构造函数**和**拷贝赋值运算符**。
  - 在拷贝构造函数中为每个指针成员分配新的内存，并复制源对象的数据。
  - 在拷贝赋值运算符中，确保正确释放当前对象的内存，然后为新对象分配内存并复制数据。



## 9、C++中友元函数和友元类有什么作用？

在 C++ 中，友元函数和友元类是**访问控制**的机制，用于**解决类内部的封装问题**，**允许某些外部的函数或类访问该类的私有成员和保护成员**。

- **友元函数**

  - 定义

    - 友元函数是一个被特定类声明为友好的函数，它可以访问该类的所有私有成员和保护成员。友元函数并不是该类的成员函数。

  - 作用

    - 访问私有和保护成员
      - 友元函数可以访问类的私有和保护成员，这对于需要在类外部实现与类内部数据交互的功能非常有用。
    - 操作封装
      - 通过友元函数，可以在不暴露类内部实现的情况下，进行类内部数据的操作。

  - 声明方式

    - 在类中，友元函数通过 `friend` 关键字声明。

      ```c++
      class MyClass {
      private:
          int data;
      
      public:
          MyClass(int val) : data(val) {}
      
          // 友元函数声明
          friend void showData(const MyClass& obj);
      };
      
      // 友元函数定义
      void showData(const MyClass& obj) {
          std::cout << "Data: " << obj.data << std::endl;  // 访问 MyClass 的私有成员
      }
      ```

  - 使用场景

    - 需要在类外部进行某些操作，但又必须访问类的私有数据时。
    - 实现运算符重载（如流插入运算符`<<`和流提取`>>`）。

- **友元类**

  - 定义

    - 友元类是一个被特定类声明为友好的类，该友元类可以访问该类的所有私有成员和保护成员。

  - 作用

    - 访问访问
      - 友元类的所有成员函数可以访问被声明为友好的类的私有和保护成员。这允许两个类之间的紧密合作，而无需将数据公开给所有的类。
    - 模块化设计
      - 可以在类与类之间设计紧密的接口，保持封装性的同时提高灵活性。

  - 声明方式

    - 在类中，友元类通过 `friend` 关键字声明。

      ```c++
      class MyClassB;  // 前向声明
      
      class MyClassA {
      private:
          int data;
      
      public:
          MyClassA(int val) : data(val) {}
      
          // 友元类声明
          friend class MyClassB;
      };
      
      class MyClassB {
      public:
          void showData(const MyClassA& obj) {
              std::cout << "Data: " << obj.data << std::endl;  // 访问 MyClassA 的私有成员
          }
      };
      ```

  - 使用场景

    - 当两个类之间有紧密的合作关系，需要访问对方的私有数据时。
    - 实现更复杂的接口时，其中一个类需要访问另一个类的私有实现细节。



## 10、C++中什么场景下使用继承？什么场景下使用组合？

在 C++ 中，**继承** 和 **组合** 是两种常用的**类关系建模方法**，它们在设计类和对象时各有不同的应用场景和优缺点。选择使用继承还是组合，取决于设计目标和需求。

- **继承**

  - 定义

    - 继承是一种**类与类之间的关系**，其中一个类（子类或派生类）从另一个类（基类或父类）继承属性和行为（数据成员和成员函数）。继承强调的是“是一个”（Is-A）关系。

  - 适用场景

    - 子类化
      - 当你有一个类（基类），它的某些特性和行为可以被其他类（子类）共享时。子类可以继承基类的所有公共和保护成员，并可以添加或重写它们。
    - 代码重用
      - 当多个类有共同的功能时，通过继承可以将共享的功能放在基类中，从而减少代码重复。
    - 多态性
      - 当你需要实现运行时多态性时。基类的指针或引用可以指向不同的派生类对象，从而实现动态绑定和多态行为。
    - 类型拓展
      - 当子类是基类的一种特定类型，具有基类的所有特征，同时增加或修改功能时。例如，`Dog` 类继承自 `Animal` 类，因为 `Dog` 是 `Animal` 的一种。

  - ```c++
    class Animal {
    public:
        virtual void makeSound() const {
            std::cout << "Animal sound" << std::endl;
        }
    };
    
    class Dog : public Animal {
    public:
        void makeSound() const override {
            std::cout << "Bark" << std::endl;
        }
    };
    ```

- **组合**

  - 定义

    - 组合是一种将**一个类的对象作为另一个类的成员变量**的关系。这种关系强调的是“有一个”（Has-A）关系。

  - 适用场景

    - 功能聚合
      - 当一个类需要使用另一个类的功能而不是其所有特征时。组合允许你在类之间建立强耦合关系，同时保留类的独立性。
    - 避免继承的复杂性
      - 当继承关系可能导致复杂的类层次结构或不适用时。使用组合可以避免继承的复杂性，尤其是在多重继承的情况下。
    - 动态变化
      - 当一个对象的行为或功能在运行时可能会变化时。组合允许你在对象生命周期内动态地改变其组成部分。
    - 增强灵活性
      - 通过组合可以更灵活地组合不同的功能和行为，而不是受限于继承链。例如，一个 `Car` 类可以包含 `Engine` 和 `Transmission` 对象，通过组合实现不同的功能。

  - ```c++
    class Engine {
    public:
        void start() {
            std::cout << "Engine starting" << std::endl;
        }
    };
    
    class Car {
    private:
        Engine engine;  // 组合关系
    
    public:
        void start() {
            engine.start();  // 使用 Engine 的功能
            std::cout << "Car starting" << std::endl;
        }
    };
    
    ```

- **选择标准**

  - 选择继承时：
    - 当有明显的“是一个”关系。
    - 当你需要共享代码和实现多态性。
    - 当子类需要访问基类的保护或公共成员。
  - 选择组合时：
    - 当类之间的关系是“有一个”或“使用”。
    - 当你希望避免复杂的继承层次和多重继承。
    - 当你希望在运行时动态改变对象的行为或功能。



## 11、C++成员变量初始化顺序是固定的吗？

在 C++ 中，**成员变量的初始化顺序是固定的**。

- **成员变量初始化顺序**
  - **顺序**：在构造函数的初始化列表中列出的成员变量的初始化顺序，**是按照它们在类定义中的声明顺序进行的**，而不是按照初始化列表中的顺序。

```c++
#include <iostream>

class MyClass {
private:
    int x;
    int y;
    int z;

public:
    MyClass(int a, int b, int c) : y(b), x(a), z(c) {
        std::cout << "Constructor called" << std::endl;
    }

    void printValues() const {
        std::cout << "x: " << x << ", y: " << y << ", z: " << z << std::endl;
    }
};

int main() {
    MyClass obj(1, 2, 3);
    obj.printValues();
    return 0;
}
//输出：
//Constructor called
//x: 1, y: 2, z: 3

```

在这个例子中，类 `MyClass` 中的成员变量 `x`, `y`, `z` 被声明了。构造函数的初始化列表中，`y` 被初始化在 `x` 之前，`x` 被初始化在 `z` 之前。

尽管初始化列表中是 `y`, `x`, `z` 的顺序，但实际的初始化顺序将是 `x`, `y`, `z`，因为它们在类定义中的声明顺序是这样。也就是说：

- `x` 会首先被初始化。
- 然后是 `y`。
- 最后是 `z`。









# 五、C++ STL

## １、C++中`vector`的原理是什么？`resize`和`reserve`的区别是什么？

- **`vector`的原理**

  `std::vector` 是 C++ 标准库中的一个**动态数组容器**，其特点是在内存中连续存储元素，且可以自动调整大小。`vector` 的底层实现通过**动态分配内存**来存储元素，并在需要时扩展内存空间。

  - 动态数组：
    - `vector` 的底层是一块连续的内存空间，当插入新元素超出容量时，它会自动分配更大的内存空间并将原有元素复制到新空间中。
  - 容量(`capacity`)和大小(`size`)：
    - `size`表示`vector`当前存储的元素个数。
    - `capacity`表示`vector`已分配的内存容量，可以存储的最大元素个数。在容量不足时，`vector`会自动扩容。
  - 自动扩容：
    - 当`vector`的容量不足以存储新元素时，`vector`会分配一块更大的内存空间（通常是原来的2倍，与操作系统有关），然后将旧数据复制到新空间中，并释放旧的空间。
  - 插入删除效率：
    - 由于 `vector` 使用的是连续内存，支持随机访问，但在中间插入或删除元素会导致后续元素的移动，因此其插入和删除的效率较低。

- **`resize`和`reserve`的区别：**

  在 `vector` 中，`resize` 和 `reserve` 都可以改变 `vector` 的容量或大小，但它们有不同的作用和使用场景：

  - `reserve`：

    - 作用：`reserve` 用于**预分配内存**，但**不会改变 `vector` 的当前大小**（`size`）。

    - 原理：它只是增加了 `vector` 的容量（`capacity`），以便后续插入元素时减少内存重新分配的次数，提高性能。

    - 场景：在已知需要插入大量元素时，使用 `reserve` 可以避免多次重新分配内存，提升效率。

    - 示例：

      ```c++
      std::vector<int> v;
      v.reserve(10);  // 预分配可以存储 10 个元素的空间，但 size 仍为 0
      v.push_back(1); // 插入元素，size 变为 1，capacity 仍为 10
      ```

  - `resize`：

    - 作用：`resize` 会**改变 `vector` 的当前大小**（`size`），并根据需要调整容量（`capacity`）。

    - 原理：`resize` 不仅可以扩展或缩小 `vector`，还会初始化新增加的元素。当缩小 `size` 时，多余的元素会被删除。当扩展 `size` 时，默认初始化新元素为其类型的默认值（例如整数类型初始化为 0）。

    - 场景：在需要改变 `vector` 的实际元素个数时使用 `resize`。

    - 示例：

      ```c++
      std::vector<int> v;
      v.resize(5);  // 改变 vector 的 size 为 5，capacity 根据需要调整
                    // 新增的元素被初始化为 0
      ```

      **`resize` 和 `reserve` 的区别总结**

      | 功能                  | `reserve`                      | `resize`                           |
      | --------------------- | ------------------------------ | ---------------------------------- |
      | 改变大小 (`size`)     | 否，不改变当前大小             | 是，改变当前大小                   |
      | 改变容量 (`capacity`) | 是，预分配内存，但不改变大小   | 可能会改变容量，自动分配足够的内存 |
      | 使用场景              | 预先分配内存以减少多次扩容操作 | 改变 `vector` 的实际元素个数       |
      | 初始化元素            | 否，仅分配内存                 | 是，新增加的元素会被初始化         |

      **扩容时的区别**

      - `reserve` 仅影响容量，不影响 `size`，不会插入或删除元素。
      - `resize` 改变的是实际元素个数，并根据需要调整容量，且在扩展时对新增的元素进行初始化。



## 2、C++中`deque`的原理？它的内部是如何实现的？

在C++中，`deque`（双端队列）是一个可以在两端高效进行插入和删除操作的容器，和`vector`相比，它不仅支持动态数组，还支持两端的快速操作。它的内部实现主要依赖于**一组连续的小块内存**，而不是像`vector`那样使用单一的连续内存块。这种分段结构使得`deque`在两端的操作非常高效。下面详细解释`deque`的原理及其内部实现。

- **`deque`的原理：**

  `deque`的核心思想是用多个固定大小的内存块（称为缓冲区或块，blocks）组成一个链表，形成一个分段的连续空间。每个块大小固定，块之间由指针连接。这种设计允许双端队列在两端进行高效的插入和删除操作。

  - 特性：
    - 快速的两端插入和删除：与`vector`相比，`deque`在两端插入和删除时不需要移动大量元素，因为它使用了分段内存。
    - 随机访问：尽管数据分布在多个块中，`deque`依然支持常数时间的随机访问操作，通过索引可以像访问数组一样访问元素。
    - 动态增长： `deque`可以在两端动态增长，而不会像`vector`那样每次重新分配整个内存块。它只需要分配新块并连接到链表中。

- **`deque`的内部实现：**

  - 块链表
    - `deque`的内部并不是像`vector`一样使用连续的内存空间，而是将数据分配到多个固定大小的块中。`deque`维护一个指向这些块的指针数组，称为“块指针数组”或“块图”（block map）。这个数组用于定位每个块的位置，块图中的每个元素指向一个内存块，块的大小通常是常数，例如 512 个元素。
  - 中央控制指针
    - `deque`有两个控制指针：`start`和`finish`，分别指向双端队列的第一个元素和最后一个元素的位置。每个控制指针不仅包含指向块的指针，还包含在块内的偏移量。通过这两个指针，`deque`可以在常数时间内访问两端的数据。
  - 双端扩展
    - `deque`的扩展操作非常高效，因为当需要在两端插入新元素时，它只需要为新元素分配一个新的块，并将这个块插入到块链表的两端即可。而不像`vector`那样需要重新分配整个数组。具体操作如下：
      - 在前端插入元素时：如果前端没有足够空间，`deque`会分配一个新的块，并将其连接到块链表的前面。
      - 在后端插入元素时：如果后端没有足够空间，`deque`会分配一个新的块，并将其连接到块链表的后面。
  - 随机访问
    - 由于`deque`维护了一个块指针数组，可以通过常数时间内计算出某个元素位于哪个块，并在块内进行偏移操作。因此，随机访问操作的时间复杂度是常数 `O(1)`。
    - 具体过程如下：
      - 对于给定的索引 `i`，`deque` 首先通过块大小计算出该元素位于哪个块，接着通过块内偏移量找到具体的元素。
  - 插入和删除的实现
    - 插入： 在`deque`的任意位置插入元素时，首先确定插入位置。如果是在两端插入，直接在对应块链表的两端进行插入。如果是在中间位置插入，则需要移动部分元素到新块中，但由于块大小固定，因此只需要移动部分数据，操作效率较高。
    - 删除：与插入类似，删除操作也非常高效。对于前端和后端的删除，只需移动控制指针；对于中间删除，移动操作也比较局部化。



## 3、C++中`map`和`unordered_map`的区别？分别在什么场景下使用？

在C++中，`map`和`unordered_map`都是用于**存储键值对**的**关联式容器**，但它们在内部实现、性能和使用场景上有显著的区别。

- 内部实现

  - `map`：基于**红黑树**（一种平衡二叉搜索树），所有的元素按键值有序排列。
  - `unordered_map`：基于**哈希表**，元素的存储顺序与插入顺序无关，元素根据键的哈希值存储在桶（bucket）中。

- 时间复杂度

  - `map`：由于基于**红黑树**，插入、删除、查找操作的时间复杂度为 **O(log n)**，其中 `n` 是键值对的数量。红黑树通过保持平衡来确保这些操作的对数时间复杂度。
  - `unordered_map`：基于**哈希表**，平均情况下插入、删除、查找操作的时间复杂度为 **O(1)**，但在最坏情况下（哈希冲突严重时），复杂度可能退化为 **O(n)**。

- 元素的有序性

  - `map`：键值对按照键的大小顺序排列，支持按顺序遍历。如果你需要以升序或降序对键进行迭代，`map`是更合适的选择。
  - `unordered_map`：键值对是无序存储的，无法保证遍历顺序。如果顺序不重要或者无关，`unordered_map`提供更快的操作性能。

- 内存占用

  - `map`：由于需要维护红黑树的平衡，`map`的内存开销相对较高，特别是在频繁插入和删除操作时，红黑树需要额外的指针和树结构。
  - `unordered_map`：哈希表需要为每个桶分配空间，同时还要为处理哈希冲突的链表（或其他结构）分配内存。因此，`unordered_map`的内存使用可能比`map`更高，特别是在哈希冲突严重时。

- 哈希函数

  - `unordered_map`：`unordered_map` 依赖于**哈希函数**来计算键的哈希值，并将其存储在对应的桶中。标准库中提供了默认的哈希函数（如对整数、字符串等类型），但如果使用自定义的复杂类型作为键，则需要提供合适的哈希函数。

- 查找性能

  - `map`：在小规模数据的情况下，由于树结构的平衡，查找性能较好，但随着数据量增大，性能会受到影响
  - `unordered_map`：在键值对数量较大且哈希函数设计合理时，哈希表的查找性能通常优于`map`，因为平均查找时间复杂度为O(1)。但最坏情况下，哈希冲突过多时，性能可能下降。

- 使用场景

  - `map`

    - 需要按顺序存储数据：如果需要按键值的升序或降序进行遍历（例如二分搜索、范围查询），`map` 是合适的选择。

    - 需要频繁使用有序集合的场景：如当你需要在已排序的情况下查找、插入、删除键值对，`map` 是理想选择。

    - ```c++
      std::map<int, std::string> m;
      m[3] = "apple";
      m[1] = "banana";
      m[2] = "cherry";
      // 按键的升序输出
      for (const auto &pair : m) {
          std::cout << pair.first << ": " << pair.second << std::endl;
      }
      ```

  - `unordered_map`

    - 不需要顺序：如果对键值对的顺序没有要求，只需要高效的插入、删除、查找，`unordered_map` 是更高效的选择。

    - 查找频繁：当你需要频繁进行查找操作，并且希望性能接近 O(1)，`unordered_map` 更适合。

    - ```c++
      std::unordered_map<int, std::string> um;
      um[3] = "apple";
      um[1] = "banana";
      um[2] = "cherry";
      // 无序输出
      for (const auto &pair : um) {
          std::cout << pair.first << ": " << pair.second << std::endl;
      }
      ```



## 4、C++中`list`的原理？它在什么场景下使用？

在C++中`list`是一个双向链表（double linked list），其背后的原理是每个结点包含一个数据与和两个指针，分别指向前一个结点和后一个结点。`std::list`是C++标准库容器之一，主要特点是高效插入和删除操作。

- **原理**
  - 结点结构：每个结点包含：
    - 数据：存储实际的值。
    - 前向指针：指向前一个结点。
    - 后向指针：指向后一个结点。
  - 双向链表：
    - 链表的每个结点都有两个指针，一个指向前一个节点，一个指向后一个节点。这样可以从任意一个节点开始，向前或向后遍历整个链表。
  - 动态内存分配：
    - `std::list` 中的结点通常是在**堆上动态分配**的，这意味着它的大小不需要提前知道，可以根据需求动态增长或缩减。
  - 插入与删除：
    - 由于链表的结点是通过指针相互连接的，因此在链表中插入或删除元素只需要修改相邻节点的指针，而不需要像数组那样移动大量元素，所以插入和删除操作的时间复杂度为`O(1)`，只需要调整相关指针。
  - 遍历：
    - 尽管链表中的元素是顺序存储的，但它们在内存中的位置是不连续的，因此不能像数组那样通过下标快速访问元素，访问某个特定位置的元素需要从链表的一端开始遍历，时间复杂度为`O(n)`。
- **使用场景**
  - 频繁插入和删除操作：
    - 当你需要频繁在容器中间插入或删除元素时，`std::list` 是非常适合的选择。例如，**管理任务队列**、**处理实时事件**等场景，`std::list` 能提供比 `std::vector` 更快的插入与删除操作。
  - 需要双向遍历：
    - 如果需要在容器中既向前也向后遍历元素，双向链表的结构非常适合，因为它的每个节点都有前后两个指针。
  - 大数据量场景：
    - `std::list` 在数据量较大的场景下适合那些需要高效的插入和删除，但并不关心随机访问性能的场景。
- **不适用的场景**
  - 频繁的随机访问：
    - 由于链表不支持下标访问，随机访问性能很差，时间复杂度是 `O(n)`，不适用于需要频繁随机访问的场景，比如查找特定位置的元素。
  - 空间开销大：
    - 每个节点除了存储数据，还需要存储前后两个指针，因此与 `std::vector` 等相比，链表的内存开销更大。



## 5、C++中为什么要使用`std::array`？它有什么优点？

在 C++ 中，`std::array` 是一个**固定大小的数组**类型，定义在 `<array>` 头文件中。与传统的 C 风格数组相比，`std::array` 提供了许多额外的功能和安全性，主要是结合了数组的简单结构和标准容器的优点。

- **使用`std::array`的原因：**
  - 类型安全：
    - 与 C 风格数组相比，`std::array` 提供了更好的类型安全性。C 风格数组没有大小的内置信息，而 `std::array` 会将数组的大小作为模板参数的一部分，因此可以在编译期进行检查，防止越界访问等常见错误。
  - STL容器的功能支持：
    - `std::array` 是 C++ 标准库中的一个容器，它可以与其他标准库容器（如 `std::vector`、`std::deque` 等）一样，支持 STL 中的许多算法和函数，如 `std::sort`、`std::find`，让数组的使用更加灵活。
  - 固定大小：
    - `std::array` 是一个**定长数组**，大小在**编译时确定**，因此不会像 `std::vector` 那样在运行时动态分配内存，这使得它在某些性能关键的场合中更高效。
  - 与STL兼容：
    - `std::array` 完全兼容 STL（标准模板库）的其他容器和算法，它可以与迭代器一起使用，支持范围循环（range-based for loop），而且可以像其他 STL 容器一样通过 `begin()` 和 `end()` 获取迭代器。
  - 支持赋值和比较操作：
    - C 风格数组不支持直接赋值或比较，但 `std::array` 允许通过重载的赋值运算符和比较运算符进行数组的拷贝、比较等操作。例如，你可以直接比较两个 `std::array` 是否相等。
  - 提供边界检查：
    - `std::array` 提供了一个 `at()` 成员函数，该函数在访问元素时会进行边界检查，防止越界访问。虽然直接使用 `operator[]` 依然不会进行边界检查，但 `at()` 能在运行时捕获越界访问并抛出异常（`std::out_of_range`）。
  - 更好的接口和API：`std::array` 提供了更丰富的接口，比如：
    - `size()`：返回数组的大小，避免使用 `sizeof` 计算大小时出错。
    - `fill(value)`：可以用一个值填充整个数组。
    - 支持 tuple-like 解构：可以使用 `std::get(array)` 获取特定位置的元素。
- **std::array的优点**
  - 堆栈分配，开销小：
    - `std::array` 是在**栈**上分配的固定大小数组，不涉及动态内存分配，因此分配和释放的开销非常小，适合在性能要求较高的场景中使用。
  - 编译器大小确定：
    - 由于 `std::array` 的大小在编译期就已经确定，所以没有运行时的内存分配和调整。这在对性能有严格要求的场景中表现更好，如嵌入式系统或实时系统。
  - 继承STL容器功能：
    - 与 C 风格数组相比，`std::array` 结合了 STL 容器的功能，具备丰富的操作接口，可以轻松进行赋值、遍历、排序等操作。
  - 与现代C++风格一致：
    - `std::array` 更符合现代 C++ 的设计理念，类型安全、界限检查、与标准库兼容，能提高代码的可读性和安全性。
- **使用场景**
  - 定长数据：
    - 适合在数组大小固定不变的场景中使用，如处理固定长度的数据块。
  - 高性能需求：
    - 由于没有动态分配内存的开销，`std::array`在一些性能关键的代码中非常有用，尤其是在嵌入式系统中。
  - 希望与STL算法结合使用：
    - 可以方便地与其他 STL 容器一起使用，并与 STL 算法（如 `std::sort`）兼容。



## 6、C++中`vector`的push_back和emplace_back有什么区别？

在 C++ 中，`std::vector` 是一个动态数组容器，其中有两种常用的方法用于向容器末尾添加元素：`push_back()` 和 `emplace_back()`。它们的主要区别在于处理对象的方式上，尤其是在对象构造时的效率上。

- **`push_back()`**

  - 原理：

    - `push_back()`用于将一个已有的对象拷贝或移动到std::vector的末尾。

  - 参数：

    - 它接受一个对象的值或一个已存在的对象，并将这个对象添加到 `vector` 中。

  - 过程：

    - 如果传递的是一个右值对象，调用移动构造函数，将该对象移动到 `vector` 的末尾。
    - 如果传递的是一个左值对象，调用拷贝构造函数，将该对象拷贝到 `vector` 的末尾。

  - 使用场景：

    - 当你已经有一个现成的对象，并且希望将其添加到 `vector` 中时使用。

  - ```c++
    std::vector<std::string> vec;
    std::string s = "example";
    vec.push_back(s);       // 通过拷贝，将 s 的副本添加到 vec 中
    vec.push_back("test");  // 通过移动构造，将临时字符串移动到 vec 中
    ```

- **`emplace_back()`**

  - 原理：

    - `emplace_back()` 是 C++11 引入的方法，允许你**直接在容器末尾原地构造对象**。与 `push_back()` 不同，它**不会先创建一个临时对象再拷贝或移动**，而是直接使用传入的参数调用目标类型的构造函数。

  - 参数：

    - `emplace_back()` 接受构造对象所需的参数，能够通过这些参数直接在容器内构造对象，而无需创建临时对象。

  - 过程：

    - 它会直接传递构造函数的参数，调用目标类型的构造函数，直接在 `vector` 的末尾创建对象，而不涉及拷贝或移动。
    - 适用于需要高效地直接构造对象的场景。

  - 使用场景：

    - 当你需要在 `vector` 中直接构造对象，尤其是避免临时对象的创建和拷贝时，`emplace_back()` 更高效。

  - ```c++
    std::vector<std::string> vec;
    vec.emplace_back(10, 'a');  // 直接构造一个包含 10 个 'a' 的字符串 "aaaaaaaaaa"
    ```

- **区别总结**

  - 临时对象的创建：
    - `push_back()`：可能会创建一个临时对象，然后再拷贝或移动到 `vector` 中。
    - `emplace_back()`：避免创建临时对象，直接原地构造对象，效率更高。
      - 需要避免不必要的对象拷贝或移动的场景，尤其是在处理复杂对象时（如涉及动态内存分配、文件句柄等）。
      - 你希望通过传递构造函数参数，直接在 `vector` 中原地构造对象，以提高效率。
  - 构造对象的方式：
    - `push_back()`：接受现有的对象，调用拷贝构造函数或移动构造函数。
    - `emplace_back()`：接受构造对象所需的参数，直接在容器内构造对象。
  - 性能：
    - 如果使用`push_back()`，在需要拷贝或移动大对象时，可能会有性能开销。
    - `emplace_back()`可以避免这种开销，因为它不会创建临时对象，也不会调用拷贝构造函数或移动构造函数。

- **使用场景对比**

  - `push_back()` 适用于：
    - 你已经有了一个现成的对象，并且只需要将它添加到 `vector` 中。
    - 当对象的构造较为简单，且不涉及复杂的资源管理时。
  - `emplace_back()`适用于：
    - 需要避免不必要的对象拷贝或移动的场景，尤其是在处理复杂对象时（如涉及动态内存分配、文件句柄等）。
    - 你希望通过传递构造函数参数，直接在 `vector` 中原地构造对象，以提高效率。

- **例子对比**

  - `push_back()` 使用现有对象：

    ```c++
    std::vector<std::pair<int, std::string>> vec;
    std::pair<int, std::string> p(1, "example");
    vec.push_back(p);  // 需要拷贝 p
    ```

  - `emplace_back()` 原地构造对象：

    ```c++
    std::vector<std::pair<int, std::string>> vec;
    vec.emplace_back(1, "example");  // 直接原地构造，不需要临时对象或拷贝
    ```



## 7、C++中迭代器和指针有什么区别？

在 C++ 中，**迭代器（iterator）** 和 **指针（pointer）** 都可以用于**访问容器中的元素**，但它们有着本质上的区别。

- **概念区别**

  - 指针：
    - 指针是**内存地址的直接表示**。它是一个低级的工具，允许程序直接操作内存位置。指针可以指向任何类型的对象、函数或内存地址，并可以进行简单的指针运算，如递增、递减。
  - 迭代器：
    - 迭代器是一个**抽象的对象**，用来遍历容器中的元素。它是标准的C++标准库容器的一部分，是STL中的重要概念。迭代器为容器提供了一种统一的访问机制，能够**隐藏容器底层的实现细节**（如链表、动态数组等）。

- **功能上的区别**

  - 指针：
    - 指针是一个内存地址，允许对数组、结构体、类等进行直接访问。
    - 可以指针进行算数操作，如`++`、`--`来遍历数组中的元素。
    - 没有任何容器特定的操作，不能直接用在STL容器上（如`std::list`、`std::vector`）
  - 迭代器：
    - 迭代器是一种抽象工具，提供了一组特定的操作，用于遍历容器的元素。
    - 每种容器都有它自己类型的迭代器（如`std::vector::iterator`，`std::list::iterator`等），不同的容器可能有不同的迭代器类型。
    - 迭代器不仅可以像指针一样访问元素，还可以提供与容器类型相关的其他功能，如向前或向后遍历、随机访问、元素插入和删除。

- **与容器的关系**

  - 指针：
    - 仅适用于**连续存储**的容器（如数组或 `std::vector`），因为它们的元素在内存中是紧密排列的。指针可以通过简单的偏移计算来访问数组的元素。
  - 迭代器：
    - 适用于所有 STL 容器，无论其内部存储是连续的还是不连续的。链表（`std::list`）等非连续存储的容器也有自己的迭代器类型。**迭代器隐藏了底层存储细节，提供了一致的接口来访问容器的元素。**

- **灵活性**

  - 指针：
    - 是通用的，但比较基础，它可以直接操作内存地址，提供了很大的灵活性，但**容易导致内存错误**（如指针越界、悬空指针等）。同时，指针不具备和容器结构相关的特定功能。
  - 迭代器：
    - 提供了更高层次的抽象，能适应不同容器的结构。迭代器可以确保在容器内的有效访问，不同类型的迭代器支持不同的操作：
      - **输入迭代器：**只能读取一次数据（如输入流迭代器）。
      - **输出迭代器：**只能向容器中写入数据（如输出流迭代器）。
      - **前向迭代器：**可以从头到尾一次性遍历容器元素。
      - **双向迭代器：**可以向前或向后遍历（如`std::list`）。
      - **随机访问迭代器：**支持随机访问容器中的任意元素（如std::vector的迭代器）。

- **使用方便性**

  - 指针：
    - 指针需要开发者**手动管理**访问和内存，容易出现错误，如越界访问、指针悬挂等问题。
    - 使用指针遍历数组较为高效，但在非连续内存的数据结构中使用不方便。
  - 迭代器：
    - 迭代器提供了更高的安全性，能够确保遍历操作的正确性。
    - 迭代器与标准算法兼容（如 `std::sort`、`std::find` 等），大大提高了代码的可读性和通用性。
    - 不同容器类型的迭代器具有一致的接口，但在底层实现中可以表现出最佳的性能。

- **与STL的兼容性**

  - 指针：
    - 可以看作是指向数组的简单迭代器。某些容器（如 `std::vector` 和 C 风格数组）的迭代器实际上就是指针，但大多数 STL 容器的迭代器不是指针。
  - 迭代器：
    - 完全兼容 C++ 标准库中的算法，可以与 `std::vector`、`std::list`、`std::map` 等所有标准容器一起使用。这种抽象使得代码更加灵活，适用于不同的容器。

- **性能差异**

  - 指针：
    - 由于指针是直接操作内存的，因此它的性能通常会比迭代器稍快一些。但是这种微小的性能差异往往可以忽略不计，因为现代编译器能够对迭代器进行优化，使得迭代器的使用和指针一样高效。
  - 迭代器：
    - 虽然迭代器提供了更高的抽象层，但在大多数情况下性能开销是非常小的，尤其是在随机访问迭代器的情况下（如 `std::vector` 的迭代器）。对于链表等需要更多逻辑的容器，迭代器可以有效地隐藏复杂性。

- **总结**

  |    特性    |             指针（Pointer）             |                迭代器（Iterator）                 |
  | :--------: | :-------------------------------------: | :-----------------------------------------------: |
  |    概念    |         内存地址，直接操作内存          |         抽象对象，提供统一接口来遍历容器          |
  |  适用范围  | 适用于连续内存（如数组、`std::vector`） | 适用于所有 STL 容器（如 `std::list`、`std::map`） |
  |    功能    |   直接指向对象，可以进行指针算术操作    |      提供统一的遍历容器的接口，支持 STL 算法      |
  | 与容器关系 |  仅适用于数组和其他连续存储类型的容器   |                适用于所有 STL 容器                |
  |  兼容 STL  |       只能对数组使用部分 STL 算法       |             与所有 STL 算法和容器兼容             |
  |    性能    |         直接访问内存，速度稍快          |    提供抽象，性能稍微有些开销，但通常可以忽略     |
  |   灵活性   |       低级，操作灵活，但容易出错        |         更高级的抽象，安全性和灵活性更好          |



















# 六、C++并发

## 1、lock_guard和unique_lock的区别？

| 项目         | `lock_guard`     | `unique_lock`                            |
| ------------ | ---------------- | ---------------------------------------- |
| 功能         | 简单的作用域锁   | 功能更强的可控锁                         |
| 解锁方式     | 自动解锁（RAII） | 自动解锁，但也可以手动解锁               |
| 支持延迟锁   | ❌                | ✅（通过 `defer_lock`）                   |
| 支持锁的转移 | ❌                | ✅（支持移动构造）                        |
| 支持条件变量 | ❌                | ✅（配合 `std::condition_variable` 使用） |
| 适用场景     | 简单加锁解锁     | 需要灵活控制锁的生命周期或配合条件变量   |



## 2、thread的join和detach的区别？

| 项目     | `join()`                 | `detach()`                           |
| -------- | ------------------------ | ------------------------------------ |
| 含义     | 等待线程执行完毕（阻塞） | 脱离主线程，后台运行                 |
| 线程关系 | 主线程会等待子线程       | 子线程独立运行，不再受主线程管理     |
| 后果     | 安全收尾                 | 程序结束前线程未结束会导致未定义行为 |
| 使用场景 | 需要线程返回结果或同步   | 不关心线程结果、类似“火并忘”         |



## 3、jthread和thread的区别？

| 项目        | `std::thread` | `std::jthread`                     |
| ----------- | ------------- | ---------------------------------- |
| 自动 `join` | ❌（需手动）   | ✅（析构时自动 join）               |
| 支持中断    | ❌             | ✅（通过 `stop_token`）             |
| 更安全      | ❌             | ✅                                  |
| 推荐场景    | C++17 及以下  | C++20 及以上使用优先推荐 `jthread` |



## 4、future、promise、packaged_task、async的区别？

| 组件                 | 作用                            | 配套使用                       |
| -------------------- | ------------------------------- | ------------------------------ |
| `std::promise`       | 提供数据                        | `future` 获取结果              |
| `std::future`        | 获取异步结果                    | 与 `promise` 或 `async` 等配合 |
| `std::packaged_task` | 将函数包装成异步任务            | 创建 `future`                  |
| `std::async`         | 自动创建异步任务并返回 `future` | 最简单的异步机制               |



## 5、async在使用时有哪些注意事项？

- 调用策略
  - `std::launch::async`：新线程执行
  - `std::launch::deferred`：延迟执行（调用 `get()` 时才执行）
  - 默认：系统决定是否异步执行
- 阻塞行为
  - 调用 `future.get()` 会阻塞等待结果
- 异常传播
  - `async` 中的异常会通过 `future.get()` 抛出
- 不能忽略`future`
  - 如果不调用 `.get()` 或 `.wait()`，线程异常或资源泄露可能发生



## 6、如何理解C++中的atomic？

`std::atomic` 是 **无锁的、线程安全的原子操作封装**，可用于替代锁进行数据共享。

特点：

- 保证对变量的读写操作是**不可中断的原子操作**
- 避免竞争条件
- 通常效率高于锁
- 提供了原子操作函数，如 `load()`、`store()`、`fetch_add()`、`compare_exchange_weak/strong()`



## 7、什么场景下使用锁？什么场景下使用原子变量？

| 场景                       | 使用锁(`mutex`) | 使用原子变量(`std::atomic`) |
| -------------------------- | --------------- | --------------------------- |
| 操作复杂、涉及多个共享变量 | ✅               | ❌（可能出现竞争）           |
| 需要同步多个线程/等待条件  | ✅(配合条件变量) | ❌                           |
| 简单计数器/标志位更新      | ❌（太重）       | ✅                           |
| 可接受一定性能损耗换安全性 | ✅               | ✅                           |
| 性能要求极高、操作简单     | ❌               | ✅                           |



## 8、锁的底层原理是什么？

## 9、介绍C++的6中内存序



# 七、设计模式

## 1、什么是设计模式？请简述其作用。

**设计模式**（Design Patterns）是软件开发中总结出的解决常见设计问题的可重用解决方案。它们是经过验证的设计结构，用来提高软件的灵活性、可维护性和可重用性。设计模式并不是具体的代码，而是编程中的**最佳实践**和**模板**，可以应用于不同的开发场景。

- **设计模式的作用**

  - 解决常见问题
    - 设计模式为常见的开发问题提供了解决方案，减少了开发者自行探索问题的时间和精力。
  - 提高代码可重用性
    - 通过使用设计模式，开发者可以创建模块化、解耦的代码，这样代码可以在不同项目中重用。
  - 增强代码的可维护性
    - 设计模式有助于创建清晰、结构化的代码，使代码更易于理解和维护。
  - 促进团队协作
    - 设计模式提供了统一的解决方案，帮助开发团队使用一致的设计方案，方便沟通和协作。
  - 提高代码的灵活性和扩展性
    - 设计模式使代码更容易扩展，能够适应变化的需求，而不需要对现有代码进行大量修改。
  - 遵行面向对象设计原则
    - 大部分设计模式基于面向对象编程原则，例如封装、继承和多态性，它们帮助开发者构建灵活且可扩展的系统。

- **常见的设计模式分类**

  - 创建型模式

    处理对象的创建过程，确保对象的创建方式合适并且可扩展。

    - **工厂方法模式（Factory Method Pattern）**
      - 定义一个创建对象的接口，由子类决定实例化哪一个类。
    - 抽象工厂模式（Abstract Factory Pattern）
      - 提供一个接口，创建一系列相关或依赖的对象，而无需指定具体的类。
    - **单例模式（Singleton Pattern）**
      - 确保一个类只有一个实例，并提供一个全局访问点。
    - **建造者模式（Builder Pattern）**
      - 将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
    - 原型模式（Prototype Pattern）
      - 通过复制现有对象创建新对象，而不是通过类实例化创建对象。

  - 结构性模式

    关注对象和类之间的组合，确保不同部分可以协作。

    - **适配器模式（Adapter Pattern）**
      - 将一个类的接口转换成客户端希望的另一个接口，使得原本不兼容的类可以一起工作。
    - 桥接模式（Bridge Pattern）
      - 将抽象部分与它的实现部分分离，使它们都可以独立地变化。
    - 组合模式（Composite Pattern）
      - 将对象组合成树形结构以表示“部分-整体”层次结构，使得客户端对单个对象和组合对象的使用具有一致性。
    - **装饰器模式（Decorator Pattern）**
      - 动态地给对象添加新的职责，通过对象组合而非继承来扩展功能。
    - **代理模式（Proxy Pattern）**
      - 为其他对象提供一个代理，以控制对这个对象的访问。
    - 外观模式
      - 为复杂的子系统提供一个统一的接口，简化客户端与子系统的交互。
    - 享元模式
      - 通过共享尽可能多的相似对象，减少内存的消耗。

  - 行为型模式

    涉及对象之间的交互，处理类与对象之间的职责分配。

    - **观察者模式（Observer Pattern）**
      - 定义对象间的一对多依赖，当一个对象状态发生改变时，所有依赖它的对象都会得到通知并自动更新。
    - **策略模式（Strategy Pattern）**
      - 定义一系列算法，将每个算法封装起来，并使它们可以互换。
    - **命令模式（Command Pattern）**
      - 将请求封装成对象，从而可以用不同的请求对客户进行参数化，并支持请求的排队、记录和撤销操作。
    - **责任链模式（Chain of Responsibility）**
      - 将请求沿着处理链传递，直到有对象处理它。
    - 解释器模式（Interpreter Pattern）
      - 为语言创建解释器，定义语言的语法，并解释表达式
    - 迭代器模式（Iterator Pattern）
      - 提供一种方法顺序访问集合对象中的各个元素，而不暴露其内部表示。
    - 中介者模式（Mediator Pattern）
      - 定义一个中介对象来封装对象间的交互，使得对象不需要直接引用彼此，从而降低耦合度。
    - 备忘录模式（Memento Pattern）
      - 在不破坏封装的前提下，捕获对象的内部状态，以便以后恢复。
    - 状态模式（State Pattern）
      - 允许对象在内部状态改变时改变它的行为，状态改变时看起来像是更改了对象的类。
    - 模板方法模式（Strategy Pattern）
      - 在一个方法中定义一个算法的骨架，将一些步骤的实现延迟到子类中。
    - 访问者模式（Visitor Pattern）
      - 为对象结构中的元素添加新的操作，而不改变对象结构。



## 2、设计模式的原则有哪些？

设计模式的原则是指导开发人员编写可维护、可扩展、可重用代码的基本原则。以下是常见的面向对象设计的**六大设计原则**

- **单一职责原则（SRP: Single Responsibility Principle）**
  - 定义
    - 每个类应该只有一个单一的职责，且该职责应该完全由类负责。换句话说，一个类应该只有一个引起它变化的原因。
  - 目的
    - 将不同的功能拆分到不同的类中，使类的职责更加明确，代码更容易维护。
  - 好处
    - 降低类的复杂度，使类更简单且更易理解。
    - 提高代码的可读性、可维护性和可复用性。
    - 当需求变化时，只需修改相关类，不会影响其他不相关的功能。
- **开闭原则（OCP: Open/Closed Principle）**
  - 定义
    - 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。也就是说，系统应该通过扩展已有代码的方式进行功能增强，而不是通过修改已有代码。
  - 目的
    - 避免频繁修改已有代码，从而减少引入错误的可能性，同时增强系统的灵活性和可扩展性。
  - 好处
    - 提高系统的稳定性和可维护性。
    - 便于扩展和升级系统功能。
- **里氏替换原则（LSP: Liskov Substitution Principle）**
  - 定义
    - 子类对象可以替换父类对象，并且保证程序行为不变。也就是说，子类必须能够在任何期望使用父类对象的地方使用，且不影响程序的正确性。
  - 目的
    - 确保继承体系中的子类能够正确地扩展父类功能，而不破坏系统原有的行为。
  - 好处
    - 保证继承关系的正确性，防止类之间出现意外的耦合或依赖。
    - 提高代码的可替换性和复用性。
- **依赖倒置原则（DIP: Dependency Inversion Principle）**
  - 定义
    - 高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。
  - 目的
    - 通过依赖抽象接口，而不是具体实现，降低模块之间的耦合度，提升系统的可维护性和可扩展性。
  - 好处
    - 提高模块的独立性和灵活性。
    - 降低模块之间的耦合度，使得模块之间可以更容易地替换或扩展。
    - 便于单元测试和模块化开发。
- **接口隔离原则（ISP: Interface Segregation Principle）**
  - 定义
    - 客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。
  - 目的
    - 避免一个接口过于庞大，使得实现类必须实现不必要的方法。通过细分接口，每个接口只包含客户端真正需要的操作。
  - 好处
    - 接口精简化，避免类过度复杂化。
    - 提高代码的灵活性和可扩展性。
    - 当接口发生变化时，影响的范围更小。
- **迪米特法则（LoD: Law of Demeter）**
  - 定义
    - 一个对象应该对其他对象有尽可能少的了解，也称为“最少知道原则”。即一个类应该只与它直接的朋友通信，避免过多的依赖关系。
  - 目的
    - 减少类与类之间的耦合，降低系统的复杂度和变化的影响范围。
  - 好处
    - 降低系统的耦合性，增强系统的模块化。
    - 提高系统的可维护性和可扩展性。
- **设计模式的应用**
  - 单一职责原则：在**工厂模式**中，工厂类只负责对象的创建，产品类负责产品的逻辑处理。
  - 开闭原则：在**装饰者模式**和**策略模式**中，通过扩展类来增加功能，而不修改现有类。
  - 里氏替换原则：在继承结构中，如**模板方法模式**和**观察者模式**中，子类替代父类来实现多态。
  - 依赖倒置原则：在**依赖注入、工厂模式**中，通过抽象接口和类来解耦高层和低层组件。
  - 接口隔离原则：在**适配器模式**中，每个适配器只暴露它需要的接口。
  - 迪米特法则：在**外观模式**中，通过一个统一的接口与复杂的子系统交互，减少模块之间的依赖。



## 3、请解释什么是单例模式？并给出一个使用场景。

**单例模式**是一种创建型设计模式，它的主要目标是确保某个类在程序运行期间**仅有一个实例**，并且提供一个**全局的访问点**来访问该实例。

在单例模式中，类会控制自身的实例化过程，确保只有一个实例被创建。单例模式可以通过懒加载（Lazy Initialization）来实现，确保对象在真正需要时才会创建。

- **单例模式的核心要点**

  - 唯一类
    - 该类只会有一个实例存在，防止多次创建，节省资源。
  - 全局访问
    - 提供一个静态方法，允许程序的其他部分访问该唯一的实例。
  - 延迟初始化
    - 实例通常是在首次使用时才被创建，优化了资源的使用。

- **单例模式的典型实现**

  ```c++
  class Singleton {
  private:
      // 私有化构造函数，防止外部实例化
      Singleton() {}
  
      // 禁用拷贝构造和赋值运算，防止进行拷贝和赋值。
      Singleton(const Singleton&) = delete;
      Singleton& operator=(const Singleton&) = delete;
  
      // 静态指针，保存唯一实例
      static Singleton* instance;
  
  public:
      // 获取实例的静态方法
      static Singleton* getInstance() {
          if (instance == nullptr) {
              instance = new Singleton();
          }
          return instance;
      }
  
      // 示例方法
      void doSomething() {
          std::cout << "Doing something!" << std::endl;
      }
  };
  
  // 静态成员变量初始化
  Singleton* Singleton::instance = nullptr;
  
  int main() {
      // 通过 getInstance() 方法获取唯一实例
      Singleton* s = Singleton::getInstance();
      s->doSomething();
  
      return 0;
  }
  
  ```

- **关键点**

  - 构造函数时私有的，确保不能通过`new`运算符直接实例化对象。
  - `getInstance()`方法提供唯一实例的访问接口，如果实例不存在，会创建它。
  - 静态变量`instance`保证了实例的唯一性。

- **使用场景**

  - 日志记录系统

    在许多应用程序中，日志系统需要全局访问，并且确保只有一个日志文件或输出目标。通过单例模式，可以确保日志记录器是唯一的，避免多个实例之间的资源竞争。

    - 示例场景

      一个大型软件系统需要将不同模块的日志信息统一记录在同一个文件中。使用单例模式实现日志记录器，保证所有模块都共享同一个日志记录器实例，从而避免日志文件被多个实例打开或写入冲突。

    ```c++
    class Logger {
    private:
        static Logger* loggerInstance;
        Logger() {}  // 私有化构造函数
    
    public:
        static Logger* getInstance() {
            if (loggerInstance == nullptr) {
                loggerInstance = new Logger();
            }
            return loggerInstance;
        }
    
        void log(const std::string& message) {
            std::cout << "Log: " << message << std::endl;
        }
    };
    
    int main() {
        Logger* logger = Logger::getInstance();
        logger->log("This is a log message.");
        return 0;
    }
    ```
    

在这个场景中，无论系统中有多少个模块调用 `Logger`，它们都会使用同一个实例来写入日志，确保了统一的日志管理。



## 4、单例模式有哪几种实现？如何保证线程安全？

单例模式在 C++ 中有多种实现方式，不同的实现方式会对线程安全进行不同的处理。

- **懒汉模式**

  **懒汉模式**是在第一次使用时才创建实例，但它的基本实现**不保证线程安全**。为保证线程安全，需要加锁。

  线程安全懒汉模式（使用互斥锁）：

  ```c++
  #include <iostream>
  #include <mutex>
  
  class Singleton {
  private:
      static Singleton* instance;
      static std::mutex mutex_;
  
      // 私有化构造函数，防止外部实例化
      Singleton() {}
  
  public:
      // 获取唯一实例的静态方法
      static Singleton* getInstance() {
          std::lock_guard<std::mutex> lock(mutex_);
          if (instance == nullptr) {
              instance = new Singleton();
          }
          return instance;
      }
  
      void doSomething() {
          std::cout << "Doing something in Lazy Singleton!" << std::endl;
      }
  };
  
  // 初始化静态成员
  Singleton* Singleton::instance = nullptr;
  std::mutex Singleton::mutex_;
  
  int main() {
      Singleton* s1 = Singleton::getInstance();
      s1->doSomething();
      return 0;
  }
  ```

- **饿汉模式**

  **饿汉模式**在类加载时即创建单例实例，而不是在第一次使用时创建。这种模式确保了实例在程序启动时即被创建，通常适用于实例创建开销较小且程序启动时可以接受的场景。

  ```c++
  #include <iostream>
  
  class Singleton {
  private:
      // 静态成员变量，类加载时初始化
      static Singleton instance;
  
      // 私有化构造函数，防止外部实例化
      Singleton() {}
  
  public:
      // 获取唯一实例的静态方法
      static Singleton& getInstance() {
          return instance;
      }
  
      void doSomething() {
          std::cout << "Doing something in Eager Singleton!" << std::endl;
      }
  
  private:
      // 禁用拷贝构造函数和赋值运算符
      Singleton(const Singleton&) = delete;
      Singleton& operator=(const Singleton&) = delete;
  };
  
  // 初始化静态成员
  Singleton Singleton::instance;
  
  int main() {
      Singleton& s1 = Singleton::getInstance();
      s1.doSomething();
      return 0;
  }
  ```

  

- **双重检查锁定**

  **双重检查锁定**是懒汉模式的优化，减少了加锁的开销。它结合了懒汉模式和锁机制，通过两次检查 `instance` 指针来减少锁操作。

  线程安全的双重检查锁定：

  ```c++
  #include <iostream>
  #include <mutex>
  
  class Singleton {
  private:
      static Singleton* instance;
      static std::mutex mutex_;
  
      // 私有化构造函数，防止外部实例化
      Singleton() {}
  
  public:
      // 获取唯一实例的静态方法
      static Singleton* getInstance() {
          if (instance == nullptr) {
              std::lock_guard<std::mutex> lock(mutex_);
              if (instance == nullptr) {
                  instance = new Singleton();
              }
          }
          return instance;
      }
  
      void doSomething() {
          std::cout << "Doing something in Double-Checked Locking Singleton!" << std::endl;
      }
  };
  
  // 初始化静态成员
  Singleton* Singleton::instance = nullptr;
  std::mutex Singleton::mutex_;
  
  int main() {
      Singleton* s1 = Singleton::getInstance();
      s1->doSomething();
      return 0;
  }
  ```

- **静态内部类**

  **静态内部类**利用静态内部类的特性，在类加载时创建单例实例，线程安全且延迟加载。

  线程安全的静态内部类：

  ```c++
  #include <iostream>
  
  class Singleton {
  private:
      // 私有化构造函数，防止外部实例化
      Singleton() {}
  
  public:
      // 获取唯一实例的静态方法
      static Singleton* getInstance() {
          return SingletonHolder::instance;
      }
  
      void doSomething() {
          std::cout << "Doing something in Static Inner Class Singleton!" << std::endl;
      }
  
  private:
      class SingletonHolder {
      public:
          static Singleton instance;  // 静态成员变量，保证只创建一次
      };
  };
  
  // 初始化静态成员
  Singleton Singleton::SingletonHolder::instance;
  
  int main() {
      Singleton* s1 = Singleton::getInstance();
      s1->doSomething();
      return 0;
  }
  ```

- **局部静态变量**

  **局部静态变量**利用 C++11 的局部静态变量特性，保证线程安全，并且只在第一次调用时初始化。

  线程安全的局部静态变量：

  ```c++
  #include <iostream>
  
  class Singleton {
  public:
      // 获取唯一实例的静态方法
      static Singleton& getInstance() {
          static Singleton instance;  // 局部静态变量，线程安全
          return instance;
      }
  
      void doSomething() {
          std::cout << "Doing something in Meyers' Singleton!" << std::endl;
      }
  
  private:
      // 私有化构造函数，防止外部实例化
      Singleton() {}
  
      // 禁用拷贝构造函数和赋值运算符
      Singleton(const Singleton&) = delete;
      Singleton& operator=(const Singleton&) = delete;
  };
  
  int main() {
      Singleton& s1 = Singleton::getInstance();
      s1.doSomething();
      return 0;
  }
  ```

- **使用std::call_once（C++11及以后）**

  **`std::call_once`** 是 C++11 中的功能，用于确保初始化操作只被执行一次，适用于单例模式的线程安全实现。

  线程安全的`std::call_once`：

  ```c++
  #include <iostream>
  #include <mutex>
  
  class Singleton {
  private:
      static Singleton* instance;
      static std::once_flag initFlag;
  
      // 私有化构造函数，防止外部实例化
      Singleton() {}
  
  public:
      // 获取唯一实例的静态方法
      static Singleton* getInstance() {
          std::call_once(initFlag, []() { instance = new Singleton(); });
          return instance;
      }
  
      void doSomething() {
          std::cout << "Doing something in Singleton with call_once!" << std::endl;
      }
  
  private:
      // 禁用拷贝构造函数和赋值运算符
      Singleton(const Singleton&) = delete;
      Singleton& operator=(const Singleton&) = delete;
  };
  
  // 初始化静态成员
  Singleton* Singleton::instance = nullptr;
  std::once_flag Singleton::initFlag;
  
  int main() {
      Singleton* s1 = Singleton::getInstance();
      s1->doSomething();
      return 0;
  }
  ```

- **枚举单例**

  **枚举单例**在 Java 中非常常见，但 C++ 也可以利用类似的方式实现。它利用枚举的特点，防止了**反序列化和反射**破坏单例的风险。

  ```c++
  #include <iostream>
  
  enum class SingletonEnum {
      INSTANCE;
      // 可以在枚举类中添加方法
      void doSomething() {
          std::cout << "Doing something in Enum Singleton!" << std::endl;
      }
  };
  
  int main() {
      SingletonEnum& s1 = SingletonEnum::INSTANCE;
      s1.doSomething();
      return 0;
  }
  ```




## 5、工厂模式和抽象工厂模式有什么区别？

**工厂模式（Factory Pattern）**和**抽象工厂模式（Abstract Factory Pattern）**都是创建型设计模式，它们主要用于对象的创建，但在复杂性和适用场景上有所不同。

- **目的与复杂度**

  - 工厂模式
    - 它旨在为一个具体的产品提供一个创建方法。你可以通过子类决定具体实例化的对象类型，适合于创建一类产品。例如，创建不同类型的汽车（电动车、燃油车），每个工厂只负责一种类型的汽车。
    - 使用场景
      - 当你需要根据不同条件创建某种特定对象时使用工厂模式。它可以减少客户端对具体类的依赖，只需关心工厂的接口。
  - 抽象工厂模式
    - 它用于提供一个创建“**相关**”或“**依赖**”对象的接口，而无需指定它们的具体类。抽象工厂模式是工厂模式的更高层次，适用于需要创建多个产品族（相关产品）时。例如，一个工厂可能会创建不同的家用电器（电视、冰箱、洗衣机），每个产品有不同的系列（如高端系列、普通系列），抽象工厂负责整个产品族的创建。
    - 使用场景
      - 当系统需要创建多个相互关联的对象，且不需要指定具体类时使用抽象工厂模式。它有利于扩展产品族，但产品类型的扩展较为困难。

- **产品与数量**

  - 工厂模式
    - 通常负责**创建单一产品或产品类型**。例如，只创建“电动车”或“燃油车”。
  - 抽象工厂模式
    - 负责**创建一系列相关的产品**。例如，创建一个包含“电动车”、“电动摩托车”、“电动自行车”的产品族。

- **结构**

  - 工厂模式

    - 只提供创建**单一类型产品**的工厂接口。

      ```c++
      #include <iostream>
      #include <memory>
      
      // 产品基类
      class Car {
      public:
          virtual void drive() const = 0;
          virtual ~Car() {}
      };
      
      // 具体产品 - 电动车
      class ElectricCar : public Car {
      public:
          void drive() const override {
              std::cout << "Driving an electric car!" << std::endl;
          }
      };
      
      // 具体产品 - 燃油车
      class GasolineCar : public Car {
      public:
          void drive() const override {
              std::cout << "Driving a gasoline car!" << std::endl;
          }
      };
      
      // 工厂基类
      class CarFactory {
      public:
          virtual std::unique_ptr<Car> createCar() const = 0;
          virtual ~CarFactory() {}
      };
      
      // 具体工厂 - 电动车工厂
      class ElectricCarFactory : public CarFactory {
      public:
          std::unique_ptr<Car> createCar() const override {
              return std::make_unique<ElectricCar>();
          }
      };
      
      // 具体工厂 - 燃油车工厂
      class GasolineCarFactory : public CarFactory {
      public:
          std::unique_ptr<Car> createCar() const override {
              return std::make_unique<GasolineCar>();
          }
      };
      
      int main() {
          std::unique_ptr<CarFactory> factory = std::make_unique<ElectricCarFactory>();
          std::unique_ptr<Car> car = factory->createCar();
          car->drive();  // 输出：Driving an electric car!
      
          factory = std::make_unique<GasolineCarFactory>();
          car = factory->createCar();
          car->drive();  // 输出：Driving a gasoline car!
      
          return 0;
      }
      ```

  - 抽象工厂模式

    - 提供创建**多个相关产品**的接口，客户端通过工厂的接口生成多个产品族的实例，而不需要关心具体产品的实现。

      ```c++
      #include <iostream>
      #include <memory>
      
      // 产品基类 - 汽车
      class Car {
      public:
          virtual void drive() const = 0;
          virtual ~Car() {}
      };
      
      // 产品基类 - 摩托车
      class Motorcycle {
      public:
          virtual void ride() const = 0;
          virtual ~Motorcycle() {}
      };
      
      // 具体产品 - 电动车
      class ElectricCar : public Car {
      public:
          void drive() const override {
              std::cout << "Driving an electric car!" << std::endl;
          }
      };
      
      // 具体产品 - 电动摩托车
      class ElectricMotorcycle : public Motorcycle {
      public:
          void ride() const override {
              std::cout << "Riding an electric motorcycle!" << std::endl;
          }
      };
      
      // 具体产品 - 燃油车
      class GasolineCar : public Car {
      public:
          void drive() const override {
              std::cout << "Driving a gasoline car!" << std::endl;
          }
      };
      
      // 具体产品 - 燃油摩托车
      class GasolineMotorcycle : public Motorcycle {
      public:
          void ride() const override {
              std::cout << "Riding a gasoline motorcycle!" << std::endl;
          }
      };
      
      // 抽象工厂基类
      class VehicleFactory {
      public:
          virtual std::unique_ptr<Car> createCar() const = 0;
          virtual std::unique_ptr<Motorcycle> createMotorcycle() const = 0;
          virtual ~VehicleFactory() {}
      };
      
      // 具体工厂 - 电动车辆工厂
      class ElectricVehicleFactory : public VehicleFactory {
      public:
          std::unique_ptr<Car> createCar() const override {
              return std::make_unique<ElectricCar>();
          }
          std::unique_ptr<Motorcycle> createMotorcycle() const override {
              return std::make_unique<ElectricMotorcycle>();
          }
      };
      
      // 具体工厂 - 燃油车辆工厂
      class GasolineVehicleFactory : public VehicleFactory {
      public:
          std::unique_ptr<Car> createCar() const override {
              return std::make_unique<GasolineCar>();
          }
          std::unique_ptr<Motorcycle> createMotorcycle() const override {
              return std::make_unique<GasolineMotorcycle>();
          }
      };
      
      int main() {
          std::unique_ptr<VehicleFactory> factory = std::make_unique<ElectricVehicleFactory>();
          std::unique_ptr<Car> car = factory->createCar();
          std::unique_ptr<Motorcycle> motorcycle = factory->createMotorcycle();
          car->drive();          // 输出：Driving an electric car!
          motorcycle->ride();    // 输出：Riding an electric motorcycle!
      
          factory = std::make_unique<GasolineVehicleFactory>();
          car = factory->createCar();
          motorcycle = factory->createMotorcycle();
          car->drive();          // 输出：Driving a gasoline car!
          motorcycle->ride();    // 输出：Riding a gasoline motorcycle!
      
          return 0;
      }
      ```

- **扩展性**

  - 工厂模式
    - 容易添加新的产品类型。只需添加新的工厂类或产品类即可。
  - 抽象工厂模式
    - 扩展产品族时很方便，但增加新的产品种类（比如增加卡车类型）则需要修改抽象工厂及所有具体工厂，扩展难度较大。



## 6、请描述简单工厂模式的工作原理？

**简单工厂模式**（Simple Factory Pattern）是一种用于对象创建的设计模式，它通过定义一个工厂类来根据传递的参数创建不同类型的对象。简单工厂模式通常不是一种正式的设计模式，但它常用来简化对象的创建过程。

- **工作原理**

  - 工厂类
    - 简单工厂模式中有一个专门的**工厂类（或方法）**，该类包含一个用于创建对象的静态方法。这个方法会根据传入的参数（如类型标识符）决定创建哪种具体的对象。
  - 产品类
    - 工厂创建的对象都属于一个父类（或接口），这个父类定义了所有具体产品类的共同方法。具体的产品类继承或实现这个父类，并提供具体的实现。
  - 客户端
    - 客户端只需向工厂类请求对象，不需要直接使用 `new` 关键字来创建对象。客户端不关心具体对象的实现，只需提供一些参数让工厂知道需要创建哪种产品。

- **工作流程**

  - 客户端调用工厂类的方法并传递必要的参数。
  - 工厂类内部根据参数判断创建哪种具体的产品。
  - 工厂类返回创建的对象，客户端就可以使用该对象执行相关操作。

- **优点**

  - 封装对象创建
    - 客户端不直接依赖具体产品类，而是依赖工厂，降低了耦合性。
  - 集中管理创建逻辑
    - 所有对象的创建都集中在工厂类中，便于统一管理和修改。

- **缺点**

  - 不符合开闭原则
    - 每次增加新类型的产品都需要修改工厂类，违反了对扩展开放、对修改封闭的设计原则。
  - 单一职责问题
    - 工厂类可能承担过多的职责，随着产品种类增多，工厂类变得臃肿。

- 代码示例

  简单工厂模式创建不同类型的产品对象：

  ```c++
  #include <iostream>
  #include <memory>
  
  // 产品基类
  class Car {
  public:
      virtual void drive() const = 0; // 纯虚函数，所有子类必须实现
      virtual ~Car() {}
  };
  
  // 具体产品 - 电动车
  class ElectricCar : public Car {
  public:
      void drive() const override {
          std::cout << "Driving an electric car!" << std::endl;
      }
  };
  
  // 具体产品 - 燃油车
  class GasolineCar : public Car {
  public:
      void drive() const override {
          std::cout << "Driving a gasoline car!" << std::endl;
      }
  };
  
  // 简单工厂类
  class CarFactory {
  public:
      // 静态方法根据不同的参数创建不同的产品
      static std::unique_ptr<Car> createCar(const std::string& type) {
          if (type == "electric") {
              return std::make_unique<ElectricCar>();
          } else if (type == "gasoline") {
              return std::make_unique<GasolineCar>();
          } else {
              return nullptr;
          }
      }
  };
  
  int main() {
      // 客户端通过简单工厂获取具体对象
      std::unique_ptr<Car> car = CarFactory::createCar("electric");
      if (car) {
          car->drive();  // 输出：Driving an electric car!
      }
  
      car = CarFactory::createCar("gasoline");
      if (car) {
          car->drive();  // 输出：Driving a gasoline car!
      }
  
      return 0;
  }
  ```

  在该示例中：

  - `Car`类：定义了一个汽车的基类，包含一个纯虚函数`drive()`。
  - 具体产品类（`ElectricCar`和`GasolineCar`）：分别实现了`Car`类和`drive()`方法。
  - `CarFactory`类：简单工厂类，它根据传入的字符串（类型标识符）创建具体的汽车对象。
  - 客户端：客户端通过调用`CarFactory::createCar()`方法，根据参数创建具体的产品，而不直接依赖于产品的具体实现。



## 7、什么是建造者模式？一般用在什么场景？

**建造者模式**（Builder Pattern）是一种**创建型设计模式**，它将一个复杂对象的构造与其表示分离，使得同样的构建过程可以创建不同的表示。该模式通过逐步构建对象的各个部分，并最终生成一个完整的对象。

- **核心思想**

  - 建造者模式的核心思想是**将复杂对象的构建过程分步进行，并允许用户根据需要逐步设置对象的每个部分，避免创建过程过于复杂或不灵活**。在建造者模式中，客户端只需要知道如何使用建造者对象，而不需要关心具体构建对象的细节。

- **组成部分**

  - 产品类（Product）
    - 表示最终要构建的复杂对象。通常，它包含多个组件或属性。
  - 建造者类（Builder）
    - 提供了创建对象不同部分的抽象接口。
  - 具体建造者类（ConcreteBuilder）
    - 实现 `Builder` 接口，负责创建产品的具体部分，并定义如何构建复杂对象。
  - 指挥者类（Director）
    - 负责控制构建过程。它按照特定顺序调用建造者的构建步骤，最终得到完整的对象。
  - 客户端（Client）
    - 客户端不直接创建产品，而是通过指挥者和建造者来创建复杂对象。

- **使用场景**

  - 创建过程复杂
    - 对象的构造过程包含多个步骤或多个组件，且创建过程涉及到复杂的逻辑。
  - 需要生成不同表示的对象
    - 通过相同的构建过程，可能需要生成不同类型或不同属性的对象。
  - 构建过程需要灵活控制
    - 用户希望能够灵活地选择性地构建对象的某些部分，而不是必须一次性构建全部属性。

- **示例代码**

  使用建造者模式创建一个复杂的`Computer`对象：

  ```c++
  #include <iostream>
  #include <string>
  #include <memory>
  
  using std::cout;
  using std::endl;
  using std::string;
  using std::unique_ptr;
  
  //产品类-电脑
  class Computer
  {
  public:
      void setCPU(const string& cpu)
      {
          CPU = cpu;
      }
  
      void setGPU(const string& gpu)
      {
          GPU = gpu;
      }
  
      void setRAM(const string& ram)
      {
          RAM = ram;
      }
  
      void setStorage(const string& storage)
      {
          Storage = storage;
      }
      
      void showSpecs()const
      {
          cout << "CPU : " << CPU << endl;
          cout << "GPU : " << GPU << endl;
          cout << "RAM : " << RAM << endl;
          cout << "Storage: " << Storage << endl;
      }
  private:
      string CPU;
      string GPU;
      string RAM;
      string Storage;
  };
  
  //抽象建造类
  class ComputerBuilder
  {
  public:
      virtual ~ComputerBuilder(){}
      virtual void buildCPU() = 0;
      virtual void buildGPU() = 0;
      virtual void buildRAM() = 0;
      virtual void buildStorage() = 0;
      virtual unique_ptr<Computer> getComputer() = 0;
  };
  
  //具体建造者类-高性能电脑建造者
  class HighEndComputerBuilder : public ComputerBuilder
  {
  public:
      HighEndComputerBuilder()
      {
          computer = std::make_unique<Computer>();
      }
  
      void buildCPU() override
      {
          computer->setCPU("Intel i9");
      }
  
      void buildGPU() override
      {
          computer->setGPU("NVIDIA RTX 4090");
      }
  
      void buildRAM() override
      {
          computer->setRAM("64G");
      }
  
      void buildStorage() override
      {
          computer->setStorage("4TB SSD");
      }
  
      unique_ptr<Computer> getComputer() override
      {
          return std::move(computer);//转移所有权
      }
  private:
      unique_ptr<Computer> computer;
  };
  //具体建造者类-低性能电脑建造者
  class LowEndComputerBuilder : public ComputerBuilder
  {
  public:
      LowEndComputerBuilder()
      {
          computer = std::make_unique<Computer>();
      }
  
      void buildCPU() override
      {
          computer->setCPU("Intel i3");
      }
  
      void buildGPU() override
      {
          computer->setGPU("Integated Graphics");
      }
  
      void buildRAM() override
      {
          computer->setRAM("8G");
      }
  
      void buildStorage() override
      {
          computer->setStorage("256G SSD");
      }
  
      unique_ptr<Computer> getComputer() override
      {
          return std::move(computer);//转移所有权
      }
  
  private:
      unique_ptr<Computer> computer;
  };
  
  //指挥者类-控制建造过程
  class Director
  {
  public:
      void setBuilder(unique_ptr<ComputerBuilder> builder)
      {
          this->builder = std::move(builder);
      }
  
      unique_ptr<Computer> construct()
      {
          builder->buildCPU();
          builder->buildGPU();
          builder->buildRAM();
          builder->buildStorage();
          return builder->getComputer();
      }
  private:
      unique_ptr<ComputerBuilder> builder;
  };
  
  int main(int argc, char **argv)
  {
      Director director;
  
      //构建高性能电脑
      director.setBuilder(std::make_unique<HighEndComputerBuilder>());
      unique_ptr<Computer> highEndComputerBuilder = director.construct();
      cout << "High-end computer specs:" << endl;
      highEndComputerBuilder->showSpecs();
  
      //构建低性能电脑
      director.setBuilder(std::make_unique<LowEndComputerBuilder>());
      unique_ptr<Computer> lowEndComputerBuilder = director.construct();
      cout << endl <<  "Low-end computer specs:" << endl;
      lowEndComputerBuilder->showSpecs();
  
      return 0;
  }
  ```

  在该示例中：

  - `Computer`类：表示需要建造的复杂对象，包含了 `CPU`、`GPU`、内存、存储等属性。
  - `ComputerBuilder`抽象类：定义了构建`Computer`的步骤，包括`buildCPU()`、`buildGPU()`、`buildRAM()`和`buildStorage()`等虚函数。
  - `HighEndComputerBuilder`和`LowEndComputerBuilder`：分别实现了`ComputerBuilder`接口，负责创建高端和低端的电脑。
  - `Director`类：负责控制建造过程。客户端通过指挥者构建对象，而不直接操作建造者。
  - 客户端：客户端通过`Director`创建不同配置的`Computer`对象，而无需直接了解其构建过程的细节。

- **使用场景示例**

  - 复杂对象的创建
    - 比如创建一台配置复杂的计算机、汽车、房子等，每个对象包含很多部件，并且每个部件有不同的实现。
  - 可定制的对象创建
    - 用户可以通过指定不同的建造者来创建不同的对象配置。
  - 逐步构建对象
    - 需要灵活地控制对象的构建顺序，并根据需求调整某些部件。



## 8、什么是适配器模式？一般用在什么场景？

**适配器模式**（Adapter Pattern）是一种**结构型设计模式**，它的目的是将不兼容的接口通过一个适配器转换为兼容的接口，使得原本不能一起工作的类可以协同工作。

- **核心思想**

  将一个类的接口转换成客户端期望的另一个接口，使原本由于接口不兼容而不能一起工作的类能够协同工作。

  - 核心要点
    - 接口转换
      - 在不改变原有类（或接口）的情况下，实现不同接口之间的兼容。
    - 复用现有类
      - 通过适配器，让已有类可以满足新的需求或配合新系统工作。
    - 解耦
      - 让不同类之间保持松耦合，尤其是在使用第三方库时，使其独立于应用的业务逻辑。

- **组成部分**

  - 目标接口（Target）
    - 定义客户端期望的接口。客户端会通过目标接口与适配器交互。
  - 现有接口（Adaptee）
    - 已经存在的类，它有一个不兼容的接口。
  - 适配器（Adapter）
    - 适配器实现了目标接口，并通过内部调用现有接口的方法来完成任务，从而让两者能够协同工作。
  - 客户端（Client）
    - 使用目标接口的实体。它通过目标接口与适配器类进行交互。

- **使用场景**

  - 遗留系统兼容
    - 当有一个新的系统需要整合到旧的系统中，而两个系统的接口不兼容时，可以使用适配器模式进行接口的转换。
  - 第三方库集成
    - 当想使用一个已有的类或库，但它的接口不符合你的需求时，可以通过适配器将其接口转换成你需要的格式。
  - 不同接口的协作
    - 两个或多个接口不能直接协作时，通过适配器模式可以使它们协同工作。

- 示例代码

  将旧的音频播放器（只支持MP3格式）适配到一个新的接口，以支持更多格式（如MP4和AVI）。

  例如：以下只支持MP3格式：

  ```c++
  #include <iostream>
  #include <string>
  
  using std::cout;
  using std::endl;
  using std::string;
  
  //目标接口类
  class MediaPlayer
  {
  public:
      virtual void play(const string& audioType, const string& fileName) = 0;
      virtual ~MediaPlayer() = default;
  };
  
  //旧的MP3播放器类
  class OldMediaPlayer
  {
  public:
      void playMP3(const string& fileName)
      {
          cout << "Playing MP3 file : " << fileName << endl;
      }
  };
  
  //适配器类
  class MediaAdapter : public MediaPlayer
  {
  public:
      MediaAdapter(const string& audioType)
      {
          if(audioType == "mp3")
          {
              oldMediaPlayer = new OldMediaPlayer();
          }
          else
          {
              oldMediaPlayer = nullptr;
          }
      }
  
      void play(const string& audioType, const string& fileName)override
      {
          if(audioType == "mp3" && oldMediaPlayer != nullptr)
          {
              oldMediaPlayer->playMP3(fileName);
          }
          else
          {
              cout << "Invalid media type : " << audioType << " format not supported." << endl;
          }
      }
  
      ~MediaAdapter()
      {
          delete oldMediaPlayer;
      }
  private:
      OldMediaPlayer* oldMediaPlayer;
  };
  
  //客户端类
  class AudioPlayer : public MediaPlayer
  {
  public:
      AudioPlayer() : mediaAdapter(nullptr)
      {
  
      }
  
      ~AudioPlayer()
      {
          delete mediaAdapter;
      }
  
      void play(const string& audioType, const string& fileName)override
      {
          if(audioType == "mp3")
          {
              OldMediaPlayer player;
              player.playMP3(fileName);
          }
          else if(audioType == "mp4" || audioType == "avi")
          {
              mediaAdapter = new MediaAdapter(audioType);
              mediaAdapter->play(audioType, fileName);
          }
          else
          {
              cout << "Invalid media type : " << audioType << " format not supported." << endl;
          }
      }
  private:
      MediaAdapter* mediaAdapter;
  };
  
  int main(int argc, char **argv)
  {
      AudioPlayer* audioPlayer = new AudioPlayer();
  
      audioPlayer->play("mp3", "song.mp3");
      audioPlayer->play("mp4", "movie.mp4");
      audioPlayer->play("avi", "show.avi");
      audioPlayer->play("flv", "clip.flv");
  
      delete  audioPlayer;
      return 0;
  }
  ```

  输出：

  ```c++
  Playing MP3 file : song.mp3
  Invalid media type : mp4 format not supported.
  Invalid media type : avi format not supported.
  Invalid media type : flv format not supported.
  ```

  想要支持MP4，就要新增MP4类：

  ```c++
  #include <iostream>
  #include <string>
  
  using std::cout;
  using std::endl;
  using std::string;
  
  //目标接口类
  class MediaPlayer
  {
  public:
      virtual void play(const string& audioType, const string& fileName) = 0;
      virtual ~MediaPlayer() = default;
  };
  
  //旧的MP3播放器类
  class OldMediaPlayer
  {
  public:
      void playMP3(const string& fileName)
      {
          cout << "Playing MP3 file : " << fileName << endl;
      }
  };
  
  //新的MP4播放器类
  class MP4Player
  {
  public:
      void playMP4(const string& fileName)
      {
          cout << "Playing MP4 file : " << fileName << endl;
      }
  };
  
  //适配器类
  class MediaAdapter : public MediaPlayer
  {
  public:
      MediaAdapter(const string& audioType)
      {
          if(audioType == "mp3")
          {
              oldMediaPlayer = new OldMediaPlayer();
          }
          else if(audioType == "mp4")
          {
              mp4Player = new MP4Player();
              oldMediaPlayer = nullptr;
          }
          else
          {
              oldMediaPlayer = nullptr;
              mp4Player = nullptr;
          }
      }
  
      void play(const string& audioType, const string& fileName)override
      {
          if(audioType == "mp3" && oldMediaPlayer != nullptr)
          {
              oldMediaPlayer->playMP3(fileName);
          }else if(audioType == "mp4" && mp4Player != nullptr)
          {
              mp4Player->playMP4(fileName);
          }
          else
          {
              cout << "Invalid media type : " << audioType << " format not supported." << endl;
          }
      }
  
      ~MediaAdapter()
      {
          delete oldMediaPlayer;
          delete mp4Player;
      }
  private:
      OldMediaPlayer* oldMediaPlayer;
      MP4Player* mp4Player;
  };
  
  
  //客户端类
  class AudioPlayer : public MediaPlayer
  {
  public:
      AudioPlayer() : mediaAdapter(nullptr)
      {
  
      }
  
      ~AudioPlayer()
      {
          delete mediaAdapter;
      }
  
      void play(const string& audioType, const string& fileName)override
      {
          if(audioType == "mp3")
          {
              OldMediaPlayer player;
              player.playMP3(fileName);
          }
          else if(audioType == "mp4" || audioType == "avi")
          {
              mediaAdapter = new MediaAdapter(audioType);
              mediaAdapter->play(audioType, fileName);
          }
          else
          {
              cout << "Invalid media type : " << audioType << " format not supported." << endl;
          }
      }
  private:
      MediaAdapter* mediaAdapter;
  };
  
  int main(int argc, char **argv)
  {
      AudioPlayer* audioPlayer = new AudioPlayer();
  
      audioPlayer->play("mp3", "song.mp3");
      audioPlayer->play("mp4", "movie.mp4");
      audioPlayer->play("avi", "show.avi");
      audioPlayer->play("flv", "clip.flv");
  
      delete  audioPlayer;
      return 0;
  }
  ```

  输出：

  ```c++
  Playing MP3 file : song.mp3
  Playing MP4 file : movie.mp4
  Invalid media type : avi format not supported.
  Invalid media type : flv format not supported.
  ```



## 9、什么是装饰器模式？一般用在什么场景？

**装饰器模式**（Decorator Pattern）是一种**结构型设计模式**，允许你动态地向对象添加新的功能，而不改变其原始类的结构。它提供了一种灵活的替代方案，避免了通过继承增加功能的方式。装饰器模式通过组合的方式，将功能逐步包装起来，使得对象的功能可以在运行时动态扩展，而无需修改类代码。

- **核心思想**

  - 动态扩展对象功能
    - 通过在对象外部逐步封装不同的功能，使得类可以保持简洁，并且在运行时增加额外的行为。
  - 遵行开放-闭合原则
    - 类应该对扩展开放，对修改关闭。装饰器模式通过扩展类功能，而不直接修改类代码。

- **组成部分**

  - 组件接口（Component）
    - 这是定义了可以被装饰的对象的标准接口，通常是一个抽象类或接口，所有具体的对象和装饰器都要实现这个接口。
  - 具体组件（ConcreteComponent）
    - 实现了组件接口的类，是被装饰对象的具体实现。
  - 装饰器（Decorator）
    - 继承组件接口，同时包含对组件对象的引用。它可以在调用组件的原始方法之前或之后添加额外的功能。
  - 具体装饰器（ConcreteDecorator）
    - 扩展自装饰器类，具体实现额外的功能。

- **使用场景**

  - 动态扩展对象功能
    - 当需要为对象动态地添加功能，而这些功能并不是所有对象都需要时，装饰器模式是一种比继承更灵活的选择。
  - 替代继承
    - 当通过继承增加功能导致子类过多时，可以使用装饰器模式来避免过度扩展继承层次。
  - 增强功能时不改变原始类
    - 当你不能或者不想改变类的源代码时（比如第三方库的类），可以通过装饰器模式为其增加功能。

- **使用示例**

  假设有一个简单的咖啡对象，我们通过装饰器动态地为咖啡添加不同的配料，并计算最终的价格。

  ```c++
  #include <iostream>
  #include <string>
  
  using std::cout;
  using std::endl;
  using std::string;
  
  //抽象组件接口
  class Coffee
  {
  public:
      virtual string getDescription() = 0;
      virtual double cost() = 0;
      virtual ~Coffee() = default;
  };
  
  //具体组件：简单咖啡
  class SimpleCoffee : public Coffee
  {
  public:
      string getDescription()override
      {
          return "Simple Coffee";
      }
  
      double cost()override
      {
          return 5.0;//基础咖啡价格
      }
  };
  
  //抽象装饰器类，继承自Coffee
  class CoffeeDecorator : public Coffee
  {
  public:
      CoffeeDecorator(Coffee* coffee)
          : decoratedCoffee(coffee)
      {
  
      }
  
      string getDescription()override
      {
          return decoratedCoffee->getDescription();//调用被装饰对象的方法
      }
  
      double cost()override
      {
          return decoratedCoffee->cost();
      }
  
      virtual ~CoffeeDecorator()
      {
          delete decoratedCoffee; 
      }
  
  protected:
      Coffee* decoratedCoffee;//被装饰的Coffee对象
  };
  
  //具体装饰器：牛奶
  class MilkDecorator : public CoffeeDecorator
  {
  public:
      MilkDecorator(Coffee* coffee)
          : CoffeeDecorator(coffee)
      {
  
      }
  
      string getDescription()override
      {
          return decoratedCoffee->getDescription() + ", Milk";
      }
  
      double cost()override
      {
          return decoratedCoffee->cost() + 1.5;//加牛奶的额外费用
      }
  };
  
  //具体装饰器：糖
  class SugarDecorator : public CoffeeDecorator
  {
  public:
      SugarDecorator(Coffee* coffee)
          : CoffeeDecorator(coffee)
      {
  
      }
  
      string getDescription()override
      {
          return decoratedCoffee->getDescription() + ", Sugar";
      }
  
      double cost()override
      {
          return decoratedCoffee->cost() + 0.5;//加糖的额外费用
      }
  };
  
  int main(int argc, char **argv)
  {
      //创建一个基础咖啡
      Coffee* myCoffee = new SimpleCoffee();
      cout << myCoffee->getDescription() << " $" << myCoffee->cost() << endl;
  
      //添加牛奶
      myCoffee = new MilkDecorator(myCoffee);
      cout << myCoffee->getDescription() << " $" << myCoffee->cost() << endl;
  
      //添加糖
      myCoffee = new SugarDecorator(myCoffee);
      cout << myCoffee->getDescription() << " $" << myCoffee->cost() << endl;
      
      //释放内存
      delete myCoffee;
  
      return 0;
  }
  ```

  运行结果

  ```c++
  Simple Coffee $5
  Simple Coffee, Milk $6.5
  Simple Coffee, Milk, Sugar $7
  ```



## 10、什么是代理模式？一般用在什么场景？

**代理模式**（Proxy Pattern）是一种**结构型设计模式**，提供了对象的替代者或占位符，以控制对该对象的访问。代理模式为一个对象提供一个代理对象，由代理对象来控制对原对象的访问，可以在访问前后进行额外的处理。

- **核心思想**

  **代理类**和**真实类**实现相同的接口，客户端通过代理类访问真实类对象，从而控制或增强对真实对象的访问。

- **组成部分**

  - 抽象主题（Subject）
    - 定义了真实对象和代理对象的共同接口，这使得代理对象能够作为真实对象的替代品。
  - 真实主题（RealSubject）
    - 实现了抽象主题，表示客户端最终需要使用的对象。
  - 代理（Proxy）
    - 代理类实现了与真实对象相同的接口，并包含对真实对象的引用。它负责控制对真实对象的访问，可以在调用真实对象的操作之前或之后进行额外的操作。

- **主要类型**

  - 远程代理
    - 用于控制访问远程对象。客户端可以通过代理访问远程对象，就像访问本地对象一样。
  - 虚拟代理
    - 用于控制资源密集对象的访问，延迟对象的实例化，直到真正需要时才创建它。
  - 保护代理
    - 用于控制对象的访问权限，确保用户有相应的权限后才可以访问对象的方法。

- **使用场景**

  - 延迟加载（虚拟代理）
    - 当一个对象创建开销较大时，可以使用虚拟代理在真正需要时才实例化该对象。
  - 访问控制（保护代理）
    - 通过代理控制对对象的访问权限，例如不同用户角色具有不同的访问权限。
  - 远程代理
    - 用于访问远程对象时，代理可以处理网络通信，隐藏复杂性。
  - 日志记录或监控
    - 代理可以在调用真实对象的方法之前或之后记录日志，或在方法调用时进行额外的监控。
  - 智能引用
    - 代理可以控制对对象的引用计数等操作，确保对象在没有引用时被正确释放。

- **代码示例**

  假设有一个图片查看器系统，加载高清图片的成本很高，因此我们希望在用户需要查看图片时才真正加载图片。我们可以通过**虚拟代理**来延迟图片加载。

  ```c++
  #include <iostream>
  #include <string>
  
  using std::cout;
  using std::endl;
  using std::string;
  
  //抽象主题类
  class Image
  {
  public:
      virtual void display() = 0;//显示图片
      virtual ~Image() = default;
  };
  
  //真实图片类
  class RealImage : public Image
  {
  public:
      RealImage(const string& fileName)
          :fileName(fileName)
      {
          loadFromDisk();//构造时加载图片
      }
  
      void display()override
      {
          cout << "Displaying image : " << fileName << endl;
      }
  private:
      string fileName;
  
      //私有方法，模拟加载高清图片
      void loadFromDisk()
      {
          cout << "Loading image from disk : " << fileName << endl;
      }
  };
  
  //代理图片类
  class ProxyImage : public Image
  {
  public:
      ProxyImage(const string& fileName)
          :realImage(nullptr)
           ,fileName(fileName)
      {
  
      }
  
      void display()override
      {
          //只有在需要显示图片时才真正加载图片
          if(realImage == nullptr)
          {
              realImage = new RealImage(fileName);
          }
          realImage->display();
      }
  
      ~ProxyImage()
      {
          delete realImage;
      }
  private:
      RealImage* realImage;
      string fileName;
  };
  
  
  int main(int argc, char **argv)
  {
      //创建代理对象，未立即加载图片
      Image* image = new ProxyImage("high_resolution_image.jpg");
  
      //图片尚未加载
      cout << "Image object cerated, but image not loaded yet." << endl;
  
      //图片第一次显示时加载
      image->display();//将加载并显示图片
  
      //图片已加载，不需要再次加载
      image->display();//直接显示图片
  
      delete image;
  
      return 0;
  }
  ```

  运行结果：

  ```c++
  Image object created, but image not loaded yet.
  Loading image from disk: high_resolution_image.jpg
  Displaying image: high_resolution_image.jpg
  Displaying image: high_resolution_image.jpg
  ```

  代码解析：

  - **`Image`** 是抽象主题，定义了 `display()` 方法。
  - **`RealImage`** 是真实主题类，加载图片并显示它。
  - **`ProxyImage`** 是代理类，只有在第一次需要显示图片时才创建并加载 `RealImage` 对象，避免不必要的资源消耗。
  - **客户端** 通过代理对象 `ProxyImage` 访问图片，而代理控制了实际的图片加载行为。

- **代理模式的优势**

  - 控制对象访问
    - 代理模式提供了一种可以在对象访问时进行控制的机制，如权限检查、延迟加载等。
  - 延迟开销
    - 虚拟代理可以延迟创建开销较大的对象，直到真正需要时才创建，优化资源使用。
  - 增强功能
    - 通过在代理中扩展功能，能够在不改变原有类的情况下增加日志、缓存、监控等功能。

- **使用代理模式的典型场景**

  - 远程代理
    - 为远程服务提供本地代理，隐藏网络通信细节。
  - 虚拟代理
    - 用来延迟创建重量级对象，或只在需要时创建它们（如图像加载）。
  - 保护代理
    - 控制对敏感对象的访问，检查调用者的权限。
  - 缓存代理
    - 缓存一些昂贵操作的结果，减少重复计算。



## 11、什么是观察者模式？一般用在什么场景？

**观察者模式**（Observer Pattern）是一种**行为型设计模式**，用于建立一种**一对多**的依赖关系，使得**当一个对象（被观察者）状态发生变化时，所有依赖于它的对象（观察者）都能自动收到通知并更新**。这种模式非常适合处理对象之间的事件订阅和通知机制。

- **核心思想**

  - 被观察者（Subject）
    - 维护观察者的列表，并提供方法以添加、删除观察者。被观察者在状态变化时通知所有观察者。
  - 观察者（Observer）
    - 定义一个更新接口，以便接收被观察者的通知。
  - 具体观察者
    - 实现观察者接口，定义如何响应被观察者的状态变化。

- **组成部分**

  - Subject（被观察者）
    - 包含状态和观察者列表，提供注册、注销观察者的方法，并在状态变化时通知观察者。
  - Observer（观察者）
    - 定义更新方法，以接收被观察者的通知。
  - ConcreteSubject（具体被观察者）
    - 实现被观察者接口，维护状态并在变化时通知观察者。
  - ConcreteObserver（具体观察者）
    - 实现观察者接口，定义响应被观察者状态变化的具体行为。

- **使用场景**

  - 事件处理系统
    - 例如GUI框架，用户在界面上触发事件，多个组件需要响应。
  - 数据模型更新
    - 在MVC（模型-视图-控制器）架构中，模型的变化需要通知视图更新。
  - 实时数据更新
    - 股票交易系统，当股价变化时，所有订阅用户需要更新显示。
  - 推送通知
    - 例如新闻订阅系统，用户订阅新闻，当有新内容时自动推送通知。
  - 状态变化监听
    - 如游戏中的角色状态变化，所有相关组件（如UI、敌人行为）需要相应更新。

- **示例代码**

  ```c++
  #include <iostream>
  #include <vector>
  #include <string>
  
  // 抽象观察者
  class Observer {
  public:
      virtual void update(const std::string& message) = 0;
  };
  
  // 抽象被观察者
  class Subject {
  public:
      virtual void attach(Observer* observer) {
          observers.push_back(observer);
      }
      virtual void detach(Observer* observer) {
          observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end());
      }
      virtual void notify(const std::string& message) {
          for (Observer* observer : observers) {
              observer->update(message);
          }
      }
  private:
      std::vector<Observer*> observers;
  };
  
  // 具体被观察者
  class WeatherStation : public Subject {
  public:
      void setTemperature(float temp) {
          temperature = temp;
          notify("Temperature updated to: " + std::to_string(temperature));
      }
  private:
      float temperature;
  };
  
  // 具体观察者
  class Display : public Observer {
  public:
      void update(const std::string& message) override {
          std::cout << "Display updated: " << message << std::endl;
      }
  };
  
  // 客户端代码
  int main() {
      WeatherStation weatherStation;
      Display display;
  
      weatherStation.attach(&display);
      weatherStation.setTemperature(25.0f);  // 更新温度并通知观察者
  
      return 0;
  }
  ```

  

















## 12、什么是策略模式？一般用在什么场景？



## 13、什么是命令模式？一般用在什么场景？



## 14、什么是责任链模式？一般用在什么场景？









































# 八、计网

## 1、常见的HTTP状态码有哪些？（深信服）

HTTP状态码用于**表示客户端请求的响应结果**，通常由三位数字组成，并分为五个类别。

- **1xx：信息性响应**

  这些状态码表示**请求已被接受**，正在继续处理。

  - 100 Continue：客户端应继续发送请求的其余部分（通常用于POST/PUT请求）。
  - 101 Switching Protocols：服务器已接受客户端的升级协议请求，并将协议切换到新版本。

- **2xx：成功响应**

  这些状态码表示**请求成功被处理**。

  -	200 OK：请求成功，服务器返回请求的资源（最常见的状态码）。
  -	201 Created：请求成功，服务器创建了一个新的资源（通常是POST请求的结果）。
  -	202 Accepted：请求已接受，但尚未处理完。
  -	204 No Content：请求成功处理，但没有内容返回（常用于DELETE请求）。

- **3xx：重定向**

  这些状态码表示**客户端需要进一步的操作来完成请求**（通常是重定向）。

  - 301 Moved Permanently：资源永久移动到新URL，客户端应使用新地址。
  - 302 Found：资源临时移动到新URL，客户端可以继续使用旧地址（临时重定向）。
  - 304 Not Modified：资源未修改，客户端可以使用缓存的副本。

- **4xx：客户端错误**

  这些状态码表示**请求有错误，客户端需要修改请求**。

  - 400 Bad Request：请求有误，服务器无法理解（通常是语法错误或无效请求格式）。
  - 401 Unauthorized：请求未授权，需提供身份验证信息（如登录或API密钥）。
  - 403 Forbidden：服务器拒绝请求，客户端没有权限访问资源。
  - 404 Not Found：请求的资源不存在或无法找到。
  - 405 Method Not Allowed：请求的方法不被允许，例如使用POST访问只允许GET的资源。
  - 409 Conflict：请求与服务器的当前状态冲突（如并发修改冲突）。

- **5xx：服务器错误**

  这些状态码表示**服务器在处理请求时发生了错误**。

  - 500 Internal Server Error：服务器内部错误，无法完成请求（最常见的服务器错误）。
  - 502 Bad Gateway：服务器作为网关或代理时，从上游服务器接收到无效响应。
  - 503 Service Unavailable：服务器暂时无法处理请求（可能是超载或维护）。
  - 504 Gateway Timeout：服务器作为网关或代理时，未能及时从上游服务器获得响应。



## 2、HTTP请求包含哪些内容，请求头和请求体有哪些类型？

HTTP请求由**请求行、请求头（Headers）、请求体**三部分组成。 

- **请求行（Request Line）**

  HTTP请求的第一行，由三部分组成：

  - **请求方法（HTTP Method）**：表示客户端希望服务器资源执行的操作

    - **GET**：请求获取服务器上的资源，不带请求体。
    - **POST**：向服务器发送数据，一般用于表单提交、文件上传。
    - **PUT**：请求上传或替换资源。
    - **DELETE**：请求删除服务器上的资源。
    - **HEAD**：与GET类似，但只请求响应的头部信息，不返回具体内容。
    - **PATCH**：部分修改资源。
    - **OPTIONS**：请求查询服务器支持哪些请求方法。
    - **TRACE**：回显服务器收到的请求，主要用于诊断。

  - **URL（请求目标/Request Target）**

    表示请求的目标资源的地址，可以是绝对或相对路径。

  - **HTTP版本（HTTP Version）**

    表示使用的HTTP协议版本，例如 `HTTP/1.1` 或 `HTTP/2`。

    ```bash
    GET /index.html HTTP/1.1
    ```

- **请求头（Request Headers）**

  请求头包含了客户端发送给服务器的元数据信息，用于描述请求的属性或客户端的环境信息。请求头是键值对格式，格式为 `Header-Name: Header-Value`。请求头的类型有很多，主要可以分为以下几类：

  - 通用首部：适用于请求和响应的通用字段。

    - `Cache-Control`：控制缓存行为。
    - `Connection`：控制连接管理，如keep-alive或close。
    - `Date`：表示请求发送时间。

  - 请求首部：特定于请求的头字段，提供关于客户端环境的信息。

    - `Host`：请求的目标主机和端口（必须包含于 HTTP/1.1 请求中）。
    - `User-Agent`：发送请求的客户端应用程序的身份标识（如浏览器或其他客户端）。
    - `Accept`：客户端能够处理的内容类型，例如 `text/html, application/json`。
    - `Accept-Encoding`：客户端支持的内容编码，如 `gzip, deflate`。
    - `Accept-Language`：客户端支持的语言集，如 `en-US`、`zh-CN`。
    - `Referer`：指向发起此请求的页面的URL。
    - `Authorization`：包含认证信息，用于验证客户端身份，如 `Bearer `、`Basic `。
    - `Cookie`：包含客户端发送的cookies，用于维护客户端和服务器的会话状态。

  - 常见的请求头示例：

    ```makefile
    Host: www.example.com
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
    Accept-Encoding: gzip, deflate, br
    Accept-Language: en-US,en;q=0.9
    Cookie: sessionId=abcdef123456
    ```

- **请求体（Request Body）**

  请求体包含了客户端发送给服务器的实际数据，通常用于POST、PUT等方法中。GET等方法一般不包含请求体。

  常见的请求体类型：

  - `application/x-www-form-urlencoded`：表单数据的默认编码方式，常用于简单的表单提交。数据会以键值对的形式编码，例如：

    ```makefike
    username=johndoe&password=123456
    ```

  - `multipart/form-data`：用于文件上传或提交复杂的表单数据，每个字段以不同的部分分割，适合处理多部分数据（如文本和文件同时上传）。

  - `application/json`：请求体以JSON格式发送，常用于REST API调用。例如：

    ```json
    {
      "username": "johndoe",
      "password": "123456"
    }
    
    ```

  - `text/plain`：请求体以纯文本形式发送，通常用于简单的文本数据。

  - `application/xml`：请求体以XML格式发送，常用于与SOAP API或其他基于XML的数据交换协议。

- 示例

  POST请求的请求行、请求头和请求体：

  ```makefile
  POST /login HTTP/1.1
  Host: www.example.com
  Content-Type: application/json
  Content-Length: 48
  
  {
      "username": "johndoe",
      "password": "123456"
  }
  ```



## 3、除了四次挥手，还有什么方法断开连接？

除了通过 **四次挥手**（TCP 四次挥手）来断开连接，以下是几种常见的断开连接的方式：

- **RST（Reset）标志断开连接**
  - TCP连接可以通过发送一个带有 **RST（Reset）标志** 的TCP数据包立即终止。这种方式比四次挥手更为直接和粗暴，因为它不会进行任何资源的清理或状态的维护。RST连接的断开通常是在出现异常或错误时使用，例如：
    - 服务器发现收到的请求不合法，会发送RST包强制终止连接。
    - 应用程序由于某些异常条件（如主机不可达或端口不可用）触发了RST断开。
  - 特点：
    - 立即断开：不会进行正常的挥手流程，直接切断连接。
    - 无状态清理：不会像四次挥手那样有序地关闭连接，双方不会通知对方资源释放。
  - 使用场景：
    - 网络中断或错误。
    - 应用程序主动要求立即终止连接。
- **超时（Timeout）断开连接**
  - 当一方停止通信且没有进行四次挥手或其他断开操作时，另一方会因为长时间未收到数据而触发连接超时。这种情况通常会依赖于协议层的定时器来检测，并在超过一定的时间后主动断开连接。
  - 特点：
    - 被动断开：一方没有主动终止连接，而是由于长时间未通信，连接自动超时并关闭。
    - 超时时间可配置：不同的系统或协议可以配置不同的超时时间。
  - 使用场景：
    - 网络延迟或连接断开未检测到，导致长时间未收到通信数据。
    - 长时间空闲的连接（如HTTP Keep-Alive连接的超时关闭）。
- **应用层协议的断开**
  - 有些应用层协议（如HTTP、WebSocket、FTP等）本身具有断开连接的机制。应用层协议的断开通常是通过在应用层发送特定的命令或消息来实现，例如：
    - **HTTP Keep-Alive** 连接可以通过在响应头中明确指示 `Connection: close` 来断开。
    - **FTP** 连接中可以通过发送 `QUIT` 命令来通知服务器断开连接。
    - **WebSocket** 可以通过发送 `Close Frame` 来请求关闭连接。
  - 特点：
    - 协议层控制：通过应用层协议控制连接的断开，而不直接依赖底层TCP的断开机制。
    - 有序关闭：通常应用层协议会确保在发送断开命令之前完成所有必要的操作。
  - 使用场景：
    - HTTP连接的关闭控制。
    - WebSocket、FTP等协议在完成数据传输后断开连接。
- **进程终止**
  - 如果一个程序或进程在TCP连接尚未关闭时直接退出（例如，应用程序崩溃或被强制终止），操作系统会立即为该进程打开的所有TCP连接发送RST包，强制断开这些连接。这是一种强制的连接断开方式，类似于RST断开，但是在操作系统级别处理的。
  - 特点：
    - 非正常断开：进程异常终止会导致连接被强制关闭。
    - 数据丢失风险：未完成的数据传输可能会丢失。
  - 使用场景：
    - 应用程序崩溃或被用户强制终止。
    - 系统重启或关机。
- **防火墙或路由器干预**
  - 某些情况下，网络设备如防火墙或路由器可以主动中断某个TCP连接。它们可以通过配置规则阻止某些端口、IP地址的通信，或者通过网络安全策略主动断开长时间未活动的连接。
  - 特点：
    - 网络层干预：防火墙或路由器会通过直接丢弃数据包或发送RST包的方式断开连接。
    - 无序断开：连接被强制关闭，没有正常的挥手过程。
  - 使用场景：
    - 防火墙检测到安全威胁时，强制终止连接。
    - 通过路由器策略断开长时间空闲的TCP连接。
- **双FIN（快速四次挥手）**
  - 虽然TCP标准中断开连接通常是通过四次挥手，但在某些情况下，双方几乎同时发送 `FIN` 包（即两个 `FIN` 包几乎同时被发送），这样挥手过程就会缩短为**两次**交互完成。这种方式也可以被认为是一种快速的四次挥手。
  - 特点：
    - 快速关闭：双方几乎同时关闭连接，减少了等待时间。
    - 无需重传确认：在双方确认的情况下，不必等待多余的确认包。
  - 使用场景：
    - 两端连接状态明确，且都希望快速终止通信。



## 4、网络协议为什么需要分层？（深信服）

复杂的系统都需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。分层带来的好处：

- 各层之间相互独立
- 提高了整体灵活性
- 大问题化小





## 5、TCP保证可靠性的原理（深信服）

TCP协议主要通过以下几点来保证传输可靠性：连接管理、序列号、确认应答、超时重传、流量控制、拥塞控制

- 连接管理
- 序列号
- 确认应答
- 超时重传
- 流量控制
- 拥塞控制



## 6、HTTP 2.0 和 HTTP 3.0有什么区别？

## 7、 HTTP和HTTPS有什么区别？

## 8、HTTP中GET和POST的区别是什么？

## 9、WebSocker与HTTP有什么区别？

## 10、服务端是如何解析HTTP请求的数据？

在服务端解析HTTP请求的数据的过程通常包括以下几个步骤：

- 接收请求

  客户端通过HTTP协议发送请求到服务器，服务器的HTTP服务器（如Apache, Nginx, 或者自定义的服务程序）接收到该请求后，开始解析请求的数据。

- 解析请求行

  HTTP请求的第一行称为请求行（Request Line），包含了三个部分

  - HTTP方法（如GET、POST、PUT等）：告诉服务器要进行的操作。
  - 请求路径：指定客户端请求的资源路径。
  - 协议版本：如HTTP/1.1或HTTP/2。

- 解析请求头

  - 请求头包含了许多与请求相关的元数据，如客户端信息（User-Agent）、请求内容类型（Content-Type）、接收的内容编码（Accept-Encoding）等。
  - 服务端会解析这些头部信息来确定如何处理请求（如是否支持某种编码、请求是否带有认证信息等）。

- 解析请求体

  - 对于POST或PUT请求，数据通常会被包含在请求体中。请求体的内容通常是JSON、表单数据（`application/x-www-form-urlencoded`或`multipart/form-data`）、XML等格式。
  - 服务端会根据请求头中的`Content-Type`字段来解析请求体的格式。例如，如果`Content-Type`为`application/json`，服务器会将请求体解析为JSON对象。

- 解析查询参数

  如果请求路径中包含查询字符串（如`/search?q=example`），服务端需要解析这些查询参数。查询字符串位于请求路径后面，通常以`?`符号开始，参数通过`&`符号分隔。

- 处理请求

  一旦请求头、请求行、请求体等都被解析，服务端会根据请求的方法、路径、查询参数等信息，决定如何处理这个请求。比如，执行数据库查询、调用后端服务，或者返回静态资源等。

- 生成相应

  服务端处理完请求后，生成响应并返回给客户端。响应内容会包含响应行、响应头、以及响应体。



## 11、什么是TCP连接？

TCP连接是指通过**传输控制协议**（TCP）在网络中两个设备之间建立的可靠的通信通道。TCP是一个面向连接的协议，意味着在数据传输之前，客户端和服务器必须通过一个**三次握手**过程来建立连接。这个连接保证了数据的可靠性、有序性以及流量控制。

**TCP连接的关键特性：**

1. **可靠性**：
   - TCP确保数据包按顺序到达，且不会丢失。若数据包丢失，TCP会自动重新传输。
2. **面向连接**：
   - 在数据传输开始之前，必须先建立连接。连接建立后，双方可以持续进行数据交换，直到关闭连接。
3. **全双工通信**：
   - TCP连接支持全双工通信，即数据可以在两个方向上同时传输。客户端和服务器都可以同时发送和接收数据。
4. **流量控制和拥塞控制**：
   - TCP能够根据网络状况调整数据传输的速率，避免网络拥塞和传输过载。
5. **数据分段与重组**：
   - TCP将大数据流切分成较小的数据包，并在接收端按照顺序重组。

**建立TCP连接：三次握手（Three-Way Handshake）**

TCP连接的建立通过三次握手过程完成：

1. **第一次握手**：客户端发送一个**SYN**（同步）包到服务器，告诉服务器客户端想要建立连接。
   - 客户端 → 服务器：SYN (seq=x)
2. **第二次握手**：服务器收到客户端的SYN包后，响应一个**SYN-ACK**包，表示同意建立连接，并且同步自己的序列号。
   - 服务器 → 客户端：SYN-ACK (seq=y, ack=x+1)
3. **第三次握手**：客户端收到服务器的SYN-ACK包后，回复一个**ACK**包，表示确认连接建立。
   - 客户端 → 服务器：ACK (ack=y+1)

此时，连接建立完成，双方可以开始数据传输。

**关闭TCP连接：四次挥手（Four-Way Handshake）**

TCP连接的关闭通过四次挥手完成：

1. **第一次挥手**：客户端发送一个**FIN**包，表示没有数据要发送了，但可以继续接收数据。
   - 客户端 → 服务器：FIN (seq=a)
2. **第二次挥手**：服务器收到FIN包后，回复一个**ACK**包，表示同意关闭连接。
   - 服务器 → 客户端：ACK (ack=a+1)
3. **第三次挥手**：服务器发送一个**FIN**包，表示服务器也没有数据要发送了，但客户端仍然可以继续接收数据。
   - 服务器 → 客户端：FIN (seq=b)
4. **第四次挥手**：客户端收到服务器的FIN包后，回复一个**ACK**包，表示确认连接关闭。
   - 客户端 → 服务器：ACK (ack=b+1)

此时，连接正式关闭，双方都不再发送数据。

**总结：**

TCP连接是网络中设备之间建立的一个可靠的、面向连接的通信通道。在通信开始前，客户端和服务器必须通过三次握手建立连接；数据传输完成后，通过四次挥手关闭连接。这保证了数据的可靠性、顺序性和完整性。

## 12、TCP是用来解决什么问题的？

## 13、TCP和UDP有什么区别？

## 14、为什么要TCP，IP层实现控制不行吗？

## 15、TCP的粘包和拆包能说说吗？

## 16、说说TCP的三次握手？

## 17、TCP初始序列号ISN怎么取值的？

## 18、TCP三次握手时，发送SYN之后就宕机了会怎么样？



# 九、OS



# 十、MySQL

## 1、数据库的锁有哪些锁？（深信服）

数据库的锁主要有以下几种类型，每种锁都具有不同的粒度和作用，通常用于防止多个事务并发操作时出现数据不一致或冲突的情况。常见的数据库锁有：

- **共享锁**
  - 用途：允许多个事务同时读取同一数据，但不允许任何事务修改数据。
  - 特点：当事务持有共享锁时，其他事务可以持有共享锁，但不能持有排他锁。
  - 应用场景：当事务执行`SELECT`查询时，通常会加共享锁，允许其他事务也进行读取，但不能进行修改。
- **排他锁**
  - 用途：当一个事务对数据加上排他锁时，其他事务既不能读取也不能修改这部分数据。
  - 特点：排他锁会阻止其他事务对该数据加锁，无论是共享锁还是排他锁。
  - 应用场景：当事务需要修改数据时（例如`UPDATE`、`DELETE`操作），数据库会加排他锁，防止其他事务对该数据进行读写。
- **意向锁**
  - 用途：一种在更高层次（如表级别）上表示事务意图加共享锁的锁。它并不会阻止其他事务对数据加共享锁，但表示事务打算在更低的层级（如行）加共享锁。
  - 特点：常用于表锁的实现，目的是为了避免其他事务在表上加排他锁。
  - 应用场景：当事务意图在更低层次（如行级）加锁时，表面上并不直接加锁，而是通过意向锁告知数据库该事务的意图。
- **意向排他锁**
  - 用途：表示事务意图在更低的层次（如行级）加排他锁，类似于意向共享锁。
  - 特点：同样避免了其他事务对表加锁。
- **自适应锁**
  - 用途：根据当前事务的访问模式，自动调整锁的类型。通常在高并发环境下，通过动态地选择最适合的锁策略，来提高系统性能。
- **行级锁**
  - 用途：只锁定一行数据，允许其他事务访问其他行数据，适用于高并发操作。
  - 特点：提供较高的并发性，但也会带来锁管理的开销。
  - 应用场景：当数据库对某一行数据加锁时，其他事务可以访问其他行数据。行级锁是锁粒度最小的锁，可以显著提高并发性能。
- **页级锁**
  - 用途：锁定一个数据页，通常是多个行的数据块。与行级锁相比，锁定粒度较大，可能会影响并发性，但减少了锁的管理开销。
  - 特点：适用于低并发、高吞吐量的场景。
  - 应用场景：
- **表级锁**
  - 用途：锁定整张表。只允许一个事务操作这张表的所有数据，其他事务不能对这张表进行任何操作。
  - 特点：并发性最差，适用于数据量较小或更新较少的表。
  - 应用场景：当对表进行操作（如全表扫描、结构修改等）时，会加表级锁。虽然并发性较差，但可以减少锁的管理复杂度。
- **死锁**
  - 定义：死锁并不是一种锁类型，而是指多个事务互相等待对方释放锁，从而导致所有事务无法继续执行的情况。数据库管理系统会通过死锁检测机制来解决死锁问题。
  - 特点：
  - 应用场景：多个事务同时占用不同资源，并且相互等待对方释放资源时，会产生死锁。数据库管理系统一般会自动检测死锁并回滚其中一个事务来解除死锁。
- **乐观锁**
  - 用途：通常不在数据库层面使用传统的锁，而是通过应用逻辑来判断数据是否在读取之后被其他事务修改。
  - 特点：适用于并发读取较多的场景，避免了传统锁机制的开销。通常通过版本号或时间戳来判断是否存在冲突。
  - 应用场景：乐观锁通常通过版本号或时间戳来控制数据的并发更新。适用于读多写少的场景，通过避免锁竞争来提高性能。
- **悲观锁**
  - 用途：事务在对数据进行读取时，就直接加锁，假设数据会被其他事务修改，通常是数据库层面通过加锁来避免并发问题。
  - 特点：适用于写操作较多或数据竞争较大的场景。
  - 应用场景：在并发较高的写操作场景中，悲观锁可以防止其他事务对数据进行修改，确保数据的一致性。



## 2、间隙锁会不会出现死锁情况？为什么？（深信服）

**间隙锁（Gap Lock）**有可能导致死锁情况，主要是因为它在数据库的锁机制中，锁定了某些 **"空白区域"**，而不是直接锁定某一行数据。这种锁机制通常用于 **防止幻读（Phantom Read）**，并在一些特定的事务隔离级别下（例如 **可重复读（REPEATABLE READ）**）被使用。为了更好地理解为什么间隙锁可能会引发死锁，我们需要先理解其工作原理。

**什么是间隙锁？**

间隙锁是数据库的一种锁类型，它并不锁定实际存在的数据行，而是锁定 **某个范围或“间隙”**，即 **两个已存在数据之间的空白区域**。间隙锁用于防止其他事务在该区域插入新的数据行，从而避免出现幻读现象（即某个查询结果集的内容在事务执行过程中发生变化）。

例如，在一个按升序排列的整数列中，如果已经存在数据 `1, 2, 4`，则一个间隙锁可能会锁定 `[2, 4]` 之间的“间隙”来防止其他事务插入 `3`。

**间隙锁和死锁：**

间隙锁会引起死锁的原因主要有以下几点：

1. **间隙锁可能会锁住范围**：
   - 假设两个事务都试图在同一个间隙范围内插入数据。事务A可能已经持有锁 `[2, 4]` 的间隙锁，而事务B则持有锁 `[1, 3]` 的间隙锁，两个事务都无法插入数据。
   - 如果事务A试图在 `[1, 2]` 区间插入数据，事务B则会试图在 `[3, 4]` 区间插入数据。由于它们互相锁住了对方所需的间隙范围，就可能发生死锁。
2. **间隙锁具有隐式阻塞作用**：
   - 间隙锁锁定的并不是某一行数据，而是某个空隙。其他事务试图插入数据时，会被间隙锁阻塞。这种行为与其他传统锁（如行级锁、表级锁）不同，容易在多个事务间产生隐式的依赖和等待关系，从而导致死锁。
3. **锁粒度和事务竞争**：
   - 间隙锁是通过锁住一段范围来防止其他事务插入数据，这可能导致多个事务在尝试访问同一范围时发生资源竞争，特别是在高并发场景下。如果两个事务分别持有不同的间隙锁，并且互相依赖对方释放锁，最终就会导致死锁。

**示例：**

假设有两条事务，T1和T2，它们分别执行以下操作：

- **T1**：读取数据并持有 `[2, 4]` 的间隙锁。
- **T2**：读取数据并持有 `[4, 6]` 的间隙锁。

接着，它们各自尝试在对方所持有的间隙中插入数据：

- **T1** 想在 `[4, 6]` 之间插入数据，但被T2的间隙锁阻塞。
- **T2** 想在 `[2, 4]` 之间插入数据，但被T1的间隙锁阻塞。

此时，T1和T2分别在等待对方释放锁，从而导致死锁。

**如何避免间隙锁导致死锁？**

1. 调整隔离级别
   - 在较低的事务隔离级别（如 **读已提交（READ COMMITTED）**）中，数据库不会使用间隙锁，通常可以减少死锁的发生。使用更高的隔离级别（如 **可重复读（REPEATABLE READ）**）时需要小心，避免间隙锁的使用。
2. 锁粒度和应用逻辑控制
   - 在设计数据库操作时，尽量减少长时间持有锁的情况，避免多个事务竞争同一个间隙锁。
3. 死锁检测和回滚
   - 大部分数据库管理系统（如 MySQL、PostgreSQL）都具有死锁检测机制，当系统检测到死锁时，会自动回滚某一个事务，从而解除死锁。

**总结：**

**是的，间隙锁有可能导致死锁**，主要是因为它锁定了数据行之间的空白区域，而其他事务可能会在这些区域插入数据，从而导致竞争和等待。通过调整事务隔离级别、合理设计事务逻辑、以及使用死锁检测机制，可以有效降低死锁发生的几率。



## 3、MySQL中的数据排序是怎么实现的？

MySQL中的数据排序（`ORDER BY`）是通过 **排序算法** 实现的。MySQL 根据查询的具体情况选择不同的排序算法，这些算法的选择主要取决于数据的大小、是否有索引、是否需要使用外部排序等因素。下面详细介绍 MySQL 排序的实现方式和背后的机制：

1. 排序算法的选择

   MySQL 使用了几种排序算法，其中最常见的是 **快速排序**（QuickSort）、**归并排序**（MergeSort）和 **插入排序**（InsertionSort）。MySQL 会根据具体情况选择合适的排序算法。

   - 内存排序
     - 当排序的数据量足够小，MySQL 可以在内存中完成排序，通常采用 **快速排序**（QuickSort）或 **归并排序**（MergeSort）。
     - 内存排序速度较快，因为它不需要进行磁盘I/O。
     - MySQL 会使用 `sort_buffer_size` 变量指定的内存来进行排序，默认情况下，如果排序的数据量较小，MySQL 会将数据加载到内存中进行排序。
   - 外部排序
     - 当排序的数据量超出 `sort_buffer_size` 配置的内存限制时，MySQL 会使用外部排序，即将数据分成多个小块，每次加载一个小块进行排序，最后将各个小块合并成一个大的有序结果。
     - 外部排序通常使用 **归并排序**，因为它适合处理大数据量的排序任务。归并排序通过不断地将多个已排序的文件合并成一个大的有序文件，直到最终得到完整的排序结果。
     - 这种方法的缺点是涉及到磁盘 I/O，因此性能相对较低。
   - 插入排序
     - 在一些特定情况下，MySQL 会使用 **插入排序**，比如在排序的数据量非常小或者数据已经基本有序时。
     - 插入排序的时间复杂度为 O(n²)，适用于小规模数据的排序。

2. 如何决定使用哪种排序算法

   MySQL 通过以下几个条件来决定采用哪种排序算法：

   - 数据量

     如果排序的数据量非常小，MySQL 会尽量使用内存排序算法（如快速排序或插入排序）。

   - 内存限制

     如果 `sort_buffer_size` 的内存大小足够容纳所有待排序的数据，MySQL 会在内存中执行排序。如果数据量过大，无法放入内存中，MySQL 就会使用外部排序。

   - 索引

     如果查询中涉及到的字段已经建立了索引，MySQL 会利用索引的有序性进行排序，这样可以避免完全排序。也就是说，如果查询中的排序字段与索引列匹配，MySQL 可以通过 **索引扫描** 来直接获取排序结果。

3. 排序和索引的关系

   索引的存在与否对排序性能有着重要影响：

   - 有索引时
     - 如果排序字段有索引，并且查询条件可以利用该索引，MySQL 会通过索引来完成排序，避免全表扫描和额外的排序操作。
     - 比如，如果表上有一个基于 `age` 字段的升序索引，执行 `SELECT * FROM users ORDER BY age` 查询时，MySQL 会直接利用该索引返回已经排序的数据，而不需要额外的排序操作。
   - 无索引时
     - 如果排序字段没有索引，MySQL 就需要对查询结果进行完全排序，使用内存排序或外部排序算法来完成。
     - 这种情况下，数据量大时，性能会下降，因为需要消耗更多的 CPU 和 I/O 资源。

4. `ORDER BY`的优化

   MySQL 的 `ORDER BY` 可能会涉及到以下优化手段：

   - 覆盖索引排序：
     - 如果排序字段在索引的前缀列中，并且查询仅使用这些列，MySQL 可以通过 **覆盖索引**（Covering Index）来直接返回排序结果，从而避免访问数据表。
   - 合并排序：
     - 在执行多表连接时，MySQL 可能会使用 **合并排序**（Merge Join），通过合并排序将已经有序的部分数据合并，提升排序效率。

5. 排序的性能影响

   排序操作会占用较多的资源，尤其是在没有索引或数据量较大的情况下：

   - 内存使用：`sort_buffer_size` 是 MySQL 中控制排序内存大小的参数，如果排序数据量超过该值，MySQL 就会使用磁盘进行外部排序，导致性能降低。
   - 磁盘 I/O：外部排序会涉及磁盘 I/O，因此性能较低，特别是在数据量很大的情况下。
   - 排序字段选择：多个字段排序时，MySQL 会按顺序逐个比较这些字段，排序的复杂度和字段数量及数据量呈线性关系。

**总结**

MySQL 的数据排序是通过不同的排序算法（如快速排序、归并排序、插入排序等）实现的，选择哪种排序算法取决于数据量、是否有索引以及是否超出了内存限制。排序的性能与内存的使用、索引的存在以及磁盘 I/O 等因素密切相关，合理配置和优化这些因素可以大大提高排序操作的效率。



## 4、MySQL的Change Buffer是什么？它有什么作用？

**Change Buffer** 是 MySQL InnoDB 存储引擎中的一个优化机制，旨在提高对二级索引（non-clustered index）写入操作的性能，尤其是在写操作频繁的情况下。它的主要作用是 **延迟二级索引的写入操作**，将更新先存储在内存中，等到适当的时候再统一刷新到磁盘。通过这种方式，Change Buffer 可以减少磁盘I/O操作，提高数据库的整体性能。

**1. Change Buffer 的基本原理**

在 InnoDB 中，**数据页（Data Page）** 和 **索引页（Index Page）** 会被缓存在内存中。当某个查询或更新操作需要修改二级索引时，Change Buffer 会将这些修改 **暂时存储在内存中，而不立即写入磁盘**。这样，磁盘写入操作被延迟，只有当这些数据页被需要（比如在访问时）或者当它们被刷新到磁盘时，才会将更改同步到二级索引的实际数据页中。

Change Buffer 主要针对的是 **二级索引的修改**，因为对于 **聚簇索引（Clustered Index）**，其数据本身就是存储在主索引中，无法采用这种方式进行优化。

**2. Change Buffer 的作用**

1. **减少磁盘I/O**：
   - 写操作（如 `INSERT`、`UPDATE` 或 `DELETE`）会修改二级索引，但是这些修改不会立即写入磁盘，而是先被缓存到 Change Buffer 中。这样，数据库可以通过合并多个写操作，减少对磁盘的频繁写入，提高性能。
2. **提高性能，尤其是大批量写操作时**：
   - 对于一些批量插入或更新操作，Change Buffer 可以有效地将这些操作合并并延迟写入，从而避免了多次的磁盘I/O操作，提高了性能。
3. **优化二级索引更新**：
   - 二级索引的更新通常是较为频繁的，尤其是在大数据量的表中，Change Buffer 提供了一个合并写入的机制，减少了不必要的磁盘操作。
4. **减少磁盘竞争**：
   - 在写操作高并发的场景下，磁盘写入会成为瓶颈，Change Buffer 通过延迟写操作来减少磁盘访问的竞争，提高了系统的并发处理能力。

**3. Change Buffer 的工作机制**

当对 InnoDB 表进行修改（如插入、更新或删除）时，如果涉及到二级索引的更新，InnoDB 会首先判断是否使用 Change Buffer 来延迟更新。

- **插入操作**：如果在插入数据时需要更新二级索引，而这个二级索引的页不在内存中，InnoDB 会将这个更新请求缓存到 Change Buffer 中，并延迟实际写入磁盘。
- **更新操作**：如果更新操作涉及到二级索引的修改，且修改的数据不在内存中，Change Buffer 会将这次修改的请求先缓存，等待下次访问该数据时再将修改写入。
- **删除操作**：类似于更新操作，删除操作如果影响了二级索引，Change Buffer 会缓存这些修改。

**4. Change Buffer 的触发条件**

Change Buffer 会在以下情况下被触发：

- 当 **二级索引** 页需要被更新时，且该页面不在内存中（即不在缓冲池中）。
- 当某个页被修改，但 InnoDB 决定推迟更新，等待下次访问时再执行实际的写入操作。

对于 **聚簇索引**，不会使用 Change Buffer，因为聚簇索引直接存储在数据页中，修改操作是立即生效的。

**5. 何时会将 Change Buffer 中的修改刷写到磁盘？**

Change Buffer 中的内容并不会无限期地保持在内存中，它们会在以下几种情况下被刷新到磁盘：

- **数据页被访问时**：当需要访问某个二级索引页时，如果该页的更改已被缓存到 Change Buffer 中，则这些更改会被写入磁盘。
- **Checkpoints**：MySQL 定期会创建 checkpoint，将缓冲池中的修改持久化到磁盘，Change Buffer 中的修改也会在这个过程中被写入。
- **内存达到上限时**：如果 Change Buffer 占用了过多的内存，或者系统的内存资源压力较大，MySQL 会强制将这些修改刷新到磁盘。

**6. Change Buffer 的配置**

MySQL 允许通过配置参数来调整 Change Buffer 的行为：

- `innodb_change_buffer_max_size`
  - 该参数控制 Change Buffer 的大小，决定了 Change Buffer 最大可以占用缓冲池的比例。默认为 **25%**（即0.25），表示 Change Buffer 可以使用缓冲池总内存的 25%。如果你想增加 Change Buffer 的容量，可以适当增加这个值。
- `innodb_change_buffering`
  - 该参数控制 Change Buffer 的启用方式，可以设置为以下几种值：
    - **`all`**：对所有涉及二级索引的操作都使用 Change Buffer（插入、更新、删除）。
    - **`inserts`**：仅对插入操作使用 Change Buffer。
    - **`none`**：禁用 Change Buffer。

**7. Change Buffer 的性能影响**

虽然 Change Buffer 可以显著提高性能，减少磁盘 I/O，但在一些情况下，它也可能带来一定的开销：

- **额外的内存开销**：Change Buffer 会占用一部分内存，如果配置不当，可能会导致内存资源紧张。
- **写入延迟**：虽然减少了写入操作的频率，但延迟写入的操作可能导致最终的写入操作变得较为集中，可能会导致写入峰值时的性能下降。

**总结**

**Change Buffer** 是 MySQL InnoDB 存储引擎中的一个优化机制，旨在提高二级索引的写入性能，通过将二级索引的更新操作先缓存到内存中，延迟写入磁盘，从而减少磁盘I/O操作，提升性能。它尤其对批量写操作和高并发写入的场景有很大帮助，但也需要合理配置以避免内存资源的过度占用。



## 5、详细描述一条SQL语句在MySQL中的执行过程。

在 MySQL 中，一条 SQL 语句的执行过程可以从 **客户端发起请求** 到 **数据库返回结果** 的整个过程，涉及到多个步骤。具体的执行过程如下：

**1. 客户端发送 SQL 请求**

- 客户端（比如 MySQL 客户端、应用程序等）将 SQL 语句通过网络发送给 MySQL 数据库服务器。
- 发送的 SQL 语句包含操作类型（如 `SELECT`、`INSERT`、`UPDATE`、`DELETE` 等）和相应的数据库对象（如表、字段等）。

**2. 连接层（Connection Layer）**

- MySQL 数据库首先通过连接层接收客户端请求。连接层处理如下内容：
  - 连接认证：验证客户端的用户身份（用户名、密码等）。
  - 会话管理：为每个连接分配一个会话标识符，管理连接状态和事务控制等。
  - 参数初始化：设置与连接相关的参数，如字符集、时区、事务隔离级别等。

**3. 解析 SQL 语句（Parser）**

- SQL 语句首先会被发送到 **解析器（Parser）**，解析器负责对 SQL 语句进行 **词法分析** 和 **语法分析**。
- **词法分析**：将 SQL 语句的字符串拆分为一系列的标记（tokens），比如关键字、标识符、运算符等。
- **语法分析**：检查 SQL 语句的结构是否符合 SQL 语法规范。解析器会根据 MySQL 内部的语法规则来确认 SQL 语句是否有效，并生成一个 **解析树（Parse Tree）**。

**4. 预处理和优化（Preprocessing and Optimization）**

- **语法检查**：首先确保语法无误，并且确保没有错误的字段、表或数据库引用。

- 查询优化器（Query Optimizer）

  ：对于查询语句，MySQL 会进行查询优化。优化器会根据查询的结构和统计信息生成不同的执行计划，并选择最优的执行计划。

  - **选择最优执行计划**：优化器会根据查询的 `WHERE` 条件、表的大小、索引情况等因素来决定如何扫描表、如何连接多个表、是否使用索引等。
  - **成本评估**：优化器会评估各种执行方式的“成本”，即估算执行某种操作所需的资源（如 CPU、内存、磁盘 I/O）并选择成本最低的执行计划。

**5. 执行计划生成（Execution Plan）**

- 优化器生成的执行计划将包含：
  - 表扫描顺序
  - 使用的索引
  - 连接方式（如嵌套循环连接、排序合并连接等）
  - 读取数据的具体方式（如全表扫描、索引扫描等）
- 优化器将选择最合适的执行计划并将其传递给执行引擎。

**6. 执行引擎（Execution Engine）**

- 执行引擎

  根据生成的执行计划执行 SQL 语句。执行引擎处理不同的 SQL 操作，通常包含以下步骤：

  - **数据检索**：根据执行计划，执行引擎会根据查询类型检索数据。例如，如果查询包含 `SELECT`，则会根据优化计划扫描表，使用索引，或者进行全表扫描。
  - **数据操作**：对于 `INSERT`、`UPDATE`、`DELETE` 等语句，执行引擎会执行相应的 DML 操作，修改数据库中的数据。
  - **事务管理**：如果涉及到事务，执行引擎会按照事务的隔离级别处理锁、提交、回滚等事务操作。

**7. 存储引擎（Storage Engine）**

- **存储引擎**负责实际的数据存取。在 MySQL 中，存储引擎是处理数据存储、数据读取和修改的组件。例如，InnoDB、MyISAM 等存储引擎负责物理存储操作。
- 存储引擎会根据查询计划中的操作类型执行相应的任务：
  - **读取数据**：对于查询语句，存储引擎会扫描数据表、应用索引，或者进行全表扫描，将数据返回给执行引擎。
  - **数据修改**：对于修改操作，存储引擎会在磁盘上实际更新数据，执行 `INSERT`、`UPDATE` 或 `DELETE`，并处理锁和日志。

**8. 缓存和缓冲池**

- **查询缓存（Query Cache）**：如果启用了查询缓存，MySQL 会先检查查询缓存中是否有该查询的结果。如果缓存中存在相同的查询，MySQL 将直接返回缓存结果，避免重新执行查询。
- **缓冲池（Buffer Pool）**：InnoDB 存储引擎使用缓冲池来缓存数据和索引页。如果查询的数据已经在内存中，存储引擎将直接从内存中获取，而无需访问磁盘，提高性能。

**9. 锁管理和并发控制**

- 在执行查询时，MySQL 会根据事务的隔离级别、锁的粒度（行级锁、表级锁等）以及当前的并发环境，管理数据库的锁。**InnoDB 存储引擎**会根据需要对数据进行加锁，以保证数据一致性和事务隔离性。
- 例如，在读取数据时，如果使用了 **共享锁**，其他事务可以读取相同数据，但不能进行修改；而 **排他锁** 会阻止其他事务访问相同的数据。

**10. 返回结果给客户端**

- 查询操作的结果会通过执行引擎和网络层返回给客户端。MySQL 会将查询结果从内部数据格式转换成适合客户端处理的格式（如 JSON、CSV 等），然后将结果集发送回客户端。
- 如果是更新操作（如 `INSERT`、`UPDATE`、`DELETE`），MySQL 会返回一个影响的行数、状态信息等，告知客户端操作是否成功。

**11. 日志和持久化**

- **事务日志**：在执行数据修改时，InnoDB 会记录 **事务日志**，以确保事务的原子性、持久性和一致性。所有修改操作都会先写入日志文件，再根据日志进行数据的实际修改。
- **二进制日志（Binary Log）**：MySQL 还会生成二进制日志，记录所有对数据库进行修改的操作，主要用于数据复制和恢复。

**12. 提交和回滚**

- 如果操作是事务的一部分，执行过程中可能会有 **提交（commit）** 或 **回滚（rollback）**。如果事务提交，所有更改将被永久写入磁盘；如果发生错误或回滚，所有更改将被撤销。

**总结**

一条 SQL 语句在 MySQL 中的执行过程可以分为多个阶段：

1. 客户端发送请求。
2. 连接层验证和管理会话。
3. 解析器解析 SQL 语句，生成解析树。
4. 查询优化器生成执行计划，选择最优执行计划。
5. 执行引擎执行计划，调用存储引擎进行实际操作。
6. 存储引擎完成数据读取或修改，返回结果给执行引擎。
7. 返回结果给客户端，或者如果是写操作，返回影响行数等信息。
8. 日志记录、事务提交或回滚等操作。

通过这些步骤，MySQL 能够有效地处理 SQL 语句并返回正确的结果。



## 6、MySQL的存储引擎有哪些？他们之间有什么区别？

MySQL 提供了多个存储引擎，每种存储引擎有不同的特点和适用场景。存储引擎决定了数据在磁盘上的存储方式、索引的结构、事务的支持以及数据访问的方式。以下是 MySQL 中常见的存储引擎及其区别：

**1. InnoDB**

- 特点：
  - **事务支持**：InnoDB 完全支持事务，具有 **ACID**（原子性、一致性、隔离性、持久性）特性。
  - **行级锁**：InnoDB 提供行级锁，适用于高并发的读写场景。
  - **外键支持**：InnoDB 支持外键约束，保证数据的完整性。
  - **自动恢复**：InnoDB 支持崩溃恢复，通过 **重做日志（redo log）** 和 **回滚日志（undo log）** 实现。
  - **支持多版本并发控制（MVCC）**：通过 MVCC，InnoDB 可以支持 **可重复读** 隔离级别，避免幻读。
  - **存储格式**：使用聚簇索引存储数据，即数据行和主键一起存储在叶子节点中，适合大多数 OLTP（联机事务处理）场景。
- **适用场景**：适用于大多数生产环境，特别是需要支持高并发事务处理、数据一致性和完整性的应用。

**2. MyISAM**

- 特点：
  - **不支持事务**：MyISAM 不支持事务，因此不具备事务的 ACID 特性。
  - **表级锁**：MyISAM 使用表级锁，不支持行级锁。虽然它的表级锁简单高效，但在高并发写入场景下容易成为瓶颈。
  - **高速读写**：对于读取操作较多的场景，MyISAM 的性能通常比 InnoDB 更高，因为表级锁的开销较小。
  - **不支持外键**：MyISAM 不支持外键约束。
  - **压缩支持**：MyISAM 支持压缩表，适用于需要节省存储空间的场景。
  - **存储格式**：使用非聚簇索引存储数据，数据存储在 `.MYD` 文件中，索引存储在 `.MYI` 文件中。
- **适用场景**：适用于读取密集型的应用，或者对数据一致性和事务要求不高的应用，如日志系统、数据仓库等。

**3. MEMORY（HEAP）**

- **特点**：
  - **数据存储在内存中**：MEMORY 存储引擎将数据存储在内存中，因此非常快速。
  - **表级锁**：MEMORY 使用表级锁，适合并发不高的场景。
  - **不持久化数据**：数据存储在内存中，数据库重启后会丢失数据。
  - **支持索引**：MEMORY 支持基于哈希索引（默认）和 B+ 树索引（可以显式指定）进行数据查询。
  - **适用于临时数据存储**：因为数据存在内存中，所以操作非常快速，适用于临时表和会话表等短期存储。
- **适用场景**：适用于需要高性能读写且数据不会长期保存的应用，如会话存储、缓存、临时数据表等。

**4. CSV**

- 特点：
  - **存储格式**：数据以 CSV（逗号分隔值）格式存储在文件中，每行一个记录，每个字段由逗号分隔。
  - **不支持索引**：CSV 存储引擎不支持索引，性能较差。
  - **没有事务**：不支持事务，不能保证数据的一致性和完整性。
- **适用场景**：适用于数据导入导出、快速的数据交换或简单的存储需求，不适合高性能的数据处理。

**5. NDB（Cluster）**

- 特点：
  - **分布式存储**：NDB 存储引擎是 MySQL Cluster 的核心，支持分布式数据库存储，可以在多个节点之间共享数据。
  - **支持高可用性**：NDB 支持数据的高可用性，通过数据分片和冗余备份，实现了高可用性和自动恢复。
  - **支持事务**：NDB 支持事务，保证数据的完整性和一致性。
  - **主键索引**：数据存储使用主键索引，每个表的主键索引将数据分布到不同的节点上。
  - **内存存储**：数据主要存储在内存中，支持非常高的性能，但对于大数据量的持久化有一定挑战。
- **适用场景**：适用于需要高可用性、高并发访问和分布式存储的场景，如电信、金融和大规模分布式系统。

**6. Archive**

- 特点：
  - **专为归档设计**：Archive 存储引擎专为存储大量历史数据、日志数据等设计，具有高压缩性。
  - **只支持插入和查询**：只支持 `INSERT` 和 `SELECT` 操作，更新和删除操作不被支持。
  - **数据压缩**：Archive 表会对数据进行压缩存储，节省存储空间。
  - **不支持索引**：Archive 存储引擎不支持索引，因此对于查询性能有限，尤其是在数据量大的时候。
- **适用场景**：适用于日志存储、历史数据归档等只进行插入和查询、不涉及更新或删除的场景。

**7. Falcon**

- 特点：
  - **事务支持**：Falcon 存储引擎支持事务，但它已经不再是 MySQL 官方的存储引擎（从 MySQL 5.5 版本开始被淘汰）。
  - **高性能写入**：Falcon 存储引擎优化了高并发写入操作，适合需要大量数据写入的场景。
  - **多版本并发控制（MVCC）**：提供了类似于 InnoDB 的多版本并发控制，以避免锁竞争。
- **适用场景**：虽然已经被淘汰，Falcon 原本适用于需要处理大量写操作的应用，但现在 MySQL 官方推荐使用 InnoDB 来替代它。

**8. TokuDB**

- 特点：
  - **压缩存储**：TokuDB 使用 Fractal Tree 索引技术，能够有效地压缩数据，减少存储空间。
  - **高并发支持**：TokuDB 提供了对高并发写入操作的优化，适合处理大量数据插入的应用。
  - **事务支持**：支持事务和 ACID 特性，但相较于 InnoDB，它的写入性能更高。
  - **多版本并发控制（MVCC）**：支持 MVCC 来处理并发事务。
- **适用场景**：适用于写操作密集型应用，尤其是在需要存储大量数据且对存储空间要求较高的场景。

**9. Blackhole**

- 特点：
  - **“黑洞”存储**：所有写入的请求都会丢失（即“黑洞”），不会存储任何数据。
  - **没有数据持久化**：数据不会保存到磁盘中，适用于只做数据复制或日志的场景。
- **适用场景**：适用于数据复制、测试环境或日志记录等场景。

**总结**

| 存储引擎      | 事务支持 | 锁粒度 | 外键支持 | 适用场景                             |
| ------------- | -------- | ------ | -------- | ------------------------------------ |
| **InnoDB**    | 完全支持 | 行级锁 | 支持     | 高并发、高事务一致性要求的应用       |
| **MyISAM**    | 不支持   | 表级锁 | 不支持   | 读多写少的场景，如日志系统、数据仓库 |
| **MEMORY**    | 不支持   | 表级锁 | 不支持   | 高速缓存、临时表等                   |
| **CSV**       | 不支持   | 无锁   | 不支持   | 数据导入导出、简单存储               |
| **NDB**       | 支持     | 行级锁 | 支持     | 分布式数据库、高可用性要求的场景     |
| **Archive**   | 不支持   | 无锁   | 不支持   | 历史数据归档、日志存储               |
| **Falcon**    | 支持     | 行级锁 | 支持     | 高并发写操作（已淘汰）               |
| **TokuDB**    | 支持     | 行级锁 | 支持     | 大数据量、高写入负载的应用           |
| **Blackhole** | 不支持   | 无锁   | 不支持   | 数据复制、日志记录                   |

选择存储引擎时，应该根据应用的具体需求（如事务支持、读写负载、并发性、存储要求等）来进行合理的选择。



## 7、MySQL的索引类型有哪些？

MySQL 支持多种索引类型，不同的索引类型在查询优化、性能和存储结构上各有特点。以下是 MySQL 中常见的索引类型及其简要说明：

**1. 主键索引（Primary Key Index）**

- **定义**：主键索引是特殊的一种唯一索引，用于唯一标识表中的每一行数据。一个表只能有一个主键索引。
- 特点：
  - **唯一性**：主键索引要求索引列的值是唯一的，不允许 `NULL` 值。
  - **聚簇索引**：InnoDB 存储引擎中的主键索引是聚簇索引（Clustered Index）。表中的数据行是按照主键的顺序存储的，因此主键索引的叶子节点存储了实际的数据行。
  - **自动生成**：如果没有显式定义主键，InnoDB 会自动创建一个隐藏的主键索引。
- **适用场景**：通常用于表中的主键列，保证数据的唯一性。

**2. 唯一索引（Unique Index）**

- **定义**：唯一索引要求索引列的值唯一，但允许 `NULL` 值（对于某些存储引擎，如 InnoDB）。唯一索引可以包含一个或多个列。
- 特点：
  - **唯一性**：与主键索引一样，唯一索引保证索引列的值是唯一的，但是允许 `NULL` 值，多个 `NULL` 值是允许的。
  - **非聚簇索引**：在 InnoDB 中，唯一索引通常是非聚簇索引。数据行的存储顺序与索引顺序是分开的。
- **适用场景**：适用于需要保证某列或组合列的唯一性的场景，如邮箱、用户名等。

**3. 普通索引（Index）**

- **定义**：普通索引是 MySQL 中最常见的索引类型，用于提高查询效率。
- 特点：
  - **非唯一性**：普通索引允许索引列有重复值，并没有唯一性要求。
  - **非聚簇索引**：在 InnoDB 存储引擎中，普通索引通常是非聚簇索引，数据行的存储顺序与索引顺序是分开的。
- **适用场景**：适用于那些不要求唯一性，仅仅为了提高查询速度的列。

**4. 全文索引（Fulltext Index）**

- **定义**：全文索引是专门用于 **文本搜索** 的索引类型，适用于对大量文本数据进行查询（例如：在 `TEXT` 或 `VARCHAR` 字段上进行全文搜索）。
- 特点：
  - **全文搜索**：全文索引支持对文本进行更加复杂的搜索，如匹配单词、短语等。支持 `MATCH ... AGAINST` 语法进行全文搜索。
  - **不支持前缀匹配**：全文索引只支持对单词进行匹配，不支持对单个字符的前缀匹配。
  - **存储格式**：在 MySQL 中，全文索引会为每个文档（记录）创建一个倒排索引。
- **适用场景**：适用于需要进行全文搜索的应用，如博客系统、新闻网站等。

**5. 空间索引（Spatial Index）**

- **定义**：空间索引用于处理地理空间数据类型（如 `GEOMETRY`、`POINT`、`LINESTRING` 等）的索引。
- 特点：
  - **地理空间查询**：空间索引专门用于加速与地理位置相关的查询，如范围查询、距离查询等。
  - **基于 R-Tree**：空间索引通常基于 R-Tree 索引结构，这是一种适用于空间数据的树型结构。
  - **仅限于 MyISAM**：MySQL 的空间索引目前只在 MyISAM 存储引擎上可用（虽然在 InnoDB 存储引擎上，空间数据可以创建索引，但支持的操作有限）。
- **适用场景**：适用于地理信息系统（GIS）、地图应用等需要处理空间数据的场景。

**6. 联合索引（Composite Index）**

- **定义**：联合索引是包含多个列的索引，也叫组合索引。联合索引可以提高多个列的查询效率。
- 特点：
  - **索引多个列**：联合索引将多个列作为一个单独的索引进行处理。查询时，MySQL 会使用联合索引来优化那些涉及这些列的查询。
  - **最左前缀原则**：在查询时，联合索引能够加速匹配左侧列的查询。例如，如果创建了 `(a, b, c)` 的联合索引，那么查询 `WHERE a = ? AND b = ?` 可以有效利用该索引，但如果查询条件是 `WHERE b = ?` 或 `WHERE c = ?`，则不能完全利用该索引。
- **适用场景**：适用于需要对多个列进行组合查询的场景，如多条件查询。

**7. 哈希索引（Hash Index）**

- **定义**：哈希索引是基于哈希算法构建的索引类型。它将索引列的值通过哈希函数映射到一个哈希表中。
- 特点：
  - **快速查找**：哈希索引的查找速度非常快，特别是在执行等值查询时，能通过哈希值直接定位数据位置。
  - **不支持范围查询**：由于哈希算法是基于哈希值计算的，哈希索引不适合用于范围查询（如 `BETWEEN`、`>`、`<` 等）。
  - **仅支持 MEMORY 引擎**：MySQL 的哈希索引通常仅适用于 MEMORY 存储引擎。
- **适用场景**：适用于进行等值查询（`=`）的场景，尤其是在内存中存储的数据。

**8. B-Tree 索引（B-Tree Index）**

- **定义**：B-Tree（平衡树）是最常见的索引类型，MySQL 默认的索引类型就是 B-Tree 索引。
- 特点：
  - **有序索引**：B-Tree 索引将数据组织成平衡树形结构，能够实现高效的查找、范围查询和排序操作。
  - **支持范围查询**：B-Tree 索引能够支持范围查询（如 `BETWEEN`、`>`、`<` 等）。
  - **适用于大多数情况**：由于其高效的查找和排序特性，B-Tree 索引广泛应用于大多数 MySQL 存储引擎（如 InnoDB、MyISAM）。
- **适用场景**：适用于绝大多数场景，尤其是需要频繁进行查询、排序和范围查询的场景。

**总结**

| 索引类型        | 主要特点                                                 | 适用场景                      |
| --------------- | -------------------------------------------------------- | ----------------------------- |
| **主键索引**    | 聚簇索引，唯一标识一行数据，数据行按主键顺序存储         | 表的主键列                    |
| **唯一索引**    | 保证唯一性，但允许 `NULL` 值，非聚簇索引                 | 需要唯一性约束的列            |
| **普通索引**    | 无唯一性要求，非聚簇索引                                 | 提高查询效率的常规索引        |
| **全文索引**    | 用于文本搜索，支持 `MATCH ... AGAINST` 查询              | 需要全文搜索的场景            |
| **空间索引**    | 用于空间数据类型（如 `POINT`）的索引，基于 R-Tree        | 地理信息系统（GIS）等空间查询 |
| **联合索引**    | 多列组合索引，使用最左前缀原则                           | 多条件查询                    |
| **哈希索引**    | 基于哈希算法，支持等值查询，但不支持范围查询             | 内存数据库的快速等值查询      |
| **B-Tree 索引** | 平衡树索引，支持排序和范围查询，广泛应用于大多数存储引擎 | 大多数场景，尤其是范围查询    |

每种索引类型都有其特定的应用场景，合理选择和使用索引可以大大提高数据库的查询效率。



## 8、MySQL InnoDB引擎中的聚簇索引和非聚簇索引有什么区别？

在 **MySQL InnoDB** 存储引擎中，**聚簇索引（Clustered Index）** 和 **非聚簇索引（Non-clustered Index）** 是两种常见的索引类型，它们的主要区别在于**数据存储和访问方式**。了解这两种索引的区别对于优化查询性能至关重要。

**1. 聚簇索引（Clustered Index）**

- **定义**：聚簇索引是将 **数据行** 本身存储在索引的叶子节点中，索引的顺序即为数据的存储顺序。也就是说，聚簇索引的 **数据表本身** 是按照索引的顺序组织存储的，数据和索引是 **不可分割的**。
- **特点**：
  - **唯一的**：每个表只能有一个聚簇索引，因为数据行的存储顺序必须唯一，且表中的数据只能有一个顺序。
  - **数据存储**：聚簇索引的叶子节点存储了完整的数据行，也就是说，聚簇索引的键值是数据表的主键，数据行存储的顺序是按主键索引的顺序排列的。
  - **访问速度**：由于数据和索引存储在同一个地方，因此使用主键索引进行查询时可以非常高效，因为查找时可以直接通过索引定位到数据。
  - **更新代价**：更新聚簇索引时，可能需要移动数据行，因为数据行的顺序和索引顺序一致，所以更新涉及到数据行的位置可能会带来额外的性能开销。
- **适用场景**：聚簇索引适用于需要快速查找和排序的数据场景，特别是在通过主键进行大量查询的情况下。
- **示例**：
  - InnoDB 中的 **主键** 索引就是聚簇索引。如果没有显式定义主键，InnoDB 会自动选择一个唯一的非 `NULL` 列作为聚簇索引。
  - 表的数据实际存储是按照 **主键的顺序** 排列的。

**2. 非聚簇索引（Non-clustered Index）**

- **定义**：非聚簇索引将索引结构和实际的数据存储分开，索引的叶子节点不直接存储数据行，而是 **存储指向数据行的指针**（即记录的物理地址）。非聚簇索引的键值与数据行的物理存储顺序无关。
- **特点**：
  - **可以有多个**：一个表可以有多个非聚簇索引，因为数据行的存储顺序不与索引顺序相关，数据的存储顺序和索引顺序是独立的。
  - **索引存储**：非聚簇索引的叶子节点存储的是索引键值和指向数据行的指针。通过索引键值可以查找到数据行，但需要额外的 **回表** 操作来获取数据行。
  - **查询速度**：由于数据和索引是分开的，非聚簇索引的查找通常会比聚簇索引稍慢，尤其是在查询需要通过非主键列进行时，可能需要额外的回表操作来访问数据行。
  - **空间开销**：由于非聚簇索引需要存储指向数据行的指针，因此会占用额外的存储空间。
  - **更新代价**：在更新非聚簇索引时，通常不需要移动数据行，更新的代价比聚簇索引低。
- **适用场景**：非聚簇索引适用于需要对多个列进行快速查询或排序的场景，尤其是当数据表有多个查询条件时。
- **示例**：
  - 如果你在一个表上创建了一个非主键的唯一索引或普通索引（如 `CREATE INDEX`），这将是一个非聚簇索引。
  - 非聚簇索引存储了索引键和值的指针，而不是实际的数据行。

**3. 聚簇索引和非聚簇索引的区别**

| 特性                 | 聚簇索引（Clustered Index）                      | 非聚簇索引（Non-clustered Index）                    |
| -------------------- | ------------------------------------------------ | ---------------------------------------------------- |
| **数据存储位置**     | 数据行和索引存储在一起，叶子节点包含数据行。     | 索引和数据分开，叶子节点包含指向数据行的指针。       |
| **表中索引的数量**   | 每个表只有一个聚簇索引。                         | 每个表可以有多个非聚簇索引。                         |
| **索引类型**         | 主键索引通常是聚簇索引。                         | 可用于任何列的索引。                                 |
| **存储结构**         | 聚簇索引的叶子节点存储完整的数据行。             | 非聚簇索引的叶子节点只存储索引键和指向数据行的指针。 |
| **索引和数据的关系** | 数据存储的顺序和索引顺序一致。                   | 索引和数据存储的顺序不一致。                         |
| **查询速度**         | 查询通过主键索引非常高效，因为数据存储在索引里。 | 查询速度较慢，尤其是需要回表操作的情况。             |
| **更新代价**         | 更新时可能需要移动数据行，代价较高。             | 更新索引时代价较低，因不需要移动数据行。             |
| **空间开销**         | 由于数据存储在索引中，空间开销较小。             | 需要额外存储指向数据行的指针，空间开销较大。         |
| **适用场景**         | 高效的主键查询、范围查询。                       | 多列查询、需要多个索引的场景。                       |

**4. 示例**

假设我们有一个 `users` 表，如下：

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(255),
    email VARCHAR(255),
    age INT
);
```

- **聚簇索引**：InnoDB 存储引擎会使用 `id` 列作为 **主键** 索引，并且表中的数据行会按照 `id` 的顺序存储在磁盘上。主键索引就是聚簇索引，数据行是按照主键的顺序排列的。
- **非聚簇索引**：如果你为 `email` 列创建一个索引：

```sql
CREATE INDEX idx_email ON users(email);
```

这个索引就是非聚簇索引，它会单独存储 `email` 列的索引值，并且叶子节点存储的是指向实际数据行的指针，而不是数据行本身。

**5. 小结**

- **聚簇索引**：将数据和索引存储在一起，表中的数据根据主键的顺序存储，每个表只能有一个聚簇索引。适用于高效的主键查找。
- **非聚簇索引**：索引和数据分开存储，允许多个非聚簇索引。适用于多列查询和需要多个索引的场景，但查询可能需要回表。

通过合理地选择聚簇索引和非聚簇索引，可以大大提升查询性能，尤其是在复杂查询和高并发场景下。



## 9、MySQL中的回表是什么？

**回表**（**Covering index lookup**）是 MySQL 在查询中使用的一个术语，指的是在使用 **非聚簇索引** 时，查询需要通过索引找到数据的 **物理位置**，然后根据该位置去 **数据表** 中再次检索所需的完整数据行的过程。

简而言之，**回表** 是在查询结果未能直接由索引提供的情况下，使用 **索引中的指针** 去访问实际的数据行，从而获取完整的结果。

**1. 回表的基本原理**

当 MySQL 使用 **非聚簇索引**（例如，普通索引、唯一索引、联合索引等）来执行查询时，如果查询的 **所有列** 都可以通过 **索引** 获取到，那么就 **不需要回表**，索引的叶子节点就已经包含了查询所需的所有数据。这种情况称为 **覆盖索引**，查询速度较快，因为不需要回到数据表中查找。

然而，如果查询的列并非全部包含在索引中（例如，索引只包含了部分字段，而查询需要其他字段的值），那么 MySQL 会在索引中找到匹配的记录，并使用 **指向数据行的指针**（即 **row id** 或 **主键**）去数据表中查找实际的数据行，完成最终的查询，这个过程就叫做 **回表**。

**2. 为什么会发生回表？**

回表通常发生在 **非聚簇索引** 上，原因是：

- **非聚簇索引** 存储的是索引键和指向数据行的指针，而不包含完整的数据行。因此，当查询需要的数据列不完全在索引中时，MySQL 必须通过回表操作，从数据表中获取缺失的列。
- **聚簇索引** 不会发生回表，因为数据行本身就是按照主键索引顺序存储的，查询时直接通过聚簇索引就能获取完整的数据行。

**3. 回表的过程**

假设有一个 `users` 表，表结构如下：

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(255),
    email VARCHAR(255),
    age INT
);
```

假设我们创建了一个非聚簇索引在 `email` 字段上：

```sql
CREATE INDEX idx_email ON users(email);
```

接下来，如果我们执行以下查询：

```sql
SELECT username, email FROM users WHERE email = 'user@example.com';
```

MySQL 会使用 `idx_email` 索引来查找满足 `email = 'user@example.com'` 的行。此时，`idx_email` 索引只包含 `email` 字段和指向数据行的指针（通常是 `id` 字段或主键）。

- **步骤 1**：MySQL 查找 `email` 为 `'user@example.com'` 的记录，找到了相关的索引条目。
- **步骤 2**：由于 `idx_email` 索引只包含 `email` 字段，查询要求返回 `username` 和 `email`，因此 MySQL 会通过索引中的指针（例如 `id` 或 `row_id`）去 **回表** 查询完整的 `username` 和 `email` 字段的值。

**4. 回表的性能影响**

回表会引入额外的 I/O 操作，因为每次回表时都需要去 **实际数据表** 查找缺失的字段。这意味着：

- 回表会比直接从索引获取数据的操作慢，尤其是在 **大数据量** 或者 **高并发查询** 的情况下。
- 查询的性能会受到影响，因为回表需要额外的磁盘读取，特别是当数据表很大或查询字段较多时。

**5. 避免回表的优化方法**

为了避免回表并提升查询性能，可以考虑以下优化方法：

**5.1 使用 覆盖索引（Covering Index）**

- **覆盖索引** 是指查询中所需的所有列都包含在索引的叶子节点中。这样，查询可以直接从索引中获取结果，而不需要回表。

例如，修改上述查询，只需要 `email` 和 `username`，可以创建一个覆盖这两个字段的联合索引：

```sql
CREATE INDEX idx_email_username ON users(email, username);
```

这样，当执行查询时，MySQL 可以直接使用 `idx_email_username` 索引返回结果，而不需要回表。

**5.2 使用 选择合适的索引：**

- 根据查询的字段选择合适的索引，确保索引包含所有查询所需的字段，这样就能避免回表。

**5.3 避免在查询中使用 SELECT ：**

- 尽量避免使用 `SELECT *`，因为这样会查询所有列，MySQL 可能需要回表来获取未包含在索引中的列。如果只查询需要的列，可以减少回表的发生。

**6. 回表的示例**

假设 `users` 表的数据如下：

| id   | username | email                                         | age  |
| ---- | -------- | --------------------------------------------- | ---- |
| 1    | user1    | [user1@example.com](mailto:user1@example.com) | 25   |
| 2    | user2    | [user2@example.com](mailto:user2@example.com) | 30   |
| 3    | user3    | [user3@example.com](mailto:user3@example.com) | 22   |

以及我们有如下的非聚簇索引：

```sql
CREATE INDEX idx_email ON users(email);
```

执行以下查询：

```sql
SELECT username FROM users WHERE email = 'user2@example.com';
```

MySQL 的执行过程如下：

- **查找索引**：MySQL 使用 `idx_email` 索引，找到 `email = 'user2@example.com'` 的索引条目，并取得其指向的数据行的指针（`id = 2`）。
- **回表查询**：由于查询只需要 `username`，而索引只包含了 `email` 字段，MySQL 必须回表去 `users` 表中查找 `id = 2` 对应的 `username` 字段。
- **返回结果**：返回 `username = 'user2'`。

**7. 总结**

- **回表** 是指使用索引查找数据时，如果索引中不包含查询所需的所有字段，就需要使用索引的指针去数据表中查找实际的数据行。
- **回表** 会增加额外的 I/O 操作，可能会影响查询性能。
- **覆盖索引** 可以避免回表，提升查询性能。



## 10、MySQL索引的最左前缀匹配原则是什么？

MySQL 索引的 **最左前缀匹配原则**（也叫 **最左匹配原则**）是指在查询条件中，如果使用了多个字段组成的复合索引，那么查询时必须从复合索引的最左侧开始匹配，并且要按照索引字段的顺序来使用这些字段。也就是说，查询条件中只能依次使用复合索引的左侧字段，不能跳过某个字段或者改变顺序。

**原则：**

1. **从左到右的顺序匹配：** 查询条件必须从复合索引的最左侧字段开始，依次匹配，不能跳过任何字段。
2. **可以匹配索引的前缀：** 如果查询条件只涉及复合索引的前几个字段，那么也能利用该复合索引。
3. **不能反向匹配：** 查询条件中的字段顺序不能和索引字段顺序不一致或跳过字段。

**举个例子：**

假设有一个复合索引 `(a, b, c)`，那么以下的查询条件会使用该索引：

- `WHERE a = ? AND b = ? AND c = ?`  （完全符合最左前缀匹配）
- `WHERE a = ? AND b = ?`           （符合前两个字段，可以使用索引）
- `WHERE a = ?`                     （仅使用第一个字段，也能使用索引）
- `WHERE b = ? AND c = ?`           （无法使用索引，因为没有从最左侧字段 `a` 开始匹配）

**不能使用的情况：**

- `WHERE b = ?` （跳过了 `a`，不能使用索引）
- `WHERE c = ?` （跳过了 `a` 和 `b`，不能使用索引）

**特殊注意：**

1. 范围查询：如果在查询中使用了范围查询（例如`>`、`<`、`BETWEEN`等），那么在范围查询字段后面的字段将不会被利用（即索引不再从该字段继续匹配）。例如：
   - `WHERE a = ? AND b > ?` （可以使用索引，但只有 `a` 会被使用，`b` 不会被使用）
2. LIKE 查询：对于前缀匹配的`LIKE`查询，索引也可以被使用，但要求`LIKE`必须是从字段的最左侧开始匹配的。例如：
   - `WHERE a LIKE 'abc%'` 可以使用 `(a)` 索引。
   - `WHERE a LIKE '%abc'` 就无法使用 `(a)` 索引。

了解这个原则后，我们可以通过合理设计索引来优化查询性能，避免不必要的全表扫描。



## 11、MySQL的覆盖索引是什么？

MySQL 的 **覆盖索引**（Covering Index）是指在查询时，所需要的所有数据（字段）都能够通过索引直接获取，而**不需要回表**（访问数据表中的实际数据行）。换句话说，**覆盖索引**是一个能够“覆盖”查询字段的索引，查询过程中不需要读取表中的数据行，直接从索引中获取所有的需要的数据。

**覆盖索引的特点：**

1. **索引包含了查询所需要的所有字段：** 查询的字段要么是索引的一部分，要么完全由索引提供。
2. **不需要回表：** 当查询的字段都可以通过索引获得时，就不需要再去访问原始数据表。这大大减少了I/O操作，提高了查询性能。
3. **仅需索引查找：** 查询操作中所有必要的数据都存在于索引结构中（例如 B+ 树），因此直接通过索引就可以完成查询。

**覆盖索引的应用场景：**

覆盖索引通常应用于那些只需要返回少量字段的查询，尤其是在：

- 查询涉及的字段都在索引中（包括选择条件、返回字段、排序字段等）。
- 查询只涉及几个字段，能够利用复合索引覆盖所有字段。

**举个例子：**

假设有一个表 `users`，其结构如下：

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    age INT,
    email VARCHAR(100)
);
```

如果创建了以下复合索引：

```sql
CREATE INDEX idx_name_age ON users(name, age);
```

现在，执行以下查询：

```sql
SELECT name, age FROM users WHERE name = 'John' AND age = 30;
```

这个查询可以完全通过 `idx_name_age` 索引来完成，因为：

- 查询条件中的 `name` 和 `age` 都在索引 `idx_name_age` 中。
- 查询返回的字段 `name` 和 `age` 也在索引中。 因此，这个查询使用了 **覆盖索引**，无需回表。

**覆盖索引的优势：**

1. **提高查询性能：** 由于可以直接从索引中获取数据，避免了回表操作，减少了 I/O。
2. **节省资源：** 查询不需要访问表数据行，减少了磁盘访问的频率，从而节省了 CPU 和 I/O 资源。

**不适用的场景：**

1. **查询返回的字段不在索引中：** 如果查询的字段不在索引中，索引就不能覆盖该查询，仍然需要回表。
2. **涉及的查询字段过多：** 如果查询涉及的字段过多，可能需要多个索引来覆盖查询，导致性能反而下降。

**如何判断是否使用了覆盖索引？**

可以通过 `EXPLAIN` 来检查查询是否使用了覆盖索引。在执行查询时，MySQL 会显示查询执行计划，标记是否是覆盖索引。例如：

```sql
EXPLAIN SELECT name, age FROM users WHERE name = 'John' AND age = 30;
```

如果查询计划显示 `Using index`，则表示使用了覆盖索引。

**总结：**

覆盖索引是优化 MySQL 查询性能的重要手段之一，它通过将查询所需的数据包含在索引中，避免了回表操作，从而提升了查询效率。在设计数据库和索引时，合理利用覆盖索引可以大大提高查询性能，尤其是在只需要部分字段的查询中。



## 12、MySQL的索引下推是什么？

**MySQL 索引下推（Index Condition Pushdown，简称 ICP）** 是 MySQL 在执行查询时的一种优化技术。它允许 MySQL 将查询中的某些条件 **提前**（即下推）到存储引擎层（如 InnoDB）进行筛选，而不是将这些条件全部交给 SQL 引擎处理。

**1. 什么是索引下推？**

索引下推的基本原理是：当我们在查询中使用索引时，MySQL 会将查询条件分为两部分：

- 一部分是索引可以直接使用的条件。
- 另一部分是不能通过索引处理的条件。

通过索引下推，MySQL 将能在索引查找阶段就尽可能多地过滤掉不符合条件的记录，而不是等到回表后再进行过滤。

这样可以减少回表的次数和数据量，提高查询效率，特别是在复合索引的情况下。

**2. 如何工作：**

在没有索引下推的情况下，MySQL 会先用索引查找符合条件的记录（通过索引的查找），然后再回表获取剩余的列，并对其他的过滤条件（如 `WHERE` 子句中不在索引中的条件）进行进一步筛选。

而索引下推技术则允许 MySQL 在使用索引查找的同时，将 `WHERE` 子句中的某些条件直接传递给存储引擎（如 InnoDB），从而在查找过程中就可以对数据进行筛选。

**3. 示例：**

假设我们有以下表和索引：

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    age INT,
    gender VARCHAR(10)
);

CREATE INDEX idx_name_age ON users(name, age);
```

然后执行如下查询：

```sql
SELECT id, name, age 
FROM users
WHERE name = 'Alice' AND age > 25 AND gender = 'F';
```

如果开启了 **索引下推**，MySQL 会将 `name = 'Alice'` 和 `age > 25` 的条件下推到存储引擎中，这样存储引擎在用 `idx_name_age` 索引查找记录时，就能同时根据 `name` 和 `age` 进行过滤。在查找到符合条件的记录后，MySQL 只需回表查找 `gender`，然后根据 `gender = 'F'` 进一步过滤。

**4. 索引下推的优化效果：**

- **减少回表次数：** 如果能够在索引查找阶段过滤更多的记录，就减少了回表的次数。
- **降低 I/O 开销：** 由于在存储引擎层进行更早的筛选，查询不需要检索不符合条件的数据行，从而减少了 I/O 负担。
- **提升查询性能：** 尤其在查询涉及多个条件时，索引下推能够提高查询性能。

**5. 什么时候索引下推会生效？**

- **复合索引**：索引下推通常在使用复合索引时效果更好，因为复合索引可以利用多个列的条件进行过滤。如果查询中涉及到复合索引的多个列，索引下推能够将多个条件下推到存储引擎。
- **多列条件的查询**：如果查询中的 `WHERE` 子句包含多个字段的条件（例如使用复合索引），并且存储引擎支持索引下推，MySQL 会自动将部分过滤条件下推到存储引擎。

**6. 启用和禁用索引下推：**

从 MySQL 5.6 开始，索引下推默认是启用的。你可以通过查询 `EXPLAIN` 输出或查看查询执行计划来确认是否使用了索引下推。

你可以通过 `optimizer_switch` 系统变量控制索引下推的行为：

```sql
SET optimizer_switch='index_condition_pushdown=off';  -- 禁用索引下推
SET optimizer_switch='index_condition_pushdown=on';   -- 启用索引下推
```

**7. 例子：**

假设有一个表 `orders`，其结构如下：

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    user_id INT,
    status VARCHAR(10),
    total DECIMAL(10, 2)
);

CREATE INDEX idx_user_status ON orders(user_id, status);
```

如果执行如下查询：

```sql
SELECT * FROM orders WHERE user_id = 123 AND status = 'shipped' AND total > 100;
```

MySQL 会使用 `idx_user_status` 索引来查找 `user_id = 123` 和 `status = 'shipped'` 的记录，并且会将 `total > 100` 的条件下推到存储引擎中，这样只有符合这两个条件的数据才会返回，减少了回表的必要性。

**8. 总结：**

索引下推是 MySQL 在查询优化中的一种重要技术，它能够让查询在执行时尽可能地提前筛选数据，减少不必要的回表和 I/O 操作，从而提高查询性能。它主要适用于使用复合索引的查询，尤其是当查询条件中有多个字段时。通过合理地利用索引下推，可以显著提升查询效率，特别是在大数据量的情况下。



## 13、在MySQL中使用索引一定有效吗？如何排查索引效果？

在 MySQL 中，**使用索引并不一定总是有效**，即便你为某些列创建了索引，也不意味着查询就一定能从中获益。MySQL 在查询优化时会根据多种因素决定是否使用索引，以及如何使用索引。

**1. 为什么索引可能不被使用？**

以下是一些常见的原因，导致索引未被使用或未能有效提升查询性能：

1.1 **查询条件不适合索引：**

- 没有涉及索引列：如果查询条件没有涉及到索引列，索引自然不会被使用。

  ```sql
  SELECT * FROM users WHERE gender = 'M';  -- 如果没有索引在 gender 列上，查询就不会使用索引
  ```

- 使用了不适合索引的操作：某些查询操作，如 `LIKE`开头带 `%`的查询、`OR`或函数计算等，可能会导致索引无法生效。

  ```sql
  SELECT * FROM users WHERE name LIKE '%john%';  -- 无法使用索引，除非是前缀匹配 LIKE 'john%'
  ```

  ```sql
  SELECT * FROM users WHERE YEAR(created_at) = 2021;  -- 如果在索引列上应用了函数（例如 YEAR），索引就无法使用
  ```

1.2 **索引选择性差：**

如果某列的索引选择性差（即该列的值重复率很高），MySQL 可能会认为使用索引反而比全表扫描更低效。例如，性别字段 `gender` 只有 `'M'` 和 `'F'` 两个值，而有很大一部分记录的 `gender` 值是 `'M'`，那么 MySQL 就可能选择直接进行全表扫描。

```sql
CREATE INDEX idx_gender ON users(gender);  -- 性别字段索引的选择性较低，可能不会用索引
```

1.3 **表的大小：**

对于小表来说，索引可能没有什么明显的性能提升。MySQL 会自动判断，对于小表，使用全表扫描可能反而更高效。

1.4 **索引的维护成本：**

当表中的数据频繁变化（如大量的 `INSERT`、`UPDATE`、`DELETE` 操作），索引的维护成本会较高。在某些情况下，MySQL 可能会放弃使用某些索引，以降低维护索引的开销。

1.5 **不合适的索引类型或索引顺序：**

- 使用了错误的索引类型（如 B-Tree 索引）来处理范围查询或唯一值查询时，可能导致索引不被使用。
- 在复合索引中，索引字段的顺序不正确也会导致无法利用该索引，必须遵循 **最左前缀原则**。

1.6 **强制全表扫描：**

你可以通过 `FORCE INDEX` 强制 MySQL 使用某个特定的索引。如果 MySQL 选择不使用索引，强制索引可能会导致性能下降，因此不建议轻易使用：

```sql
SELECT * FROM users FORCE INDEX (idx_gender) WHERE gender = 'M';
```

------

2. **如何排查索引是否生效？**

你可以使用 **`EXPLAIN`** 语句来查看 MySQL 查询执行计划，进而分析索引是否被有效使用。`EXPLAIN` 会提供关于查询的执行计划信息，包括是否使用了索引、使用了哪个索引等。

2.1 **使用 `EXPLAIN` 查看执行计划**

执行查询时，在查询前加上 `EXPLAIN`：

```sql
EXPLAIN SELECT * FROM users WHERE name = 'Alice' AND age > 25;
```

`EXPLAIN` 输出的字段包含：

- **id**：查询的顺序（如果是联合查询，可能有多个 id）。
- **select_type**：查询类型（例如 `SIMPLE`、`PRIMARY`、`UNION` 等）。
- **table**：查询涉及的表。
- **type**：连接类型（`ALL` 表示全表扫描，`range`、`ref`、`eq_ref` 等表示使用了索引）。
- **possible_keys**：可能使用的索引。
- **key**：实际使用的索引（如果没有使用索引，这里会显示 `NULL`）。
- **key_len**：使用索引时，索引长度（字节数）。
- **ref**：显示与索引匹配的列。
- **rows**：扫描的行数。
- **Extra**：额外的执行信息，例如 `Using where`、`Using index`、`Using temporary` 等。

2.2 **示例分析**

假设我们有一个查询：

```sql
EXPLAIN SELECT id, name FROM users WHERE age > 30;
```

可能的 `EXPLAIN` 输出：

```pgsql
+----+-------------+-------+-------+-------------------+---------+---------+------+--------+----------------------+
| id | select_type | table | type  | possible_keys     | key     | key_len | ref  | rows   | Extra                |
+----+-------------+-------+-------+-------------------+---------+---------+------+--------+----------------------+
|  1 | SIMPLE      | users | range | idx_age           | idx_age | 4       | NULL | 1000   | Using where; Using index |
+----+-------------+-------+-------+-------------------+---------+---------+------+--------+----------------------+
```

在这个例子中：

- `type` 为 `range`，表示 MySQL 使用了索引。
- `possible_keys` 列显示了可能使用的索引 `idx_age`。
- `key` 列显示实际使用的索引 `idx_age`。
- `Extra` 列显示了 `Using where` 和 `Using index`，说明索引有效，并且查询过程中没有回表。

2.3 **如何解读执行计划？**

- **`type`**：是最关键的字段之一，显示了查询时使用的连接类型。`ALL` 表示全表扫描（没有使用索引），而 `range`、`ref` 等表示已经使用了索引。通常来说，`ALL` 是性能最差的，越往下的类型（`eq_ref`、`ref`、`range`）越优。
- **`key`**：显示了实际使用的索引。如果这里显示 `NULL`，说明没有使用索引。
- **`Extra`**：如果显示 `Using index`，表示查询完全通过索引完成，没有回表；如果显示 `Using where`，表示索引仅用于过滤，但可能还需要回表。

------

3. **如何提高索引效果？**

- **优化查询条件：** 确保查询条件涉及的列有索引，并且遵循最左前缀原则。
- **避免全表扫描：** 确保查询能够利用合适的索引，避免 `ALL` 类型的扫描。
- **检查索引的选择性：** 如果某个索引的选择性较低，可能需要重新评估是否使用该索引。
- **使用合适的索引：** 根据查询的特点选择合适的索引（单列索引、复合索引等）。
- **避免对索引列进行函数操作：** 如果对索引列使用了函数（例如 `YEAR(date_column)`），索引无法被有效利用，尽量避免。

通过合理的索引设计、查询优化和使用 `EXPLAIN` 工具检查查询计划，可以有效排查索引是否被正确使用，并确保查询的性能达到最优。



## 14、MySQL中的索引数量是否越多越好？为什么？

在 MySQL 中，**索引的数量并非越多越好**，实际上，索引过多可能会导致性能下降，甚至对数据库的整体效率产生负面影响。合理设计和使用索引是优化 MySQL 查询性能的关键。下面是一些关于索引数量及其影响的详细分析。

**1. 索引的优势：**

索引的主要优势是加速查询。对于经常用于查询条件（`WHERE`）、排序（`ORDER BY`）、分组（`GROUP BY`）和连接（`JOIN`）操作的列，创建索引可以大大提高查询性能。

**2. 索引过多的负面影响：**

2.1 **影响写操作性能：**

每当进行 `INSERT`、`UPDATE` 或 `DELETE` 操作时，MySQL 都需要更新相关索引。索引越多，更新和插入操作的开销就越大。因为每次写入数据时，MySQL 需要确保索引的数据结构是最新的，这会增加写操作的成本。

- **`INSERT` 操作**：在插入数据时，所有相关的索引都需要更新，导致插入速度变慢。
- **`UPDATE` 操作**：当更新索引列时，索引不仅需要更新，还可能需要重新排序。
- **`DELETE` 操作**：删除数据时，索引中对应的记录也需要删除。

2.2 **占用更多存储空间：**

每个索引都需要占用磁盘空间，尤其是复合索引和大型表的索引，可能会导致数据库的磁盘使用量大幅增加。索引越多，占用的存储空间就越大，这对于存储成本是一个不小的负担。

2.3 **维护成本：**

随着索引数量的增加，数据库的维护成本也会增加。MySQL 在执行查询时需要评估多个索引，并选择最优的索引，这可能导致额外的开销。尤其是在大规模数据库中，频繁创建、删除和修改索引会带来额外的管理复杂度。

2.4 **查询优化器的选择问题：**

如果创建了大量的索引，MySQL 的查询优化器在选择执行计划时可能会变得更加复杂。它可能会花费更多时间在决定使用哪个索引上，甚至有可能选择了一个不合适的索引，从而导致查询性能不佳。

------

**3. 如何平衡索引数量：**

3.1 **遵循合理的索引设计原则：**

- **优先为频繁查询的列创建索引**：通常为 `WHERE` 子句、`JOIN` 操作、`ORDER BY` 和 `GROUP BY` 子句中常用的列创建索引。复合索引在多个列经常同时出现在查询条件中的情况下，通常会比单列索引更有效。
- **避免创建重复的索引**：如果你已经有了一个复合索引 `idx_name_age`（包括 `name` 和 `age`），那么再单独为 `name` 或 `age` 创建单列索引可能是多余的。因为复合索引已经能处理这两列的查询。
- **不对低选择性的列创建索引**：低选择性（例如 `gender` 列只有两个值 `M` 和 `F`）的列索引通常效果较差，可能导致查询性能不如全表扫描。

3.2 **使用 `EXPLAIN` 进行查询分析：**

使用 `EXPLAIN` 来分析查询执行计划，确定哪些索引被实际使用，哪些是冗余的。如果某些索引在查询中没有被使用，可以考虑删除它们。

```sql
EXPLAIN SELECT * FROM users WHERE age > 30;
```

通过 `EXPLAIN` 查看查询计划，检查是否有不必要的索引没有被使用，或者存在重复的索引。

3.3 **索引合并与覆盖索引：**

- **索引合并**：在某些情况下，多个单列索引可以被合并为复合索引，提高查询效率。比如，如果有 `idx_name` 和 `idx_age` 两个单列索引，而查询经常是 `WHERE name = ? AND age = ?`，那么可以考虑创建一个复合索引 `(name, age)`。
- **覆盖索引**：设计复合索引时，考虑将查询中所有需要的字段都包含在索引中，这样查询可以通过索引直接返回结果，避免回表，提高查询性能。

3.4 **定期检查和优化索引：**

随着数据量的增加和查询模式的变化，数据库中的某些索引可能变得不再有效或不再必要。定期检查索引的使用情况，并根据查询性能来调整索引。

- 删除不常用或冗余的索引。
- 对于低选择性的列或不常用的列，考虑减少索引的使用。
- 考虑使用部分索引（例如前缀索引）来减小索引的存储开销。

------

**4. 总结：**

- **索引数量不等于查询性能**：虽然索引能够加速查询，但过多的索引会影响写操作、占用存储空间，并且增加管理复杂度。
- **合理使用索引**：根据查询需求和表结构合理设计索引，不要为了创建更多的索引而创建索引，而是要考虑查询的实际需求。
- **定期优化**：使用 `EXPLAIN` 来分析查询的执行计划，删除冗余或不必要的索引，优化数据库性能。

总的来说，索引的数量应该根据实际应用场景来设计，尽量避免过多的索引，尤其是当它们无法有效提高查询性能时。合理的索引设计可以显著提高查询效率，而过多无用的索引会反而降低系统的整体性能。



## 15、请详细描述MySQL的B＋树中查询数据的全过程。

MySQL 中的 **B+ 树（B+ Tree）** 是一种自平衡的树形数据结构，广泛用于数据库索引的实现，尤其是 InnoDB 存储引擎。B+ 树是 **B 树** 的一种变体，支持高效的插入、删除和查找操作，并且特别适合于范围查询和顺序访问。

在 B+ 树中，所有数据（即实际的表记录）都存储在 **叶子节点**，而非叶子节点则只作为索引作用。B+ 树的结构使得查询数据时可以通过高效的路径查找，逐步缩小搜索范围。

**B+ 树查询数据的全过程：**

1. **B+ 树的基本结构**

- **根节点**：B+ 树的顶层节点，包含指向子节点的指针。
- **内部节点（非叶子节点）**：包含指向子节点的指针，存储索引键，但不存储实际的数据。
- **叶子节点**：包含实际的索引数据或数据指针（对于聚簇索引，数据存储在叶子节点中）。所有叶子节点通过链表连接，方便范围查询。

2. **查询数据的过程**

假设我们有一个表 `users`，并为 `id` 列创建了 B+ 树索引。查询语句如下：

```sql
SELECT * FROM users WHERE id = 100;
```

B+ 树的查询过程可以分为以下几个步骤：

------

**2.1 从根节点开始查找**

- **根节点**存储了一个范围的键值（分割点），并且指向相应的子节点。查询会首先从根节点开始，检查查询的键值与根节点中的键值进行比较。
- **查找目标键**：对于查询 `id = 100`，我们会比较 `100` 和根节点中的键值。如果根节点的键值小于 `100`，则根据指向的子节点继续向下查找。

**2.2 遍历内部节点**

- 在 B+ 树中，每个非叶子节点只存储键值和指向子节点的指针。查询时，通过不断在每一层的内部节点上与目标值进行比较，逐渐向下找到目标数据所在的叶子节点。
- **按顺序查找**：每个内部节点都有多个子节点，每个子节点指向比当前节点小或大的数据范围。因此，在查询过程中，会根据目标值 `100` 比较根节点或内部节点中的键值，判断目标值位于哪个子树，然后进入该子树继续查找。

**2.3 到达叶子节点**

- **叶子节点**存储了实际的数据记录（或者是指向数据行的指针，具体取决于索引类型）。当查询目标键值到达叶子节点时，我们就找到了目标数据。
- **叶子节点顺序**：B+ 树的叶子节点通过链表相连，确保能够进行高效的顺序扫描和范围查询。例如，在执行 `SELECT * FROM users WHERE id BETWEEN 100 AND 200;` 查询时，MySQL 可以通过叶子节点之间的链表连接快速地按顺序扫描符合条件的记录。

**2.4 数据返回**

- 对于 **聚簇索引（Clustered Index）**，叶子节点不仅包含索引值，还存储实际的表数据行。当查询通过叶子节点找到目标索引值后，直接返回数据行。
- 对于 **非聚簇索引（Non-clustered Index）**，叶子节点只存储索引值和数据的 **行指针**（即指向表中实际数据的位置）。查询时，MySQL 需要通过这个行指针回到数据表中查找实际的记录。

------

**3. 查询的时间复杂度分析**

B+ 树的查询时间复杂度是 **O(log N)**，其中 `N` 是索引中的数据条目数。每经过一层节点，索引的范围就会减少一半，因此查找的时间随着树的高度对数增长。

- 假设 B+ 树的阶为 `m`，则树的高度为 `log_m(N)`，查找操作的时间复杂度为 `O(log_m N)`。
- B+ 树的平衡性使得查询操作可以在较短的时间内完成。

------

**4. 示例：**

假设我们有一个 `users` 表，包含以下数据：

| id   | name    |
| ---- | ------- |
| 1    | Alice   |
| 2    | Bob     |
| 3    | Charlie |
| 4    | David   |
| 5    | Eve     |

并为 `id` 列创建了 B+ 树索引。B+ 树的索引结构大致如下：

```
Root Node
  |
  +-- 2
  |    |
  |    +-- [1] Alice
  |    +-- [2] Bob
  |    +-- [3] Charlie
  |    +-- [4] David
  |    +-- [5] Eve
```

假设查询如下：

```sql
SELECT * FROM users WHERE id = 3;
```

- 查询开始时，我们从 **根节点**开始，根节点只有一个键值 `2`，目标值 `3` 大于 `2`，因此我们进入右子树。
- 然后进入到 **叶子节点**，叶子节点包含了所有的键值 `[1, 2, 3, 4, 5]`，以及指向实际记录的指针。
- 找到键值 `3`，然后根据该指针回表获取对应的记录 `Charlie`。

**5. B+ 树的优点：**

- **高效的查询性能**：由于 B+ 树具有高度平衡的结构，查询时能快速定位到目标数据，尤其适合范围查询。
- **顺序访问优化**：B+ 树的叶子节点通过链表连接，支持高效的范围查询（例如 `BETWEEN`、`>`, `<` 等操作），可以快速返回一段连续的数据。
- **聚簇索引的优势**：在聚簇索引中，数据存储在叶子节点，因此无需回表，查询速度非常快。

**6. 总结：**

B+ 树的查询过程依赖于其结构的平衡性，通过从根节点到叶子节点的路径查找，能够高效定位目标数据。通过比较键值和使用子节点指针，B+ 树支持快速的查找、范围查询以及顺序访问等操作。其平衡的特性使得查询时间复杂度始终保持在对数级别 `O(log N)`，而叶子节点的链表结构则使得范围查询和顺序扫描更加高效。



## 16、为什么MySQL选择使用B+ 树作为索引结构？

MySQL 选择使用 **B+ 树** 作为默认索引结构，主要是因为它能够在多个层面上提供高效的性能，特别是在 **查询优化** 和 **存储管理** 上。B+ 树的特点和优势使它成为数据库系统，尤其是 MySQL 存储引擎（如 InnoDB）默认使用的索引结构。

**1. B+ 树的特点**

在理解为什么 MySQL 选择 B+ 树之前，我们先简要回顾一下 B+ 树的基本特点：

- **自平衡**：B+ 树是自平衡的树结构。无论插入或删除了多少数据，B+ 树都会保持平衡，保证查询时可以在对数时间内完成。
- **节点存储键值**：B+ 树的 **非叶子节点** 只存储键值，用于导航查询路径，而 **叶子节点** 才存储实际的数据或数据的指针。
- **有序结构**：B+ 树的所有叶子节点都通过指针相连，形成一个有序链表，便于快速进行范围查询和顺序扫描。
- **高效的范围查询**：叶子节点通过指针按顺序连接，使得范围查询（例如 `BETWEEN` 或 `>`, `<` 查询）可以通过顺序访问叶子节点非常高效。
- **查询性能稳定**：由于树的高度保持平衡，查询的时间复杂度为 O(log N)，且性能稳定，尤其适合大数据量的场景。

**2. 为什么 MySQL 选择 B+ 树作为索引结构**

2.1 **高效的查询操作**

B+ 树通过其自平衡结构，能够在 **O(log N)** 的时间复杂度内定位到数据的位置。查询时，从根节点开始通过比较键值逐层下到叶子节点，因此即使数据库的规模非常大，查询时间也不会因为数据量增加而线性增长。

- **查找操作**：B+ 树的每一次查找操作，都通过树的层级结构逐步缩小搜索范围，减少了每次查询所需的时间，特别适合于需要快速查找单个值的场景（例如 `WHERE` 子句中的条件查询）。

2.2 **支持高效的范围查询**

B+ 树的 **叶子节点通过指针连接**，这使得在执行范围查询时，MySQL 可以在找到符合条件的第一个叶子节点后，顺序扫描叶子节点，直接返回一系列结果。因此，对于像 `BETWEEN` 或者 `>`, `<` 之类的范围查询，B+ 树比其他数据结构更高效。

- **范围查询**：比如 `SELECT * FROM users WHERE id BETWEEN 100 AND 200`，B+ 树能够通过叶子节点的链表快速地按顺序返回符合条件的所有记录，而无需重新扫描整个索引。

2.3 **避免重复数据的存储**

在 B+ 树中，所有数据都存储在 **叶子节点**，而非叶子节点仅存储索引值。非叶子节点只起到引导作用，指向更低层次的节点。因为只有叶子节点存储数据，它们实际上不会被重复存储。相比其他结构（如 B 树），B+ 树节省了存储空间。

- **避免冗余数据存储**：在 B 树中，每个节点既存储键值，又存储实际数据，因此有可能会导致冗余存储。而 B+ 树只存储索引信息，数据集中存储在叶子节点，减少了不必要的冗余。

2.4 **支持高效的顺序访问**

B+ 树中，叶子节点按顺序链接在一起，使得顺序遍历非常高效。这对于一些需要遍历大量数据或按顺序处理数据的查询非常有用。

- **顺序访问**：例如，执行 `ORDER BY` 查询时，B+ 树通过叶子节点之间的指针链表，能够在 O(log N) 的查询时间内快速定位到数据的起始位置，并顺序返回数据。

2.5 **良好的磁盘 I/O 性能**

B+ 树的节点设计较为紧凑，树的高度较低，每个节点存储多个键值，通常占用较大的磁盘页。在访问磁盘时，可以通过一次磁盘 I/O 操作加载更多的索引信息，从而减少磁盘的访问次数。

- **降低磁盘 I/O**：B+ 树通过减少磁盘的访问次数和增大单次 I/O 读取的数据量，提高了磁盘 I/O 性能。对于大规模数据库，磁盘访问延迟往往成为性能瓶颈，B+ 树的结构使得数据库能够高效地进行磁盘读取。

2.6 **适合动态数据集**

B+ 树的结构可以动态地增长和收缩，这使得它非常适合处理动态数据集（例如频繁进行插入和删除操作的数据库）。

- **高效的插入和删除操作**：B+ 树能在对数时间内插入或删除节点，同时保持平衡。这是因为 B+ 树插入和删除操作会自适应地调整树的高度或合并/分裂节点，保证查询效率。

2.7 **支持多种类型的查询**

B+ 树不仅支持等值查询（`=`），还支持范围查询（`>`, `<`, `BETWEEN`），因此它能满足各种查询的需求，适应多种使用场景。

- **多样化查询**：B+ 树能够高效处理多种查询类型，确保数据库能在不同的查询模式下优化查询性能。

------

**3. 与其他索引结构的对比**

虽然 B+ 树是 MySQL 默认使用的索引结构，但在某些情况下，其他类型的索引结构也有其特定的优势。

3.1 **哈希索引**

哈希索引在等值查询（`=`）时具有非常高的性能，因为它可以通过哈希值直接定位到数据。但哈希索引不支持范围查询（如 `BETWEEN` 或 `>`），而 B+ 树则非常适合范围查询。

- **哈希索引**：适用于仅包含等值查询的场景，但对于范围查询无法发挥优势。
- **B+ 树**：支持等值查询、范围查询、顺序扫描，因此更为通用，尤其适合于需要复杂查询的数据库系统。

3.2 **全文索引（Fulltext Index）**

全文索引用于支持文本匹配查询（如 `MATCH ... AGAINST`），它使用倒排索引来加速全文搜索。与 B+ 树不同，倒排索引适用于需要快速检索包含特定词汇的文本数据。

- **倒排索引**：适用于文本数据的查找，而 B+ 树适用于其他常见的字段类型（如整数、日期等）。

------

**4. 总结：**

MySQL 选择 B+ 树作为默认的索引结构，是因为它具有以下优点：

- 高效的 **查询性能**，尤其适用于大规模数据集。
- 对 **范围查询** 和 **顺序访问** 的支持，使其在需要按顺序或区间查询时表现出色。
- **平衡性**：B+ 树自动保持平衡，插入和删除操作时不会导致查询效率的显著下降。
- **低磁盘 I/O 开销**：B+ 树减少了磁盘 I/O 操作，适合大规模存储。
- **灵活性**：支持等值查询、范围查询和顺序扫描等多种查询类型，能够满足大多数数据库应用的需求。

因此，B+ 树能够在多种查询场景下提供 **稳定高效** 的性能，特别是当数据量较大时，它能够保持优异的查询性能和良好的扩展性，这也是 MySQL 默认使用 B+ 树的主要原因。



## 17、MySQL是如何实现事务的？

## 18、MySQL中长事务可能会导致哪些问题？

## 19、MySQL中的MVCC是什么？

## 20、如果MySQL中没有MVCC、会有什么影响？

## 21、MySQL中的事务隔离级别有哪些？

## 22、MySQL默认的事务隔离级别是什么？为什么选择这个级别？

## 23、数据库的脏读、不可重复读和幻读分别是什么？

## 24、MySQL中有哪些锁类型？

## 25、MySQL的乐观锁和悲观锁是什么？

## 26、MySQL中如果发生死锁应该如何解决？

## 27、如何使用MySQL的`EXPLAIN`语句进行查询分析？

## 28、MySQL中count(*)、count(1)和count(字段名)有什么区别？

## 29、MySQL中int(11)的11表示什么？

## 30、MySQL中varchar和char有什么区别

## 31、MySQL中如何进行SQL调优？

## 32、如何在MySQL中避免单点故障？



# 十一、Redis

## 1、Redis主从复制的原理是什么？

### Redis主从复制的概念

Redis主从复制是Redis中实现数据冗余和高可用性的一种机制。它允许将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点，后者称为从节点；并且数据的复制是单向的，只能从主节点到从节点，不能从从节点到主节点。默认情况下，每台Redis服务器都是主节点；且一个主节点可以有零个或多个从节点，但一个从节点只能有一个主节点。

### Redis主从复制的作用

- 数据冗余

  主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。

- 故障恢复

  当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。

- 负载均衡

  在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。

- 高可用性

  主从复制是哨兵和集群能够实施的基础。

## 2、如何保证MySQL和Redis的数据一致性？



# 十二、缓存Cache

## 1、什么是缓存

缓存，就是**数据交换的缓冲区**，是一种用于**临时存储数据**的高效存储机制，其主要目的是**加快访问速度、减轻后台系统压力，从而提升整体性能。**我们平时说的缓存大多是指内存。目的是，把读写速度慢的介质的数据保存在读写速度快的介质中（这里的快与慢是相对概念），从而提高读写速度，减少时间消耗。例如：

- CPU高速缓存：高速缓存的读写速度远高于内存。

- - CPU读数据时，如果在高速缓存中找到所需数据，就不需要读内存
  - CPU写数据时，先写到高速缓存，再写回内存。

- 磁盘缓存：磁盘缓存其实就把常用的磁盘数据保存在内存中，内存读写速度也是远高于磁盘的。

- - 读数据时从内存中读取
  - 写数据时，可先写回内存，定时或定量写回到磁盘，或者是同步写回。



## 2、为啥要用缓存

## 3、请说说有哪些缓存算法？手写LRU代码的实现？

缓存算法中，比较常见的如下：

- **FIFO**(先进先出)

- **LRU**(最近最少使用)

  ```c++
  /*
  * 设计 最近最久未使用 LRU
  */
  #include <unordered_map>
  #include <list>
  #include <iostream>
  
  using std::cout;
  using std::endl;
  using std::unordered_map;
  using std::list;
  
  class LRU_Cache
  {
  public:
      LRU_Cache(int capacity):_capacity(capacity){}
  
      int get(int key)
      {
          auto it = _cacheMap.find(key);
          if(it == _cacheMap.end())
          {
              //未找到
              return -1;
          }
          //将访问的节点移动到双向链表得头部
          _cacheList.splice(_cacheList.begin(), _cacheList, it->second);
          return it->second->_value;
      }
  
      void put(int key, int value)
      {
          auto it = _cacheMap.find(key);
          if(it != _cacheMap.end())
          {
              //如果键已经存在，更新值，并将其移动到双向链表的头部
              it->second->_value = value;
              _cacheList.splice(_cacheList.begin(), _cacheList, it->second);
              return;
          }
  
          //如果缓存已满，移除双向链表得尾节点
          if(_cacheMap.size() == _capacity)
          {
              auto last = _cacheList.back();
              _cacheMap.erase(last._key);
              _cacheList.pop_back();
          }
  
          //添加新节点到双向链表的头部
          _cacheList.emplace_front(key, value);
          _cacheMap[key] = _cacheList.begin();
      }
  private:
      struct CacheNode
      {
          int _key;
          int _value;
          CacheNode(int k, int v):_key(k), _value(v){}
      };
  
      int _capacity;
      // 双向链表，存储缓存数据
      list<CacheNode> _cacheList;
      // 哈希表，存储键和对应在双向链表中的迭代器
      unordered_map<int, list<CacheNode>::iterator> _cacheMap;
  };
  
  int main()
  {
      LRU_Cache cache(2);
      cache.put(1, 1);
      cache.put(2, 2);
      cout << cache.get(1) << endl; // 返回1
      cache.put(3, 3);//淘汰键2
      cout << cache.get(2) << endl; // 返回-1（未找到）
      cache.put(4, 4);//淘汰键1
      cout << cache.get(1) << endl; // 返回-1（未找到）
      cout << cache.get(3) << endl; // 返回3
      cout << cache.get(4) << endl; // 返回4
      return 0;
  }
  ```

  

- **LFU**(最不经常使用)

- **ARC**(自适应替换)



## 4、常见的缓存工具和框架有哪些

在C++开发中，常见的缓存工具和框架如下：

- **Boost.Cache**：提供灵活的缓存管理，支持LRU和LFU等策略。
- **Redis**：支持多种数据结构的分布式缓存。也是最主流最常用的。
- **Intel TBB Cache**：提供线程安全的缓存实现，支持并发访问。



## 5、用了缓存之后有哪些问题

## 6、如何处理缓存穿透的问题

## 7、如何处理缓存雪崩的问题

## 8、如何处理缓存击穿的问题

## 9、缓存和DB的一致性如何保证

## 10、什么是缓存预热，如何实现缓存预热？

## 11、缓存数据的淘汰策略有哪些？































